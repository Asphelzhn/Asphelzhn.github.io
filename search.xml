<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AJAX笔记]]></title>
    <url>%2F2019%2F12%2F10%2Ffront_06_Ajax%2F</url>
    <content type="text"><![CDATA[AJAX1.概念 ASynchronous JavaScript And XML 异步的JavaScript 和 XML 1. 异步和同步：客户端和服务器端相互通信的基础上 * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。 这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验 2. 实现方式：原生的JS实现方式（了解）12345678910111213141516171819202122232425262728293031323334353637383940//1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() &#123; //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125; &#125; JQeury实现方式1. $.ajax() 语法：$.ajax({键值对}); 1234567891011121314//使用$.ajax()发送异步请求 $.ajax(&#123; url:&quot;ajaxServlet&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(&quot;出错啦...&quot;) &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 &#125;); 2. $.get()：发送get请求语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 3. $.post()：发送post请求语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 Json1. 概念JavaScript Object Notation JavaScript对象表示法 123456Person p = new Person();p.setName(&quot;张三&quot;);p.setAge(23);p.setGender(&quot;男&quot;);var p = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125;; json现在多用于存储和交换文本信息的语法 进行数据的传输 JSON 比 XML 更小、更快，更易解析。 2. 语法 基本规则 * 数据在名称/值对中：json数据是由键值对构成的 键用引号(单双都行)引起来，也可以不使用引号 值得取值类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） {“address”:{“province”：”陕西”….}} null 数据由逗号分隔：多个键值对由逗号分隔 花括号保存对象：使用{}定义json 格式 方括号保存数组：[] 获取数据: 1. json对象.键名 json对象[“键名”] 数组对象[索引] 遍历 12345678910111213141516171819202122//1.定义基本格式 var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;; var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;]; //获取person对象中所有的键和值 //for in 循环 /* for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]); &#125;*/ //获取ps中的所有值 for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125; &#125; 3. JSON数据和Java对象的相互转换JSON解析器： 常见的解析器：Jsonlib，Gson，fastjson，jackson JSON转为Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json字符串数据,Class) Java对象转换JSON使用步骤： 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 转换方法： writeValue(参数1，obj): * 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 writeValueAsString(obj):将对象转为json字符串 注解：1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 3. @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 复杂java对象转换 List：数组 Map：对象格式一致 4. 案例校验用户名是否存在 1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： 1. $.get(type):将最后一个参数type指定为&quot;json&quot; 2. 在服务器端设置MIME类型 response.setContentType(&quot;application/json;charset=utf-8&quot;);]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery笔记]]></title>
    <url>%2F2019%2F12%2F09%2Ffront_05_JQuery%2F</url>
    <content type="text"><![CDATA[JQuery 基础1.概念一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 2. 使用步骤： 下载JQuery 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） jquery-xxx.js 与 jquery-xxx.min.js区别： 12jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 导入JQuery的js文件：导入min.js文件 使用 12var div1 = $(&quot;#div1&quot;);alert(div1.html()); 3. JQuery对象和JS对象区别与转换 JQuery对象在操作时，更加方便。 JQuery对象和js对象方法不通用的. 两者相互转换 jq – &gt; js : jq对象[索引] 或者 jq对象.get(索引) js – &gt; jq : $(js对象) 4. 选择器：筛选具有相似特征的元素(标签)基本操作： 事件绑定 //1.获取b1按钮 123$(&quot;#b1&quot;).click(function()&#123; alert(&quot;abc&quot;);&#125;); 入口函数（dom文档加载完成后执行该函数代码） 123$(function () &#123; &#125;); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 样式控制：css方法 12// $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 分类 基本选择器 标签选择器（元素选择器） 语法： $(“html标签名”) 获得所有匹配标签名称的元素 id选择器 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素 类选择器 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素 并集选择器： 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(“A B “) 选择A元素内部的所有B元素 子选择器 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素 属性选择器 属性名称选择器 语法： $(“A[属性名]”) 包含指定属性的选择器 属性选择器 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器 过滤选择器 首元素选择器 语法： :first 获得选择的元素中的第一个元素 尾元素选择器 语法： :last 获得选择的元素中的最后一个元素 非元素选择器 语法： :not(selector) 不包括指定内容的元素 偶数选择器 语法： :even 偶数，从 0 开始计数 奇数选择器 语法： :odd 奇数，从 0 开始计数 等于索引选择器 语法： :eq(index) 指定索引元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素 5. DOM操作内容操作 html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 val()： 获取/设置元素的value属性值 属性操作通用属性操作 attr(): 获取/设置元素的属性 removeAttr():删除属性 prop():获取/设置元素的属性 removeProp():删除属性 attr和prop区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 对class属性操作 addClass():添加class属性值 removeClass():删除class属性值 toggleClass():切换class属性 css(): toggleClass(“one”): 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加 CRUD操作:append():父元素将子元素追加到末尾 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 prepend():父元素将子元素追加到开头 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 appendTo(): 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 prependTo()： 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 after():添加元素到元素后边 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 before():添加元素到元素前边 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 insertAfter() 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 insertBefore() 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 remove():移除元素 对象.remove():将对象删除掉 empty():清空元素的所有后代元素。 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 JQuery 高级1. 动画1.1 三种方式显示和隐藏元素默认显示和隐藏方式 show([speed,[easing],[fn]]) 参数： speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)，或表示动画时长的毫秒数值(如：1000)easing：用来指定切换效果，默认是”swing”，可用参数”linear” swing：动画执行时效果是 先慢，中间快，最后又慢 linear：动画执行时速度是匀速的 fn：在动画完成时执行的函数，每个元素执行一次。 hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 2. 遍历js的遍历方式 for(初始化值;循环结束条件;步长) jq的遍历方式1.jq对象.each(callback) 语法： jquery对象.each(function(index,element){}); index：就是元素在集合中的索引 element：就是集合中的每一个元素对象 this：集合中的每一个元素对象 回调函数返回值： true:如果当前function返回为false，则结束循环(break)。 false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2.$.each(object, [callback]) 3.for..of：jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3.事件绑定 jquery标准的绑定方式 jq对象.事件方法(回调函数)； 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 on绑定事件/off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 事件切换：toggle jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 1&lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 4.案例 广告显示和隐藏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content&#123;width:100%;height:500px;background:#999&#125; &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () &#123; //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); &#125;); //显示广告 function adShow() &#123; //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); &#125; //隐藏广告 function adHide() &#123; //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); &#125;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 整体的DIV --&gt; &lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt; &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt; &lt;/div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 抽奖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&apos;javascript&apos; type=&apos;text/javascript&apos;&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */ var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ]; var startId;//开始定时器的id var index;//随机角标 $(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); //1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () &#123; // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;,20); &#125;); //2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt; &lt;/div&gt; &lt;!-- 大像框 --&gt; &lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt; &lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;!-- 停止按钮 --&gt; &lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;&lt;/body&gt; &lt;/html&gt; 5. 插件：增强JQuery的功能 实现方式： $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) $.extend(object) 增强JQeury对象自身的功能 $/jQuery]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web 监听器和过滤器]]></title>
    <url>%2F2019%2F12%2F01%2FJavaweb_10_listener%2F</url>
    <content type="text"><![CDATA[1. Filter：过滤器1.1 概念：生活中的过滤器：净水器，空气净化器web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。过滤器的作用： 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 1.2 使用步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 代码： 12345678910111213141516171819202122@WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filterDemo1被执行了....&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 1.3 过滤器细节： web.xml配置 123456789 &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 1. 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码 123456789101112131415161718192021@WebFilter(&quot;/*&quot;)public class FilterDemo2 implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //对request对象请求消息增强 System.out.println(&quot;filterDemo2执行了....&quot;); //放行 chain.doFilter(req, resp); //对response对象的响应消息增强 System.out.println(&quot;filterDemo2回来了...&quot;); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 过滤器生命周期方法1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter:每一次请求被拦截资源时，会执行。执行多次 destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 1.4 过滤器配置详解拦截路径配置： 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：`/ ` 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置： 设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 12345678910111213141516171819202122//浏览器直接请求index.jsp资源时，该过滤器会被执行//@WebFilter(value=&quot;/index.jsp&quot;,dispatcherTypes = DispatcherType.REQUEST)//只有转发访问index.jsp时，该过滤器才会被执行//@WebFilter(value=&quot;/index.jsp&quot;,dispatcherTypes = DispatcherType.FORWARD)//浏览器直接请求index.jsp或者转发访问index.jsp。该过滤器才会被执行//@WebFilter(value=&quot;/*&quot;,dispatcherTypes =&#123; DispatcherType.FORWARD,DispatcherType.REQUEST&#125;)public class FilterDemo5 implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; System.out.println(&quot;filterDemo5....&quot;); chain.doFilter(req, resp); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; web.xml配置 //设置标签即可 1.5 过滤器链(配置多个过滤器)拦截执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 1.6 案例案例1_登录验证 需求： 访问day17_case案例的资源。验证其是否登录 如果登录了，则直接放行。 如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”。 编写LoginFilter对登录状态进行过滤123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 登录验证的过滤器 */@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; System.out.println(req); //0.强制转换 HttpServletRequest request = (HttpServletRequest) req; //1.获取资源请求路径 String uri = request.getRequestURI(); //2.判断是否包含登录相关资源路径,要注意排除掉 css/js/图片/验证码等资源 if(uri.contains(&quot;/login.jsp&quot;) || uri.contains(&quot;/loginServlet&quot;) || uri.contains(&quot;/css/&quot;) || uri.contains(&quot;/js/&quot;) || uri.contains(&quot;/fonts/&quot;) || uri.contains(&quot;/checkCodeServlet&quot;) )&#123; //包含，用户就是想登录。放行 chain.doFilter(req, resp); &#125;else&#123; //不包含，需要验证用户是否登录 //3.从获取session中获取user Object user = request.getSession().getAttribute(&quot;user&quot;); if(user != null)&#123; //登录了。放行 chain.doFilter(req, resp); &#125;else&#123; //没有登录。跳转登录页面 request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,resp); &#125; &#125; // chain.doFilter(req, resp); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 案例2_敏感词汇过滤需求： 对day17_case案例录入的数据进行敏感词汇过滤 敏感词汇参考《敏感词汇.txt》 如果是敏感词汇，替换为 *** 分析： 对request对象进行增强。增强获取参数相关方法2. 放行。传递代理对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 敏感词汇过滤器 */@WebFilter(&quot;/*&quot;)public class SensitiveWordsFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //1.创建代理对象，增强getParameter方法 ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //增强getParameter方法 //判断是否是getParameter方法 if(method.getName().equals(&quot;getParameter&quot;))&#123; //增强返回值 //获取返回值 String value = (String) method.invoke(req,args); if(value != null)&#123; for (String str : list) &#123; if(value.contains(str))&#123; value = value.replaceAll(str,&quot;***&quot;); &#125; &#125; &#125; return value; &#125; //判断方法名是否是 getParameterMap //判断方法名是否是 getParameterValue return method.invoke(req,args); &#125; &#125;); //2.放行 chain.doFilter(proxy_req, resp); &#125; private List&lt;String&gt; list = new ArrayList&lt;String&gt;();//敏感词汇集合 public void init(FilterConfig config) throws ServletException &#123; try&#123; //1.获取文件真实路径 ServletContext servletContext = config.getServletContext(); String realPath = servletContext.getRealPath(&quot;/WEB-INF/classes/敏感词汇.txt&quot;); //2.读取文件 BufferedReader br = new BufferedReader(new FileReader(realPath)); //3.将文件的每一行数据添加到list中 String line = null; while((line = br.readLine())!=null)&#123; list.add(line); &#125; br.close(); System.out.println(list); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public void destroy() &#123; &#125;&#125; 增强对象的功能：设计模式：一些通用的解决固定问题的方式 装饰模式 代理模式 概念： 真实对象：被代理的对象 代理对象： 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 实现方式： 静态代理：有一个类文件描述代理模式 动态代理：在内存中形成代理类 实现步骤： 代理对象和真实对象实现相同的接口 代理对象 = Proxy.newProxyInstance(); 使用代理对象调用方法。 增强方法 接口类 123456public interface SaleComputer &#123; public String sale(double money); public void show();&#125; 真实类 12345678910111213141516/** * 真实类 */public class Lenovo implements SaleComputer &#123; @Override public String sale(double money) &#123; System.out.println(&quot;花了&quot;+money+&quot;元买了一台联想电脑...&quot;); return &quot;联想电脑&quot;; &#125; @Override public void show() &#123; System.out.println(&quot;展示电脑....&quot;); &#125;&#125; 动态代理测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ProxyTest &#123; public static void main(String[] args) &#123; //1.创建真实对象 Lenovo lenovo = new Lenovo(); //2.动态代理增强lenovo对象 /* 三个参数： 1. 类加载器：真实对象.getClass().getClassLoader() 2. 接口数组：真实对象.getClass().getInterfaces() 3. 处理器：new InvocationHandler() */ SaleComputer proxy_lenovo = (SaleComputer) Proxy.newProxyInstance(lenovo.getClass().getClassLoader(), lenovo.getClass().getInterfaces(), new InvocationHandler() &#123; /* 代理逻辑编写的方法：代理对象调用的所有方法都会触发该方法执行 参数： 1. proxy:代理对象 2. method：代理对象调用的方法，被封装为的对象 3. args:代理对象调用的方法时，传递的实际参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /*System.out.println(&quot;该方法执行了....&quot;); System.out.println(method.getName()); System.out.println(args[0]);*/ //判断是否是sale方法 if(method.getName().equals(&quot;sale&quot;))&#123; //1.增强参数 double money = (double) args[0]; money = money * 0.85; System.out.println(&quot;专车接你....&quot;); //使用真实对象调用该方法 String obj = (String) method.invoke(lenovo, money); System.out.println(&quot;免费送货...&quot;); //2.增强返回值 return obj+&quot;_鼠标垫&quot;; &#125;else&#123; Object obj = method.invoke(lenovo, args); return obj; &#125; &#125; &#125;); //3.调用方法 /* String computer = proxy_lenovo.sale(8000); System.out.println(computer);*/ proxy_lenovo.show(); &#125;&#125; 增强方式： 增强参数列表 增强返回值类型 增强方法体执行逻辑 123456789101112131415//判断是否是sale方法 if(method.getName().equals(&quot;sale&quot;))&#123; //1.增强参数 double money = (double) args[0]; money = money * 0.85; System.out.println(&quot;专车接你....&quot;); //使用真实对象调用该方法 String obj = (String) method.invoke(lenovo, money); System.out.println(&quot;免费送货...&quot;); //2.增强返回值 return obj+&quot;_鼠标垫&quot;; &#125;else&#123; Object obj = method.invoke(lenovo, args); return obj; &#125; 2.Listener：监听器2.1 概念web的三大组件之一 事件监听机制 事件 ：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象，一段代码 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 2.2 监听器ServletContextListener:监听ServletContext对象的创建和销毁 方法： void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 12345678910111213141516171819202122232425262728293031323334353637383940@WebListenerpublic class ContextLoaderListener implements ServletContextListener &#123; /** * 监听ServletContext对象创建的。ServletContext对象服务器启动后自动创建。 * * 在服务器启动后自动调用 * @param servletContextEvent */ @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; //加载资源文件 //1.获取ServletContext对象 ServletContext servletContext = servletContextEvent.getServletContext(); //2.加载资源文件 String contextConfigLocation = servletContext.getInitParameter(&quot;contextConfigLocation&quot;); //3.获取真实路径 String realPath = servletContext.getRealPath(contextConfigLocation); //4.加载进内存 try&#123; FileInputStream fis = new FileInputStream(realPath); System.out.println(fis); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;ServletContext对象被创建了。。。&quot;); &#125; /** * 在服务器关闭后，ServletContext对象被销毁。当服务器正常关闭后该方法被调用 * @param servletContextEvent */ @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; System.out.println(&quot;ServletContext对象被销毁了。。。&quot;); &#125;&#125; 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置 web.xml 123456789&lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 指定初始化参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 注解：@WebListener]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>监听器和过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web JSP]]></title>
    <url>%2F2019%2F11%2F22%2FJavaweb_07_jsp%2F</url>
    <content type="text"><![CDATA[1. JSP1.1 概念Java Server Pages： java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 1.2 原理JSP本质上就是一个Servlet 1.3 JSP的脚本JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 1234public void _jspService()&lt;% System.out.println(&quot;hello jsp&quot;);int i =5;%&gt; &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。定义成员变量，方法，可能引发线程安全问题 1&lt;%! int i=3; %&gt; &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 1&lt;%= i %&gt; 1.4 JSP的内置对象：在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象。 request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 1.5 JSP指令作用：用于配置JSP页面，导入资源文件 格式： 1&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; 分类：page：配置JSP页面的 contentType：等同于response.setContentType() 设置响应体的mime类型以及字符集 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前也是是否是错误页面。 true：是，可以使用内置对象exception false：否。默认值。不可以使用内置对象exception include ： 页面包含的。导入页面的资源文件 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@include file=&quot;top.jsp&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;主体信息&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; taglib ： 导入资源 12&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;prefix：前缀，自定义的 1.6 注释 html注释：&lt;!-- --&gt;:只能注释html代码片段 jsp注释：推荐使用 &lt;%– –%&gt;：可以注释所有 1.7 内置对象 变量名 真实类型 作用 pageContext PageContext 当前页面内共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 2. MVC：开发模式2.1 jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，又写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 2.2 MVC M：Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图。JSP 展示数据 C：Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点： 优点：耦合性低，方便维护，可以利于分工协作，重用性高 缺点：使得项目架构变得复杂，对开发人员要求高 3. EL表达式3.1 概念Expression Language 表达式语言 3.2 作用替换和简化jsp页面中java代码的编写 3.3 语法12$&#123;表达式&#125;$&#123;3 &gt; 4&#125; 注意： jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式 1\$&#123;表达式&#125; ：忽略当前这个el表达式 3.4 使用运算 运算符： 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 123456789101112131415$&#123;3 + 4&#125;$&#123;3 / 4&#125;$&#123;3 % 4&#125;$&#123;3 == 4&#125;$&#123;3 &gt; 4 and 3 &lt; 5&#125;&lt;h4&gt;empty运算符&lt;/h4&gt;&lt;% String str = &quot;abc&quot;; request.setAttribute(&quot;str&quot;,str); List list = new ArrayList(); request.setAttribute(&quot;list&quot;,list);%&gt;$&#123;empty str&#125;$&#123;not empty list&#125; 获取值 el表达式只能从域对象中获取值 语法： ${域名称.键名}：从指定域中获取指定键的值 域名称： pageScope –&gt; pageContext requestScope –&gt; request sessionScope –&gt; session applicationScope –&gt; application（ServletContext） 举例：在request域中存储了name=张三 获取：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 1234567891011121314&lt;html&gt;&lt;body&gt; &lt;% session.setAttribute(&quot;name&quot;,&quot;李四&quot;) request.setAttribute(&quot;name&quot;,&quot;张三&quot;); request.setAttribute(&quot;age&quot;,&quot;23&quot;); %&gt; &lt;h1&gt;获取值&lt;/h1&gt; $&#123;requsetScope.name&#125;; $&#123;sessionScope.age&#125;; $&#123;name&#125; &lt;%-- 获取到张三 --%&gt;&lt;/body&gt;&lt;/html&gt; 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名} 本质上会去调用对象的getter方法 1234567891011121314151617181920212223&lt;% User user = new User(); user.setName(&quot;张三&quot;); user.setAge(23); user.setBirthday(new Date()); request.setAttribute(&quot;user&quot;,user);%&gt;&lt;h1&gt;获取对象中的值&lt;/h1&gt;$&#123;requestScope.user&#125;&lt;%-- 通过对象的属性来获取 setter或getter方法，去掉set或get，再将剩余部分，首字母变成小写 setName --&gt; name--%&gt;$&#123;requsetScope.user.name&#125;$&#123;user.age&#125;$&#123;user.birthday.year&#125;$&#123;user.birStr&#125; &lt;%-- 自定义属性方法 --%&gt; 1234567891011121314public class User&#123; private Date birthday; public String getbirStr()&#123; //格式化日期对象 if(birthday != null)&#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); retrurn sdf.format(birthday); &#125; else&#123; return &quot;&quot;; &#125; &#125;&#125; List集合：${域名称.键名[索引]} 1234567891011&lt;% List list = new ArrayList(); list.add(&quot;aaa&quot;); request.setAttributte(&quot;list&quot;,list);%&gt;&lt;h1&gt;获取List的值&lt;/h1&gt;&#123;list&#125;&#123;list[0]&#125;&#123;list[10]&#125; &lt;%-- 越界异常会返回空字符串 --%&gt; Map集合： ${域名称.键名.key名称} ${域名称.键名[“key名称”]} 123456789101112&lt;% Map map = new HashMap(); map.put(&quot;sname&quot;,&quot;李四&quot;); map.put(&quot;gender&quot;,&quot;男&quot;); map.put(&quot;user&quot;,user); request.setAttribute(&quot;map&quot;,map);%&gt;&lt;h1&gt;获取map中的值&lt;/h1&gt;$&#123;map.gender&#125;$&#123;map[&quot;gender&quot;]&#125;$&#123;map.user.name&#125; 隐式对象： el表达式中有11个隐式对象 pageContext：获取jsp其他八个内置对象 12&lt;h1&gt;动态获取虚拟目录&lt;/h1&gt;$&#123;pageContext.request.contextPath&#125; 12&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/loginServlet&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 4. JSTL标签库4.1 概念JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 4.2 作用用于简化和替换jsp页面上的java代码 4.3 使用步骤： 导入jstl相关jar包 引入标签库：taglib指令： &lt;%@ taglib %&gt; 使用标签 4.4 常用的JSTL标签 if:相当于java代码的if语句 属性： 必须有test 属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 注意： c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 12345678910111213141516171819202122232425&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;if标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% request.setAttribute(&quot;number&quot;,3); %&gt; &lt;c:if test=&quot;$&#123;number % 2 != 0&#125;&quot;&gt; &lt;h1&gt;$&#123;number&#125;为奇数&lt;/h1&gt; &lt;/c:if&gt; &lt;% //判断request域中的一个list集合是否为空，如果不为null则显示遍历集合 List list = new Arraylist(); list.add(&quot;aaa&quot;); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;c:if test=&quot;$&#123;not empty list&#125;&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt; choose:相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;if标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% request.setAttribute(&quot;number&quot;,3); %&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;number == 1&#125;&quot;&gt;星期一&lt;/c:when&gt; &lt;c:otherwise&gt;输入有误&lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/body&gt;&lt;/html&gt; foreach:相当于java代码的for语句 完成重复动作 属性： begin:开始值 end:结束值 var:临时变量 step:步长 varStatus:循环状态变量 容器中元素索引从0开始 循环次数从1开始 遍历容器 属性： items:容器对象 var:容器中元素的临时变量 varStatus:循环状态对象 ​ index:容器中元素的索引，从0开始 ​ count:循环次数，从1开始 123456789101112131415161718192021222324252627&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;foreach标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% request.setAttribute(&quot;number&quot;,3); %&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;1&quot; varStatus=&quot;s&quot;&gt; $&#123;i&#125; &lt;h3&gt;$&#123;s.index&#125;&lt;/h3&gt; &lt;h4&gt;$&#123;s.count&#125;&lt;/h4&gt; &lt;br&gt; &lt;/c:forEach&gt; &lt;% List list = new ArrayList(); list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); list.add(&quot;ccc&quot;); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt; $&#123;s.index&#125; $&#123;s.count&#125; $&#123;str&#125; &lt;br&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 4.5 实例需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% List list = new ArrayList(); list.add(new User(&quot;张三&quot;,23, new Date())); list.add(new User(&quot;李四&quot;,21, new Date())); list.add(new User(&quot;王五&quot;,25, new Date())); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;table border=&quot;1&quot; width=&quot;500&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt; &lt;c:if test=&quot;$&#123;s.count % 2 ==0&#125;&quot;&gt; &lt;tr bgcolor=&quot;red&quot;&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.birthday&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;/table&gt; &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt; $&#123;s.index&#125; $&#123;s.count&#125; $&#123;str&#125; &lt;br&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 5. 三层架构：软件设计架构 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互 业务逻辑层：处理业务逻辑的。 数据访问层：操作数据存储文件。 6. 案例：用户信息列表展示 需求：用户信息的增删改查操作 设计： 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat 数据库设计： 1234567891011create database day17; -- 创建数据库use day17; -- 使用数据库create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50)); 开发： 环境搭建 创建数据库环境 创建项目，导入需要的jar包 编码 测试 部署运维 6.1 在src.domain中编写User类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class User &#123; private int id; private String name; private String gender; private int age; private String address; private String qq; private String email; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getQq() &#123; return qq; &#125; public void setQq(String qq) &#123; this.qq = qq; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, gender=&apos;&quot; + gender + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &quot;, qq=&apos;&quot; + qq + &apos;\&apos;&apos; + &quot;, email=&apos;&quot; + email + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 6.2 编写index.jsp页面1234567891011121314151617181920212223242526&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt; &lt;title&gt;首页&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div align=&quot;center&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/userListServlet&quot; style=&quot;text-decoration:none;font-size:33px&quot;&gt;查询所有用户信息 &lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.3 在src.service中编写UserService接口1234567public interface UserService &#123; /** * 查询所有用户信息 * @return */ public List&lt;User&gt; findAll();&#125; 6.4 在src.service.impl中编写UserServiceImpl类12345678public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override public List&lt;User&gt; findAll() &#123; //调用Dao完成查询 return dao.findAll(); &#125;&#125; 6.5 在src.dao中编写UserDao接口123public interface UserDao &#123; public List&lt;User&gt; findAll();&#125; 6.6 在src.dao.impl中编写UserDaoImpl类12345678910111213public class UserDaoImpl implements UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public List&lt;User&gt; findAll() &#123; //使用JDBC操作数据库... //1.定义sql String sql = &quot;select * from user&quot;; List&lt;User&gt; users = template.query(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class)); return users; &#125;&#125; 6.7 在src.web.servlet中编写UserListServlet类12345678910111213141516@WebServlet(&quot;/userListServlet&quot;)public class UserListServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.调用UserService完成查询 UserService service = new UserServiceImpl(); List&lt;User&gt; users = service.findAll(); //2.将list存入request域 request.setAttribute(&quot;users&quot;,users); //3.转发到list.jsp request.getRequestDispatcher(&quot;/list.jsp&quot;).forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 6.8 在src下创建druid.properties配置文件12345678910driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///day17username=rootpassword=root# 初始化连接数量initialSize=5# 最大连接数maxActive=10# 最大等待时间maxWait=3000 6.9 在src.util下编写JDBCUtils类1234567891011121314151617181920212223242526272829303132333435363738public class JDBCUtils &#123; private static DataSource ds ; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接池对象 */ public static DataSource getDataSource()&#123; return ds; &#125; /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125;&#125; 6.10 编写list.jsp页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;h3 style=&quot;text-align: center&quot;&gt;用户信息列表&lt;/h3&gt; &lt;table border=&quot;1&quot; class=&quot;table table-bordered table-hover&quot;&gt; &lt;tr class=&quot;success&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;users&#125;&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;update.html&quot;&gt;修改&lt;/a&gt;&amp;nbsp;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr&gt; &lt;td colspan=&quot;8&quot; align=&quot;center&quot;&gt;&lt;a class=&quot;btn btn-primary&quot; href=&quot;add.html&quot;&gt;添加联系人&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web 案例]]></title>
    <url>%2F2019%2F11%2F21%2FJavaweb_09_exercise%2F</url>
    <content type="text"><![CDATA[1. 用户信息管理 简单功能 列表查询 登录 添加 删除 修改 复杂功能 删除选中 分页查询：减轻服务器内存的开销，提升用户体验 复杂条件查询 1.1 登录功能对list.jsp页面进行调整123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; function deleteUser(id)&#123; //用户安全提示 if(confirm(&quot;您确定要删除吗？&quot;))&#123; //访问路径 location.href=&quot;$&#123;pageContext.request.contextPath&#125;/delUserServlet?id=&quot;+id; &#125; &#125; window.onload = function()&#123; //给删除选中按钮添加单击事件 document.getElementById(&quot;delSelected&quot;).onclick = function()&#123; if(confirm(&quot;您确定要删除选中条目吗？&quot;))&#123; var flag = false; //判断是否有选中条目 var cbs = document.getElementsByName(&quot;uid&quot;); for (var i = 0; i &lt; cbs.length; i++) &#123; if(cbs[i].checked)&#123; //有一个条目选中了 flag = true; break; &#125; &#125; if(flag)&#123;//有条目被选中 //表单提交 document.getElementById(&quot;form&quot;).submit(); &#125; &#125; &#125; //1.获取第一个cb document.getElementById(&quot;firstCb&quot;).onclick = function()&#123; //2.获取下边列表中所有的cb var cbs = document.getElementsByName(&quot;uid&quot;); //3.遍历 for (var i = 0; i &lt; cbs.length; i++) &#123; //4.设置这些cbs[i]的checked状态 = firstCb.checked cbs[i].checked = this.checked; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;h3 style=&quot;text-align: center&quot;&gt;用户信息列表&lt;/h3&gt; &lt;div style=&quot;float: left;&quot;&gt; &lt;form class=&quot;form-inline&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;%--label标签点击选中输入框--%&gt; &lt;label for=&quot;exampleInputName2&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;condition.name[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName2&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputName3&quot;&gt;籍贯&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;address&quot; value=&quot;$&#123;condition.address[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName3&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail2&quot;&gt;邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;condition.email[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail2&quot; &gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=&quot;float: right;margin: 5px;&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/add.jsp&quot;&gt;添加联系人&lt;/a&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;javascript:void(0);&quot; id=&quot;delSelected&quot;&gt;删除选中&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;form&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/delSelectedServlet&quot; method=&quot;post&quot;&gt; &lt;table border=&quot;1&quot; class=&quot;table table-bordered table-hover&quot;&gt; &lt;tr class=&quot;success&quot;&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; id=&quot;firstCb&quot;&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;pb.list&#125;&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;uid&quot; value=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;&quot;&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;javascript:deleteUser($&#123;user.id&#125;);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;c:if test=&quot;$&#123;pb.currentPage == 1&#125;&quot;&gt; &lt;li class=&quot;disabled&quot;&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != 1&#125;&quot;&gt; &lt;li&gt; &lt;/c:if&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage - 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pb.totalPage&#125;&quot; var=&quot;i&quot; &gt; &lt;c:if test=&quot;$&#123;pb.currentPage == i&#125;&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != i&#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;li&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage + 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;span style=&quot;font-size: 25px;margin-left: 10px;&quot;&gt; 共$&#123;pb.totalCount&#125;条记录，共$&#123;pb.totalPage&#125;页 &lt;/span&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对login.jsp页面进行调整加入验证码功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt; &lt;title&gt;管理员登录&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //切换验证码 function refreshCode()&#123; //1.获取验证码图片对象 var vcode = document.getElementById(&quot;vcode&quot;); //2.设置其src属性，加时间戳 vcode.src = &quot;$&#123;pageContext.request.contextPath&#125;/checkCodeServlet?time=&quot;+new Date().getTime(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot; style=&quot;width: 400px;&quot;&gt; &lt;h3 style=&quot;text-align: center;&quot;&gt;管理员登录&lt;/h3&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/loginServlet&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;user&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;user&quot; placeholder=&quot;请输入用户名&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-inline&quot;&gt; &lt;label for=&quot;vcode&quot;&gt;验证码：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;verifycode&quot; class=&quot;form-control&quot; id=&quot;verifycode&quot; placeholder=&quot;请输入验证码&quot; style=&quot;width: 120px;&quot;/&gt; &lt;a href=&quot;javascript:refreshCode();&quot;&gt; &lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/checkCodeServlet&quot; title=&quot;看不清点击刷新&quot; id=&quot;vcode&quot;/&gt; &lt;/a&gt; &lt;/div&gt; &lt;hr/&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center;&quot;&gt; &lt;input class=&quot;btn btn btn-primary&quot; type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 出错显示的信息框 --&gt; &lt;div class=&quot;alert alert-warning alert-dismissible&quot; role=&quot;alert&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot; &gt; &lt;span&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;strong&gt;$&#123;login_msg&#125;&lt;/strong&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 添加CheckCodeServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package cn.itcast.web.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * 验证码 */@WebServlet(&quot;/checkCodeServlet&quot;)public class CheckCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; //服务器通知浏览器不要缓存 response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;); response.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;); response.setHeader(&quot;expires&quot;,&quot;0&quot;); //在内存中创建一个长80，宽30的图片，默认黑色背景 //参数一：长 //参数二：宽 //参数三：颜色 int width = 80; int height = 30; BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //获取画笔 Graphics g = image.getGraphics(); //设置画笔颜色为灰色 g.setColor(Color.GRAY); //填充图片 g.fillRect(0,0, width,height); //产生4个随机验证码，12Ey String checkCode = getCheckCode(); //将验证码放入HttpSession中 request.getSession().setAttribute(&quot;CHECKCODE_SERVER&quot;,checkCode); //设置画笔颜色为黄色 g.setColor(Color.YELLOW); //设置字体的小大 g.setFont(new Font(&quot;黑体&quot;,Font.BOLD,24)); //向图片上写入验证码 g.drawString(checkCode,15,25); //将内存中的图片输出到浏览器 //参数一：图片对象 //参数二：图片的格式，如PNG,JPG,GIF //参数三：图片输出到哪里去 ImageIO.write(image,&quot;PNG&quot;,response.getOutputStream()); &#125; /** * 产生4位随机字符串 */ private String getCheckCode() &#123; String base = &quot;0123456789ABCDEFGabcdefg&quot;; int size = base.length(); Random r = new Random(); StringBuffer sb = new StringBuffer(); for(int i=1;i&lt;=4;i++)&#123; //产生0到size-1的随机值 int index = r.nextInt(size); //在base字符串中获取下标为index的字符 char c = base.charAt(index); //将c放入到StringBuffer中去 sb.append(c); &#125; return sb.toString(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request,response); &#125;&#125; 编写loginServlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package cn.itcast.web.servlet;import cn.itcast.domain.User;import cn.itcast.service.UserService;import cn.itcast.service.impl.UserServiceImpl;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;/loginServlet&quot;)public class LoginServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置编码 request.setCharacterEncoding(&quot;utf-8&quot;); //2.获取数据 //2.1获取用户填写验证码 String verifycode = request.getParameter(&quot;verifycode&quot;); //3.验证码校验 HttpSession session = request.getSession(); String checkcode_server = (String) session.getAttribute(&quot;CHECKCODE_SERVER&quot;); session.removeAttribute(&quot;CHECKCODE_SERVER&quot;);//确保验证码一次性 if(!checkcode_server.equalsIgnoreCase(verifycode))&#123; //验证码不正确 //提示信息 request.setAttribute(&quot;login_msg&quot;,&quot;验证码错误！&quot;); //跳转登录页面 request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); return; &#125; Map&lt;String, String[]&gt; map = request.getParameterMap(); //4.封装User对象 User user = new User(); try &#123; BeanUtils.populate(user,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; //5.调用Service查询 UserService service = new UserServiceImpl(); User loginUser = service.login(user); //6.判断是否登录成功 if(loginUser != null)&#123; //登录成功 //将用户存入session session.setAttribute(&quot;user&quot;,loginUser); //跳转页面 response.sendRedirect(request.getContextPath()+&quot;/index.jsp&quot;); &#125;else&#123; //登录失败 //提示信息 request.setAttribute(&quot;login_msg&quot;,&quot;用户名或密码错误！&quot;); //跳转登录页面 request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 1.2 添加功能业务流程图 编写add.jsp添加用户数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!-- HTML5文档--&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;添加用户&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;center&gt;&lt;h3&gt;添加联系人页面&lt;/h3&gt;&lt;/center&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/addUserServlet&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; name=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked=&quot;checked&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot;/&gt;女 &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;年龄：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;age&quot; name=&quot;age&quot; placeholder=&quot;请输入年龄&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;address&quot;&gt;籍贯：&lt;/label&gt; &lt;select name=&quot;address&quot; class=&quot;form-control&quot; id=&quot;address&quot;&gt; &lt;option value=&quot;陕西&quot;&gt;陕西&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;qq&quot;&gt;QQ：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;qq&quot; name=&quot;qq&quot; placeholder=&quot;请输入QQ号码&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;请输入邮箱地址&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;input class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;button&quot; value=&quot;返回&quot; /&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写addUserServlet实现添加功能123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.itcast.web.servlet;import cn.itcast.domain.User;import cn.itcast.service.UserService;import cn.itcast.service.impl.UserServiceImpl;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;/addUserServlet&quot;)public class AddUserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置编码 request.setCharacterEncoding(&quot;utf-8&quot;); //2.获取参数 Map&lt;String, String[]&gt; map = request.getParameterMap(); //3.封装对象 User user = new User(); try &#123; BeanUtils.populate(user,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; //4.调用Service保存 UserService service = new UserServiceImpl(); service.addUser(user); //5.跳转到userListServlet response.sendRedirect(request.getContextPath()+&quot;/userListServlet&quot;); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 编写UserService接口定义添加方法12345678910111213/** * 用户管理的业务接口 */public interface UserService &#123; /** * 保存User * @param user */ void addUser(User user); &#125; 编写UserServiceImpl实现添加方法1234@Override public void addUser(User user) &#123; dao.add(user); &#125; 编写UserDao接口定义添加方法123456789101112131415161718/** * 用户操作的DAO */public interface UserDao &#123; public List&lt;User&gt; findAll(); User findUserByUsernameAndPassword(String username, String password); void add(User user); void delete(int id); User findById(int i); void update(User user);&#125; 编写UserDaoImpl实现添加方法123456789101112public class UserDaoImpl implements UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public void add(User user) &#123; //1.定义sql String sql = &quot;insert into user values(null,?,?,?,?,?,?,null,null)&quot;; //2.执行sql template.update(sql, user.getName(), user.getGender(), user.getAge(), user.getAddress(), user.getQq(), user.getEmail()); &#125;&#125; 1.3 删除功能业务流程图 修改list.jsp增加删除按钮123&lt;td&gt;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;&quot;&gt;修改&lt;/a&gt;&amp;nbsp;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;javascript:deleteUser($&#123;user.id&#125;);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; 编写DelUserServlet实现删除方法1234567891011121314151617@WebServlet(&quot;/delUserServlet&quot;)public class DelUserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取id String id = request.getParameter(&quot;id&quot;); //2.调用service删除 UserService service = new UserServiceImpl(); service.deleteUser(id); //3.跳转到查询所有Servlet response.sendRedirect(request.getContextPath()+&quot;/userListServlet&quot;); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 编写UserService接口定义删除方法12345678910111213/** * 用户管理的业务接口 */public interface UserService &#123; /** * 根据id删除User * @param id */ void deleteUser(String id);&#125; 编写UserServiceImpl实现删除方法1234@Override public void deleteUser(String id) &#123; dao.delete(Integer.parseInt(id)); &#125; 编写UserDao接口定义删除方法1void add(User user); 编写UserDaoImpl实现删除方法123456789101112public class UserDaoImpl implements UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public void delete(int id) &#123; //1.定义sql String sql = &quot;delete from user where id = ?&quot;; //2.执行sql template.update(sql, id); &#125;&#125; 添加JS函数实现确认删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; function deleteUser(id)&#123; //用户安全提示 if(confirm(&quot;您确定要删除吗？&quot;))&#123; //访问路径 location.href=&quot;$&#123;pageContext.request.contextPath&#125;/delUserServlet?id=&quot;+id; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;h3 style=&quot;text-align: center&quot;&gt;用户信息列表&lt;/h3&gt; &lt;div style=&quot;float: left;&quot;&gt; &lt;form class=&quot;form-inline&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;%--label标签点击选中输入框--%&gt; &lt;label for=&quot;exampleInputName2&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;condition.name[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName2&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputName3&quot;&gt;籍贯&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;address&quot; value=&quot;$&#123;condition.address[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName3&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail2&quot;&gt;邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;condition.email[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail2&quot; &gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=&quot;float: right;margin: 5px;&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/add.jsp&quot;&gt;添加联系人&lt;/a&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;javascript:void(0);&quot; id=&quot;delSelected&quot;&gt;删除选中&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;form&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/delSelectedServlet&quot; method=&quot;post&quot;&gt; &lt;table border=&quot;1&quot; class=&quot;table table-bordered table-hover&quot;&gt; &lt;tr class=&quot;success&quot;&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; id=&quot;firstCb&quot;&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;pb.list&#125;&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;uid&quot; value=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;&quot;&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;javascript:deleteUser($&#123;user.id&#125;);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;c:if test=&quot;$&#123;pb.currentPage == 1&#125;&quot;&gt; &lt;li class=&quot;disabled&quot;&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != 1&#125;&quot;&gt; &lt;li&gt; &lt;/c:if&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage - 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pb.totalPage&#125;&quot; var=&quot;i&quot; &gt; &lt;c:if test=&quot;$&#123;pb.currentPage == i&#125;&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != i&#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;li&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage + 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;span style=&quot;font-size: 25px;margin-left: 10px;&quot;&gt; 共$&#123;pb.totalCount&#125;条记录，共$&#123;pb.totalPage&#125;页 &lt;/span&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1.4 修改功能业务流程图 修改list.jsp页面1&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;&quot;&gt;修改&lt;/a&gt;&amp;nbsp; 编写findUserServlet根据id查找user12345678910111213141516171819@WebServlet(&quot;/findUserServlet&quot;)public class FindUserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取id String id = request.getParameter(&quot;id&quot;); //2.调用Service查询 UserService service = new UserServiceImpl(); User user = service.findUserById(id); //3.将user存入request request.setAttribute(&quot;user&quot;,user); //4.转发到update.jsp request.getRequestDispatcher(&quot;/update.jsp&quot;).forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 编写UserService接口根据id查找user1234567891011/** * 用户管理的业务接口 */public interface UserService &#123; /** * 根据id查询 * @param id * @return */ User findUserById(String id);&#125; 编写UserServiceImpl实现根据id查找user方法12345678public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override public User findUserById(String id) &#123; return dao.findById(Integer.parseInt(id)); &#125;&#125; 编写UserDaoImpl实现根据id查找user方法12345678910public class UserDaoImpl implements UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public User findById(int id) &#123; String sql = &quot;select * from user where id = ?&quot;; return template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), id); &#125;&#125; 编写update.jsp页面获取回显信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;修改用户&lt;/title&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;width: 400px;&quot;&gt; &lt;h3 style=&quot;text-align: center;&quot;&gt;修改联系人&lt;/h3&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/updateUserServlet&quot; method=&quot;post&quot;&gt; &lt;!-- 隐藏域 提交id--&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;$&#123;user.id&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; name=&quot;name&quot; value=&quot;$&#123;user.name&#125;&quot; readonly=&quot;readonly&quot; placeholder=&quot;请输入姓名&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;c:if test=&quot;$&#123;user.gender == &apos;男&apos;&#125;&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; /&gt;女 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;user.gender == &apos;女&apos;&#125;&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; checked /&gt;女 &lt;/c:if&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;年龄：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; value=&quot;$&#123;user.age&#125;&quot; id=&quot;age&quot; name=&quot;age&quot; placeholder=&quot;请输入年龄&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;address&quot;&gt;籍贯：&lt;/label&gt; &lt;select name=&quot;address&quot; id=&quot;address&quot; class=&quot;form-control&quot; &gt; &lt;c:if test=&quot;$&#123;user.address == &apos;陕西&apos;&#125;&quot;&gt; &lt;option value=&quot;陕西&quot; selected&gt;陕西&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;user.address == &apos;北京&apos;&#125;&quot;&gt; &lt;option value=&quot;陕西&quot; &gt;陕西&lt;/option&gt; &lt;option value=&quot;北京&quot; selected&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;user.address == &apos;上海&apos;&#125;&quot;&gt; &lt;option value=&quot;陕西&quot; &gt;陕西&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot; selected&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;qq&quot;&gt;QQ：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;qq&quot; class=&quot;form-control&quot; value=&quot;$&#123;user.qq&#125;&quot; name=&quot;qq&quot; placeholder=&quot;请输入QQ号码&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;email&quot; class=&quot;form-control&quot; value=&quot;$&#123;user.email&#125;&quot; name=&quot;email&quot; placeholder=&quot;请输入邮箱地址&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center&quot;&gt; &lt;input class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;button&quot; value=&quot;返回&quot;/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 编写UpdateUserServlet更新用户信息1234567891011121314151617181920212223242526272829@WebServlet(&quot;/updateUserServlet&quot;)public class UpdateUserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置编码 request.setCharacterEncoding(&quot;utf-8&quot;); //2.获取map Map&lt;String, String[]&gt; map = request.getParameterMap(); //3.封装对象 User user = new User(); try &#123; BeanUtils.populate(user,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; //4.调用Service修改 UserService service = new UserServiceImpl(); service.updateUser(user); //5.跳转到查询所有Servlet response.sendRedirect(request.getContextPath()+&quot;/userListServlet&quot;); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 编写UserServiceImpl实现更新用户信息方法12345678public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override public void updateUser(User user) &#123; dao.update(user); &#125;&#125; 编写UserDaoImpl实现更新用户信息方法12345678910public class UserDaoImpl implements UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public void update(User user) &#123; String sql = &quot;update user set name = ?,gender = ? ,age = ? , address = ? , qq = ?, email = ? where id = ?&quot;; template.update(sql, user.getName(), user.getGender(), user.getAge(), user.getAddress(), user.getQq(), user.getEmail(), user.getId()); &#125;&#125; 1.5 删除选中功能业务流程图 修改list.jsp页面，将选中id通过表单发送123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; function deleteUser(id)&#123; //用户安全提示 if(confirm(&quot;您确定要删除吗？&quot;))&#123; //访问路径 location.href=&quot;$&#123;pageContext.request.contextPath&#125;/delUserServlet?id=&quot;+id; &#125; &#125; window.onload = function()&#123; //给删除选中按钮添加单击事件 document.getElementById(&quot;delSelected&quot;).onclick = function()&#123; if(confirm(&quot;您确定要删除选中条目吗？&quot;))&#123; var flag = false; //判断是否有选中条目 var cbs = document.getElementsByName(&quot;uid&quot;); for (var i = 0; i &lt; cbs.length; i++) &#123; if(cbs[i].checked)&#123; //有一个条目选中了 flag = true; break; &#125; &#125; if(flag)&#123;//有条目被选中 //表单提交 document.getElementById(&quot;form&quot;).submit(); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;h3 style=&quot;text-align: center&quot;&gt;用户信息列表&lt;/h3&gt; &lt;div style=&quot;float: left;&quot;&gt; &lt;form class=&quot;form-inline&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;%--label标签点击选中输入框--%&gt; &lt;label for=&quot;exampleInputName2&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;condition.name[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName2&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputName3&quot;&gt;籍贯&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;address&quot; value=&quot;$&#123;condition.address[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName3&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail2&quot;&gt;邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;condition.email[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail2&quot; &gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=&quot;float: right;margin: 5px;&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/add.jsp&quot;&gt;添加联系人&lt;/a&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;javascript:void(0);&quot; id=&quot;delSelected&quot;&gt;删除选中&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;form&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/delSelectedServlet&quot; method=&quot;post&quot;&gt; &lt;table border=&quot;1&quot; class=&quot;table table-bordered table-hover&quot;&gt; &lt;tr class=&quot;success&quot;&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; id=&quot;firstCb&quot;&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;pb.list&#125;&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;uid&quot; value=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;&quot;&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;javascript:deleteUser($&#123;user.id&#125;);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;c:if test=&quot;$&#123;pb.currentPage == 1&#125;&quot;&gt; &lt;li class=&quot;disabled&quot;&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != 1&#125;&quot;&gt; &lt;li&gt; &lt;/c:if&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage - 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pb.totalPage&#125;&quot; var=&quot;i&quot; &gt; &lt;c:if test=&quot;$&#123;pb.currentPage == i&#125;&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != i&#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;li&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage + 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;span style=&quot;font-size: 25px;margin-left: 10px;&quot;&gt; 共$&#123;pb.totalCount&#125;条记录，共$&#123;pb.totalPage&#125;页 &lt;/span&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写DeleteSelectedServlet删除选中功能1234567891011121314151617@WebServlet(&quot;/delSelectedServlet&quot;)public class DelSelectedServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取所有id String[] ids = request.getParameterValues(&quot;uid&quot;); //2.调用service删除 UserService service = new UserServiceImpl(); service.delSelectedUser(ids); //3.跳转查询所有Servlet response.sendRedirect(request.getContextPath()+&quot;/userListServlet&quot;); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 编写UserServiceImpl实现删除选中功能12345678910111213141516public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override public void delSelectedUser(String[] ids) &#123; if(ids != null &amp;&amp; ids.length &gt; 0)&#123; //1.遍历数组 for (String id : ids) &#123; //2.调用dao删除 dao.delete(Integer.parseInt(id)); &#125; &#125; &#125;&#125; 编写UserDaoImpl实现删除选中功能12345678910111213public class UserDaoImpl implements UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public void delete(int id) &#123; //1.定义sql String sql = &quot;delete from user where id = ?&quot;; //2.执行sql template.update(sql, id); &#125;&#125; 1.6 完善删除选中功能编辑list.jsp实现全选全不选功能，以及提示信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=&quot;js/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; function deleteUser(id)&#123; //用户安全提示 if(confirm(&quot;您确定要删除吗？&quot;))&#123; //访问路径 location.href=&quot;$&#123;pageContext.request.contextPath&#125;/delUserServlet?id=&quot;+id; &#125; &#125; window.onload = function()&#123; //给删除选中按钮添加单击事件 document.getElementById(&quot;delSelected&quot;).onclick = function()&#123; if(confirm(&quot;您确定要删除选中条目吗？&quot;))&#123; var flag = false; //判断是否有选中条目 var cbs = document.getElementsByName(&quot;uid&quot;); for (var i = 0; i &lt; cbs.length; i++) &#123; if(cbs[i].checked)&#123; //有一个条目选中了 flag = true; break; &#125; &#125; if(flag)&#123;//有条目被选中 //表单提交 document.getElementById(&quot;form&quot;).submit(); &#125; &#125; &#125; //1.获取第一个cb document.getElementById(&quot;firstCb&quot;).onclick = function()&#123; //2.获取下边列表中所有的cb var cbs = document.getElementsByName(&quot;uid&quot;); //3.遍历 for (var i = 0; i &lt; cbs.length; i++) &#123; //4.设置这些cbs[i]的checked状态 = firstCb.checked cbs[i].checked = this.checked; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;h3 style=&quot;text-align: center&quot;&gt;用户信息列表&lt;/h3&gt; &lt;div style=&quot;float: left;&quot;&gt; &lt;form class=&quot;form-inline&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;%--label标签点击选中输入框--%&gt; &lt;label for=&quot;exampleInputName2&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;condition.name[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName2&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputName3&quot;&gt;籍贯&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;address&quot; value=&quot;$&#123;condition.address[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName3&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail2&quot;&gt;邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;condition.email[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail2&quot; &gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=&quot;float: right;margin: 5px;&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/add.jsp&quot;&gt;添加联系人&lt;/a&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;javascript:void(0);&quot; id=&quot;delSelected&quot;&gt;删除选中&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;form&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/delSelectedServlet&quot; method=&quot;post&quot;&gt; &lt;table border=&quot;1&quot; class=&quot;table table-bordered table-hover&quot;&gt; &lt;tr class=&quot;success&quot;&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; id=&quot;firstCb&quot;&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;pb.list&#125;&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;uid&quot; value=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;&quot;&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;javascript:deleteUser($&#123;user.id&#125;);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;c:if test=&quot;$&#123;pb.currentPage == 1&#125;&quot;&gt; &lt;li class=&quot;disabled&quot;&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != 1&#125;&quot;&gt; &lt;li&gt; &lt;/c:if&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage - 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pb.totalPage&#125;&quot; var=&quot;i&quot; &gt; &lt;c:if test=&quot;$&#123;pb.currentPage == i&#125;&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != i&#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;li&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage + 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;span style=&quot;font-size: 25px;margin-left: 10px;&quot;&gt; 共$&#123;pb.totalCount&#125;条记录，共$&#123;pb.totalPage&#125;页 &lt;/span&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1.7 分页查询功能好处 减轻服务器内存开销 提升用户体验 业务流程图 编写PageBean类，包含分页所需参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.List;/** * 分页对象 */public class PageBean&lt;T&gt; &#123; private int totalCount; // 总记录数 private int totalPage ; // 总页码 private List&lt;T&gt; list ; // 每页的数据 private int currentPage ; //当前页码 private int rows;//每页显示的记录数 public int getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(int totalCount) &#123; this.totalCount = totalCount; &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public List&lt;T&gt; getList() &#123; return list; &#125; public void setList(List&lt;T&gt; list) &#123; this.list = list; &#125; public int getCurrentPage() &#123; return currentPage; &#125; public void setCurrentPage(int currentPage) &#123; this.currentPage = currentPage; &#125; public int getRows() &#123; return rows; &#125; public void setRows(int rows) &#123; this.rows = rows; &#125; @Override public String toString() &#123; return &quot;PageBean&#123;&quot; + &quot;totalCount=&quot; + totalCount + &quot;, totalPage=&quot; + totalPage + &quot;, list=&quot; + list + &quot;, currentPage=&quot; + currentPage + &quot;, rows=&quot; + rows + &apos;&#125;&apos;; &#125;&#125; 编写FindUserbyPageServlet12345678910111213141516171819202122232425262728293031323334353637383940@WebServlet(&quot;/findUserByPageServlet&quot;)public class FindUserByPageServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); //1.获取参数 String currentPage = request.getParameter(&quot;currentPage&quot;);//当前页码 String rows = request.getParameter(&quot;rows&quot;);//每页显示条数 if(currentPage == null || &quot;&quot;.equals(currentPage))&#123; currentPage = &quot;1&quot;; &#125; if(rows == null || &quot;&quot;.equals(rows))&#123; rows = &quot;5&quot;; &#125; //获取条件查询参数 Map&lt;String, String[]&gt; condition = request.getParameterMap(); //2.调用service查询 UserService service = new UserServiceImpl(); PageBean&lt;User&gt; pb = service.findUserByPage(currentPage,rows,condition); System.out.println(pb); //3.将PageBean存入request request.setAttribute(&quot;pb&quot;,pb); request.setAttribute(&quot;condition&quot;,condition);//将查询条件存入request //4.转发到list.jsp request.getRequestDispatcher(&quot;/list.jsp&quot;).forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 在service实现类中创建findUserByPage方法1234567891011121314151617181920212223242526272829303132333435public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override public PageBean&lt;User&gt; findUserByPage(String _currentPage, String _rows, Map&lt;String, String[]&gt; condition) &#123; int currentPage = Integer.parseInt(_currentPage); int rows = Integer.parseInt(_rows); if(currentPage &lt;=0) &#123; currentPage = 1; &#125; //1.创建空的PageBean对象 PageBean&lt;User&gt; pb = new PageBean&lt;User&gt;(); //2.设置参数 pb.setCurrentPage(currentPage); pb.setRows(rows); //3.调用dao查询总记录数 int totalCount = dao.findTotalCount(condition); pb.setTotalCount(totalCount); //4.调用dao查询List集合 //计算开始的记录索引 int start = (currentPage - 1) * rows; List&lt;User&gt; list = dao.findByPage(start,rows,condition); pb.setList(list); //5.计算总页码 int totalPage = (totalCount % rows) == 0 ? totalCount/rows : (totalCount/rows) + 1; pb.setTotalPage(totalPage); return pb; &#125;&#125; 在Dao实现类中创建findTotalCount和findByPage方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class UserDaoImpl implements UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public int findTotalCount(Map&lt;String, String[]&gt; condition) &#123; //1.定义模板初始化sql String sql = &quot;select count(*) from user where 1 = 1 &quot;; StringBuilder sb = new StringBuilder(sql); //2.遍历map Set&lt;String&gt; keySet = condition.keySet(); //定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) &#123; //排除分页条件参数 if(&quot;currentPage&quot;.equals(key) || &quot;rows&quot;.equals(key))&#123; continue; &#125; //获取value String value = condition.get(key)[0]; //判断value是否有值 if(value != null &amp;&amp; !&quot;&quot;.equals(value))&#123; //有值 sb.append(&quot; and &quot;+key+&quot; like ? &quot;); params.add(&quot;%&quot;+value+&quot;%&quot;);//？条件的值 &#125; &#125; System.out.println(sb.toString()); System.out.println(params); return template.queryForObject(sb.toString(),Integer.class,params.toArray()); &#125; @Override public List&lt;User&gt; findByPage(int start, int rows, Map&lt;String, String[]&gt; condition) &#123; String sql = &quot;select * from user where 1 = 1 &quot;; StringBuilder sb = new StringBuilder(sql); //2.遍历map Set&lt;String&gt; keySet = condition.keySet(); //定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) &#123; //排除分页条件参数 if(&quot;currentPage&quot;.equals(key) || &quot;rows&quot;.equals(key))&#123; continue; &#125; //获取value String value = condition.get(key)[0]; //判断value是否有值 if(value != null &amp;&amp; !&quot;&quot;.equals(value))&#123; //有值 sb.append(&quot; and &quot;+key+&quot; like ? &quot;); params.add(&quot;%&quot;+value+&quot;%&quot;);//？条件的值 &#125; &#125; //添加分页查询 sb.append(&quot; limit ?,? &quot;); //添加分页查询参数值 params.add(start); params.add(rows); sql = sb.toString(); System.out.println(sql); System.out.println(params); return template.query(sql,new BeanPropertyRowMapper&lt;User&gt;(User.class),params.toArray()); &#125;&#125; 改造list.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;c:forEach items=&quot;$&#123;pb.list&#125;&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;uid&quot; value=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;&quot;&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=&quot;btn btn-default btn-sm&quot; href=&quot;javascript:deleteUser($&#123;user.id&#125;);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;c:if test=&quot;$&#123;pb.currentPage == 1&#125;&quot;&gt; &lt;li class=&quot;disabled&quot;&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != 1&#125;&quot;&gt; &lt;li&gt; &lt;/c:if&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage - 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pb.totalPage&#125;&quot; var=&quot;i&quot; &gt; &lt;c:if test=&quot;$&#123;pb.currentPage == i&#125;&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pb.currentPage != i&#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;li&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage + 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;span style=&quot;font-size: 25px;margin-left: 10px;&quot;&gt; 共$&#123;pb.totalCount&#125;条记录，共$&#123;pb.totalPage&#125;页 &lt;/span&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; 1.8 复杂条件查询业务流程图 更改list.jsp，完成表单123456789101112131415161718192021&lt;div style=&quot;float: left;&quot;&gt; &lt;form class=&quot;form-inline&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;%--label标签点击选中输入框--%&gt; &lt;label for=&quot;exampleInputName2&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;condition.name[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName2&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputName3&quot;&gt;籍贯&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;address&quot; value=&quot;$&#123;condition.address[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputName3&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail2&quot;&gt;邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;condition.email[0]&#125;&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail2&quot; &gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; 更改FindUserByPageServlet获取条件参数12345678910111213141516171819202122232425262728293031323334353637383940@WebServlet(&quot;/findUserByPageServlet&quot;)public class FindUserByPageServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); //1.获取参数 String currentPage = request.getParameter(&quot;currentPage&quot;);//当前页码 String rows = request.getParameter(&quot;rows&quot;);//每页显示条数 if(currentPage == null || &quot;&quot;.equals(currentPage))&#123; currentPage = &quot;1&quot;; &#125; if(rows == null || &quot;&quot;.equals(rows))&#123; rows = &quot;5&quot;; &#125; //获取条件查询参数 Map&lt;String, String[]&gt; condition = request.getParameterMap(); //2.调用service查询 UserService service = new UserServiceImpl(); PageBean&lt;User&gt; pb = service.findUserByPage(currentPage,rows,condition); System.out.println(pb); //3.将PageBean存入request request.setAttribute(&quot;pb&quot;,pb); request.setAttribute(&quot;condition&quot;,condition);//将查询条件存入request //4.转发到list.jsp request.getRequestDispatcher(&quot;/list.jsp&quot;).forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 修改UserServiceImpl完成条件查询1234567891011121314151617181920212223242526272829303132333435public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override public PageBean&lt;User&gt; findUserByPage(String _currentPage, String _rows, Map&lt;String, String[]&gt; condition) &#123; int currentPage = Integer.parseInt(_currentPage); int rows = Integer.parseInt(_rows); if(currentPage &lt;=0) &#123; currentPage = 1; &#125; //1.创建空的PageBean对象 PageBean&lt;User&gt; pb = new PageBean&lt;User&gt;(); //2.设置参数 pb.setCurrentPage(currentPage); pb.setRows(rows); //3.调用dao查询总记录数 int totalCount = dao.findTotalCount(condition); pb.setTotalCount(totalCount); //4.调用dao查询List集合 //计算开始的记录索引 int start = (currentPage - 1) * rows; List&lt;User&gt; list = dao.findByPage(start,rows,condition); pb.setList(list); //5.计算总页码 int totalPage = (totalCount % rows) == 0 ? totalCount/rows : (totalCount/rows) + 1; pb.setTotalPage(totalPage); return pb; &#125;&#125; 修改UserDaoImpl完成条件查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class UserDaoImpl implements UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); @Override public int findTotalCount(Map&lt;String, String[]&gt; condition) &#123; //1.定义模板初始化sql String sql = &quot;select count(*) from user where 1 = 1 &quot;; StringBuilder sb = new StringBuilder(sql); //2.遍历map Set&lt;String&gt; keySet = condition.keySet(); //定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) &#123; //排除分页条件参数 if(&quot;currentPage&quot;.equals(key) || &quot;rows&quot;.equals(key))&#123; continue; &#125; //获取value String value = condition.get(key)[0]; //判断value是否有值 if(value != null &amp;&amp; !&quot;&quot;.equals(value))&#123; //有值 sb.append(&quot; and &quot;+key+&quot; like ? &quot;); params.add(&quot;%&quot;+value+&quot;%&quot;);//？条件的值 &#125; &#125; System.out.println(sb.toString()); System.out.println(params); return template.queryForObject(sb.toString(),Integer.class,params.toArray()); &#125; @Override public List&lt;User&gt; findByPage(int start, int rows, Map&lt;String, String[]&gt; condition) &#123; String sql = &quot;select * from user where 1 = 1 &quot;; StringBuilder sb = new StringBuilder(sql); //2.遍历map Set&lt;String&gt; keySet = condition.keySet(); //定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) &#123; //排除分页条件参数 if(&quot;currentPage&quot;.equals(key) || &quot;rows&quot;.equals(key))&#123; continue; &#125; //获取value String value = condition.get(key)[0]; //判断value是否有值 if(value != null &amp;&amp; !&quot;&quot;.equals(value))&#123; //有值 sb.append(&quot; and &quot;+key+&quot; like ? &quot;); params.add(&quot;%&quot;+value+&quot;%&quot;);//？条件的值 &#125; &#125; //添加分页查询 sb.append(&quot; limit ?,? &quot;); //添加分页查询参数值 params.add(start); params.add(rows); sql = sb.toString(); System.out.println(sql); System.out.println(params); return template.query(sql,new BeanPropertyRowMapper&lt;User&gt;(User.class),params.toArray()); &#125;&#125;]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>用户信息列表案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web Session]]></title>
    <url>%2F2019%2F11%2F21%2FJavaweb_08_session%2F</url>
    <content type="text"><![CDATA[1. Session1.1 概念 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 1.2 使用 获取HttpSession对象： 1HttpSession session = request.getSession(); 使用HttpSession对象： 123Object getAttribute(String name) void setAttribute(String name, Object value)void removeAttribute(String name) 1.3 细节1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ 默认情况下。不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 1234HttpSession session = reques.getSession();Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());c.setMaxAge(60*60);response.addCookie(c); 2.客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化：在服务器正常关闭之前，将session对象系列化到硬盘上 session的活化：在服务器启动后，将session文件转化为内存中的session对象即可。 Tomcat会自动执行序列化和反序列化过程。 3.session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 方法。 session默认失效时间 30分钟选择性配置修改 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 1.4 session的特点 session用于存储一次会话的多次请求的数据，存在服务器端。包括重定向 session可以存储任意类型，任意大小的数据 1.5 session与Cookie的区别 session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全 1.6 案例案例需求： 1. 访问带有验证码的登录页面login.jsp 2. 用户输入用户名，密码以及验证码。 * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 * 如果验证码输入有误，跳转登录页面，提示：验证码错误 * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 LoginServlet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@WebServlet(&quot;/loginServlet&quot;)public class LoginServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置request编码 request.setCharacterEncoding(&quot;utf-8&quot;); //2.获取参数 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String checkCode = request.getParameter(&quot;checkCode&quot;); //3.先获取生成的验证码 HttpSession session = request.getSession(); String checkCode_session = (String) session.getAttribute(&quot;checkCode_session&quot;); //删除session中存储的验证码 session.removeAttribute(&quot;checkCode_session&quot;); //3.先判断验证码是否正确 if(checkCode_session!= null &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode))&#123; //忽略大小写比较 //验证码正确 //判断用户名和密码是否一致 if(&quot;zhangsan&quot;.equals(username) &amp;&amp; &quot;123&quot;.equals(password))&#123;//需要调用UserDao查询数据库 //登录成功 //存储信息，用户信息 session.setAttribute(&quot;user&quot;,username); //重定向到success.jsp response.sendRedirect(request.getContextPath()+&quot;/success.jsp&quot;); &#125;else&#123; //登录失败 //存储提示信息到request request.setAttribute(&quot;login_error&quot;,&quot;用户名或密码错误&quot;); //转发到登录页面 request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125; &#125;else&#123; //验证码不一致 //存储提示信息到request request.setAttribute(&quot;cc_error&quot;,&quot;验证码错误&quot;); //转发到登录页面 request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; login.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; document.getElementById(&quot;img&quot;).onclick = function()&#123; this.src=&quot;/day16/checkCodeServlet?time=&quot;+new Date().getTime(); &#125; &#125; &lt;/script&gt; &lt;style&gt; div&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/day16/loginServlet&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;checkCode&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;img id=&quot;img&quot; src=&quot;/day16/checkCodeServlet&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt;&lt;%=request.getAttribute(&quot;cc_error&quot;) == null ? &quot;&quot; : request.getAttribute(&quot;cc_error&quot;)%&gt;&lt;/div&gt; &lt;div&gt;&lt;%=request.getAttribute(&quot;login_error&quot;) == null ? &quot;&quot; : request.getAttribute(&quot;login_error&quot;) %&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; success.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;%=request.getSession().getAttribute(&quot;user&quot;)%&gt;,欢迎您&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web Cookie]]></title>
    <url>%2F2019%2F11%2F17%2FJavaweb_06_cookie%2F</url>
    <content type="text"><![CDATA[1. 会话技术会话：一次会话中包含多次请求和响应。 * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session 2. Cookie2.1 概念客户端会话技术，将数据保存到客户端 2.2 使用步骤123456781. 创建Cookie对象，绑定数据new Cookie(String name, String value) 2. 发送Cookie对象response.addCookie(Cookie cookie) 3. 获取Cookie，拿到数据Cookie[] request.getCookies() 12345678910111213@WebServlet(&quot;/cookieDemo1&quot;)public class CookieDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.创建Cookie对象 Cookie c = new Cookie(&quot;msg&quot;,&quot;hello&quot;); //2.发送Cookie response.addCookie(c); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 12345678910111213141516171819@WebServlet(&quot;/cookieDemo2&quot;)public class CookieDemo2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //3. 获取Cookie Cookie[] cs = request.getCookies(); //获取数据，遍历Cookies if(cs != null)&#123; for (Cookie c : cs) &#123; String name = c.getName(); String value = c.getValue(); System.out.println(name+&quot;:&quot;+value); &#125; &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 2.3 实现原理基于响应头set-cookie和请求头cookie实现 2.4 cookie的细节1.一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可 12345678protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.创建Cookie对象 Cookie c1 = new Cookie(&quot;msg&quot;,&quot;hello&quot;); Cookie c2 = new Cookie(&quot;name&quot;,&quot;zhangsan&quot;); //2.发送Cookie response.addCookie(c1); response.addCookie(c2); &#125; 2.cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储：设置生命周期 12345setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效负数：默认值零：删除cookie信息 1234567891011protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.创建Cookie对象 Cookie c1 = new Cookie(&quot;msg&quot;,&quot;setMaxAge&quot;); //2.设置cookie的存活时间 //c1.setMaxAge(30);//将cookie持久化到硬盘，30秒后会自动删除cookie文件 //c1.setMaxAge(-1); //c1.setMaxAge(300); c1.setMaxAge(0);//删除Cookie //3.发送Cookie response.addCookie(c1); &#125; 3.cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码，一般采用URL编码(%E3%F5%A2) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4.cookie共享问题？获取范围 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path)：设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”/“ 12345678910111213141516@WebServlet(&quot;/cookieDemo5&quot;)public class CookieDemo5 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.创建Cookie对象 Cookie c1 = new Cookie(&quot;msg&quot;,&quot;你好&quot;); //设置path，让当前服务器下部署的所有项目共享Cookie信息 c1.setPath(&quot;/&quot;); //3.发送Cookie response.addCookie(c1); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 不同的tomcat服务器间cookie共享问题？ setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 1setDomain(&quot;.baidu.com&quot;) //tieba.baidu.com和news.baidu.com中cookie可以共享 5.Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) ，对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 3. 案例案例：记住上一次访问时间 需求： 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为：显示时间字符串 分析： 1. 可以采用Cookie来完成 在服务器中的Servlet判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 写回 Cookie：lastTime=2018年6月10日11:50:01 没有：是第一次访问 响应数据：您好，欢迎您首次访问 写回Cookie：lastTime=2018年6月10日11:50:01 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@WebServlet(&quot;/cookieTest&quot;)public class CookieTest extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应的消息体的数据格式以及编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0)&#123; for (Cookie cookie : cookies) &#123; //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(&quot;lastTime&quot;.equals(name))&#123; //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(&quot;解码前：&quot;+value); //URL解码： value = URLDecoder.decode(value,&quot;utf-8&quot;); System.out.println(&quot;解码后：&quot;+value); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;); break; &#125; &#125; &#125; if(cookies == null || cookies.length == 0 || flag == false)&#123; //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web ServletContext对象]]></title>
    <url>%2F2019%2F11%2F16%2FJavaweb_05_servletContext%2F</url>
    <content type="text"><![CDATA[1. ServletContext对象1.1 概念代表整个web应用，可以和程序的容器(servlet容器，服务器)来通信 1.2 获取1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 //两种方式获取的对象一样 this.getServletContext(); 1.3 功能获取MIME类型： MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 `text/html` `image/jpeg` 获取：String getMimeType(String file) 1234ServletContext context = this.getServletContext();String filename = &quot;a.jpg&quot;;String mimeType = context.getMimeType(filename); 域对象：共享数据 123451. setAttribute(String name,Object value) //设置数据2. getAttribute(String name) //获取数据3. removeAttribute(String name) ServletContext对象范围：所有用户所有请求的数据 获取文件的真实(服务器)路径 方法：String getRealPath(String path) 12345678910111213// 获取文件的服务器路径String realPath = contex.getRealPath(&quot;/b.txt&quot;);File file = new File(realPath);String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问System.out.println(b);String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问System.out.println(c);String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问,src下文件会被放入WEB-INF/classes目录下System.out.println(a); 2. 案例文件下载需求： 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： 1content-disposition:attachment;filename=xxx 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet - 获取文件名称 - 使用字节输入流加载文件进内存 - 指定response的响应头： content-disposition:attachment;filename=xxx - 将数据写出到response输出流 1234&lt;body&gt; &lt;a href= &quot;day15/downloadServlet?filename=1.jpg&quot;&gt;图片1&lt;/a&gt; &lt;a href= &quot;day15/downloadServlet?filename=1.avi&quot;&gt;视频1&lt;/a&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536373839@WebServlet(&quot;/downloadServlet&quot;)public class DownloadServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取请求参数，文件名称 String filename = request.getParameter(&quot;filename&quot;); //2.使用字节输入流加载文件进内存 //2.1找到文件服务器路径 ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath(&quot;/img/&quot; + filename); //2.2用字节流关联 FileInputStream fis = new FileInputStream(realPath); //3.设置response的响应头 //3.1设置响应头类型：content-type String mimeType = servletContext.getMimeType(filename);//获取文件的mime类型 response.setHeader(&quot;content-type&quot;,mimeType); //3.2设置响应头打开方式:content-disposition //解决中文文件名问题 //1.获取user-agent请求头、 String agent = request.getHeader(&quot;user-agent&quot;); //2.使用工具类方法编码文件名即可 filename = DownLoadUtils.getFileName(agent, filename); response.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+filename); //4.将输入流的数据写出到输出流中 ServletOutputStream sos = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; int len = 0; while((len = fis.read(buff)) != -1)&#123; sos.write(buff,0,len); &#125; fis.close(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; 中文文件问题解决思路： 获取客户端使用的浏览器版本信息 根据不同的版本信息，设置filename的编码方式不同 123456789101112131415161718public class DownLoadUtils &#123; public static String getFileName(String agent, String filename) throws UnsupportedEncodingException &#123; if (agent.contains(&quot;MSIE&quot;)) &#123; // IE浏览器 filename = URLEncoder.encode(filename, &quot;utf-8&quot;); filename = filename.replace(&quot;+&quot;, &quot; &quot;); &#125; else if (agent.contains(&quot;Firefox&quot;)) &#123; // 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = &quot;=?utf-8?B?&quot; + base64Encoder.encode(filename.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;; &#125; else &#123; // 其它浏览器 filename = URLEncoder.encode(filename, &quot;utf-8&quot;); &#125; return filename; &#125;&#125;]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>ServletContext</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-SQL基本概念]]></title>
    <url>%2F2019%2F11%2F11%2Fdatabase_02_SQL%2F</url>
    <content type="text"><![CDATA[1. SQL的概念1.1 SQLStructured Query Language 结构化查询语言 1.2 SQL作用1)是一种所有关系型数据库的查询规范，不同的数据库都支持。2)通用的数据库操作语言，可以用在不同的数据库中。3)不同的数据库SQL语句有一些区别 1.3 SQL语句分类1)Data Definition Language (DDL数据定义语言) 如：建库，建表2)Data Manipulation Language(DML数据操纵语言)，如：对表中的记录操作增删改3)Data Query Language(DQL 数据查询语言)，如：对表中的查询操作4)Data Control Language(DCL 数据控制语言)，如：对用户权限的设置 1.4 MySQL的语法1)每条语句以分号结尾，如果在SQLyog中不是必须加的。2)SQL中不区分大小写，关键字中认为大写和小写是一样的3)3种注释： –空格 单行注释 / / 多行注释 # 这是mysql特有的注释方式 2. DDL操作数据库2.1 创建数据库创建数据库的几种方式创建数据库 1CREATE DATABASE 数据库名; 判断数据库是否已经存在，不存在则创建数据库 1CREATE DATABASE IF NOT EXISTS 数据库名; 创建数据库并指定字符集 1CREATE DATABASE 数据库名 CHARACTER SET 字符集; 实例 123456-- 直接创建数据库db1create database db1;-- 判断是否存在，如果不存在则创建数据库db2create database if not exists db2;-- 创建数据库并指定字符集为gbkcreate database db3 default character set gbk; 2.2 查看数据库按tab键可以自动补全关键字– 查看所有的数据库 1show databases; – 查看某个数据库的定义信息 12show create database db3;show create database db1; 2.3 修改数据库修改数据库默认的字符集 123ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集;alter database db3 character set utf8; 2.4 删除数据库删除数据库的语法 1DROP DATABASE 数据库名; 每行SQL语句需要选中再执行，可以按F9 删除db2数据库 1drop database db2; 2.5 使用数据库查看正在使用的数据库 1SELECT DATABASE(); 使用的一个mysql中的全局函数 使用/切换数据库 123456USE 数据库名;-- 查看正在使用的数据库select database();-- 改变要使用的数据库use db4; 面试题：在MySQL数据库软件中，有如下三个数据库： 登录数据库之后，输入语句：select database test2; 运行结果是什么?这是一条错误的语句，如果要选中一个数据库，应用使用：use test2; 3. DDL操作表结构3.1 创建表前提先使用某个数据库创建表 123CREATE TABLE 表名 ( 字段名1 字段类型1,字段名2 字段类型2); 3.2 MySQL数据类型常使用的数据类型如下： 详细的数据类型如下： 实例 创建student表包含id,name,birthday字段 12345create table student (id int, -- 整数name varchar(20), -- 字符串birthday date -- 生日，最后没有逗号); 3.3 查看表查看某个数据库中的所有表 1SHOW TABLES; 查看表结构 1DESC 表名; 查看创建表的SQL语句 1SHOW CREATE TABLE 表名; 查看day21数据库中的所有表 12use day21;show tables; 查看student表的结构 1desc student; 查看student的创建表SQL语句 1show create table student; 执行结果：`存在的目的是为了避免关键字的冲突 12345CREATE TABLE `student` (`id` int(11) DEFAULT NULL,`name` varchar(20) DEFAULT NULL,`birthday` date DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 3.4 快速创建一个表结构相同的表1CREATE TABLE 新表名 LIKE 旧表名; 创建s1表，s1表结构和student表结构相同 123-- 创建一个s1的表与student结构相同create table s1 like student;desc s1; 3.5 删除表直接删除表 1DROP TABLE 表名; 判断表是否存在，如果存在则删除表 1DROP TABLE IF EXISTS 表名; 具体操作： 1234-- 直接删除表s1表drop table s1;-- 判断表是否存在并删除s1表drop table if exists `create`; 与直接删除的区别如果表不存在，不删除，存在则删除 3.6 修改表结构添加表列ADD 1ALTER TABLE 表名 ADD 列名 类型; 为学生表添加一个新的字段remark,类型为varchar(20) 1alter table student add remark varchar(20); 修改列类型MODIFY 1ALTER TABLE 表名 MODIFY列名 新的类型; 将student表中的remark字段的改成varchar(100) 1alter table student modify remark varchar(100); 修改列名 CHANGEALTER TABLE 表名 CHANGE 旧列名 新列名 类型; 将student表中的remark字段名改成intro，类型varchar(30) 1alter table student change remark intro varchar(30); 删除列 DROPALTER TABLE 表名 DROP 列名; 删除student表中的字段intro 1alter table drop intro varchar(30); 修改表名RENAME TABLE 表名 TO 新表名; 将学生表student改名成student2 1rename table student to student2; 修改字符集character setALTER TABLE 表名 character set 字符集; 将student2表的编码修改成gbk 1alter table student2 character set gbk; 4.DML操作表中的数据用于对表中的记录进行增删改操作 4.1 插入记录INSERT [INTO] 表名 [字段名] VALUES (字段值) 123INSERT INTO 表名：表示往哪张表中添加数据(字段名1, 字段名2, …)：要给哪些字段设置值VALUES (值1, 值2, …)：设置具体的值 插入全部字段所有的字段名都写出来INSERT INTO 表名 (字段名1, 字段名2, 字段名3…) VALUES (值1, 值2, 值3); 插入所有的列，向学生表中 12insert into student (id,name,age,sex) values (1, &apos;孙悟空&apos;, 20, &apos;男&apos;);insert into student (id,name,age,sex) values (2, &apos;孙悟天&apos;, 16, &apos;男&apos;); 不写字段名INSERT INTO 表名 VALUES (值1, 值2, 值3…); 插入部分数据INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2, …); 注：没有添加数据的字段会使用NULL 向表中插入所有字段 12345-- 插入所有列insert into student values (3, &apos;孙悟饭&apos;, 18, &apos;男&apos;, &apos;龟仙人洞中&apos;);-- 如果只插入部分列，必须写列名insert into student values (3, &apos;孙悟饭&apos;, 18, &apos;男&apos;);select * from student; insert的注意事项： 123451) 插入的数据应与字段的数据类型相同2) 数据的大小应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中。3) 在values中列出的数据位置必须与被加入的列的排列位置相对应。在mysql中可以使用value，但不建议使用，功能与values相同。4) 字符和日期型数据应包含在单引号中。MySQL中也可以使用双引号做为分隔符。5) 不指定列或使用null，表示插入空值。 4.2 DOS命令窗口操作数据乱码问题的解决当我们使用DOS命令行进行SQL语句操作如有有中文会出现乱码 乱码产生的原因 查看 MySQL 内部设置的编码查看包含character开头的全局变量 1show variables like &apos;character%&apos;; 解决方案修改client、connection、results的编码为GBK，保证和DOS命令行编码保持一致 单独设置 1set character_set_client=gbk; # 修改客户端的字符集为GBK 1set character_set_connection=gbk; # 修改连接的字符集为GBK 1set character_set_results=gbk; # 修改查询的结果字符集为GBK 同时设置三项 1set names gbk; 修改查询的结果字符集为GBK 修改连接的字符集为GBKset character_set_results=gbk;修改查询的结果字符集为GBK]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库 - MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用API Arrays类]]></title>
    <url>%2F2019%2F11%2F10%2FJava_api_05_arrays%2F</url>
    <content type="text"><![CDATA[1.Arrays类1.1 概述java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 1.2 操作数组的方法 public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。 12345678910public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;2,34,35,4,657,8,69,9&#125;; // 打印数组,输出地址值 System.out.println(arr); // [I@2ac1fdc4 // 数组内容转为字符串 String s = Arrays.toString(arr); // 打印字符串,输出内容 System.out.println(s); // [2, 34, 35, 4, 657, 8, 69, 9]&#125; public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 12345678910public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;24, 7, 5, 48, 4, 46, 35, 11, 6, 2&#125;; System.out.println(&quot;排序前:&quot;+ Arrays.toString(arr)); // 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6, 2] // 升序排序 Arrays.sort(arr); System.out.println(&quot;排序后:&quot;+ Arrays.toString(arr));// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46, 48]&#125; 1.3 实例使用Arrays 相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。 1234567891011121314public class ArraysTest &#123; public static void main(String[] args) &#123; // 定义随机的字符串 String line = &quot;ysKUreaytWTRHsgFdSAoidq&quot;; // 转换为字符数组 char[] chars = line.toCharArray(); // 升序排序 Arrays.sort(chars); // 反向遍历打印 for (int i = chars.length‐1; i &gt;= 0 ; i‐‐) &#123; System.out.print(chars[i]+&quot; &quot;); // y y t s s r q o i g e d d a W U T S R K H F A &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java API</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用API ArrayList类]]></title>
    <url>%2F2019%2F11%2F08%2FJava_api_03_arraylist%2F</url>
    <content type="text"><![CDATA[1. ArrayList类1.1 引入——对象数组使用学生数组，存储三个学生对象，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; publicvoid setName(String name) &#123; this.name = name; &#125; publicint getAge() &#123; return age; &#125; publicvoid setAge(int age) &#123; this.age = age; &#125;&#125;public class Test01StudentArray &#123; public static void main(String[] args) &#123; //创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student(&quot;曹操&quot;,40); Student s2 = new Student(&quot;刘备&quot;,35); Student s3 = new Student(&quot;孙权&quot;,30); //把学生对象作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for(int x=0; x&lt;students.length; x++) &#123; Student s = students[x]; System.out.println(s.getName()+&quot;‐‐‐&quot;+s.getAge()); &#125; &#125;&#125; 选择的容器是对象数组。而数组的长度是固定的，无法适应数据变化的需求。为了解决这个问题，Java提供了另一个容器java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据。 1.2 什么是ArrayList类java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。 1.3 ArrayList使用步骤查看类java.util.ArrayList &lt;E&gt; ：该类需要 import导入使后使用。 ，表示一种指定的数据类型，叫做泛型。E ，取自Element（元素）的首字母。在出现E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下： 1ArrayList&lt;String&gt;，ArrayList&lt;Student&gt; 查看构造方法public ArrayList() ：构造一个内容为空的集合。基本格式: 1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 在JDK 7后，右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式： 1ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 查看成员方法public boolean add(E e) ： 将指定的元素添加到此集合的尾部。参数 E e ，在构造ArrayList对象时， 指定了什么数据类型，那么add(E e) 方法中，只能添加什么数据类型的对象。使用ArrayList类，存储三个字符串元素，代码如下： 123456789101112131415161718public class Test02StudentArrayList &#123; public static void main(String[] args) &#123; //创建学生数组 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //创建学生对象 String s1 = &quot;曹操&quot;; String s2 = &quot;刘备&quot;; String s3 = &quot;孙权&quot;; //打印学生ArrayList集合 System.out.println(list); //把学生对象作为元素添加到集合 list.add(s1); list.add(s2); list.add(s3); //打印学生ArrayList集合 System.out.println(list); &#125;&#125; 1.4 常用方法和遍历对于元素的操作,基本体现在——增、删、查。常用的方法有：public boolean add(E e) ：将指定的元素添加到此集合的尾部。public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 12345678910111213141516171819202122public class Demo01ArrayListMethod &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); //public E get(int index):返回指定索引处的元素 System.out.println(&quot;get:&quot;+list.get(0)); System.out.println(&quot;get:&quot;+list.get(1)); System.out.println(&quot;get:&quot;+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println(&quot;size:&quot;+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println(&quot;remove:&quot;+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++)&#123; System.out.println(list.get(i)); &#125; &#125;&#125; 1.5 存储基本数据类型ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下： 只有Integer 和Character 需要特殊记忆，其他基本类型只是首字母大写即可。那么存储基本类型数据，代码如下： 12345678910public class Demo02ArrayListMethod &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); System.out.println(list); &#125;&#125;]]></content>
      <categories>
        <category>Java API</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组和内存管理]]></title>
    <url>%2F2019%2F11%2F08%2FJava_17_array%2F</url>
    <content type="text"><![CDATA[数组定义和访问1.数组定义数组定义方法有三种： 数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度]; 1int[] arr = new int[3]; 数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3…}; 1int[] arr = new int[]&#123;1,2,3,4,5&#125;; 数据类型[] 数组名 = {元素1,元素2,元素3…}; 1int[] arr = &#123;1,2,3,4,5&#125;; 2.数组的访问 索引： 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 1234567891011public static void main(String[] args) &#123;//定义存储int类型数组，赋值元素1，2，3，4，5int[] arr = &#123;1,2,3,4,5&#125;;//为0索引元素赋值为6arr[0] = 6;//获取数组0索引上的元素int i = arr[0];System.out.println(i);//直接输出数组0索引元素System.out.println(arr[0]);&#125; 数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为： 数组名.length ，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，数组的最大索引值为数组名.length-1 。 12345public static void main(String[] args) &#123;int[] arr = new int[]&#123;1,2,3,4,5&#125;;//打印数组的属性，输出结果是5System.out.println(arr.length);&#125; 数组原理内存图1.内存概述内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 2.Java虚拟机的内存划分为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 JVM的内存划分： 区域名称 作用 寄存器 给CPU使用，和我们开发无关。 本地方法栈 JVM在使用操作系统功能的时候使用，和我们开发无关。 方法区 存储可以运行的class文件。 堆内存 存储对象或者数组，new来创建的，都存储在堆内存。 方法栈 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 3.数组在内存中的存储3.1 一个数组内存图1234public static void main(String[] args) &#123;int[] arr = new int[3];System.out.println(arr);//[I@5f150435&#125; 以上方法执行，输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素 3.2 两个数组内存图123456public static void main(String[] args) &#123;int[] arr = new int[3];int[] arr2 = new int[2];System.out.println(arr);System.out.println(arr2);&#125; 3.3 两个变量指向一个数组12345678910111213141516public static void main(String[] args) &#123;// 定义数组，存储3个元素int[] arr = new int[3];//数组索引进行赋值arr[0] = 5;arr[1] = 6;arr[2] = 7;//输出3个索引上的元素值System.out.println(arr[0]);System.out.println(arr[1]);System.out.println(arr[2]);//定义数组变量arr2，将arr的地址赋值给arr2int[] arr2 = arr;arr2[1] = 9;System.out.println(arr[1]);&#125; 数组的常见操作1.数组越界异常1234public static void main(String[] args) &#123;int[] arr = &#123;1,2,3&#125;;System.out.println(arr[3]);&#125; 创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 2.数组空指针异常12345public static void main(String[] args) &#123;int[] arr = &#123;1,2,3&#125;;arr = null;System.out.println(arr[0]);｝ arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出NullPointerException 空指针异常。在开发中，数组空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 数组作为方法参数和返回值1.数组作为方法参数以前的方法中我们学习了方法的参数和返回值，但是使用的都是基本数据类型。那么作为引用类型的数组能否作为方法的参数进行传递呢，当然是可以的。数组作为方法参数传递，传递的参数是数组内存的地址。 1234567891011121314public static void main(String[] args) &#123;int[] arr = &#123; 1, 3, 5, 7, 9 &#125;;//调用方法，传递数组printArray(arr);&#125;/*创建方法，方法接收数组类型的参数进行数组的遍历*/public static void printArray(int[] arr) &#123;for (int i = 0; i &lt; arr.length; i++) &#123;System.out.println(arr[i]);&#125;&#125; 2.数组作为方法返回值数组作为方法的返回值，返回的是数组的内存地址 1234567891011121314151617public static void main(String[] args) &#123;//调用方法，接收数组的返回值//接收到的是数组的内存地址int[] arr = getArray();for (int i = 0; i &lt; arr.length; i++) &#123;System.out.println(arr[i]);&#125;&#125;/*创建方法，返回值是数组类型return返回数组的地址*/public static int[] getArray() &#123;int[] arr = &#123; 1, 3, 5, 7, 9 &#125;;//返回数组的地址，返回到调用者return arr;&#125; 3.方法的参数类型区别123456789public static void main(String[] args) &#123;int[] arr = &#123;1,3,5&#125;;System.out.println(arr[0]);change(arr);System.out.println(arr[0]);&#125;public static void change(int[] arr) &#123;arr[0] = 200;&#125; 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.]]></content>
      <categories>
        <category>Java数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用API String类]]></title>
    <url>%2F2019%2F11%2F08%2FJava_api_04_string%2F</url>
    <content type="text"><![CDATA[1.String类1.1 概述java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如”abc” ）都可以被看作是实现此类的实例。类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。 1.2 特点 字符串不变：字符串的值在创建后不能被更改。 1234String s1 = &quot;abc&quot;;s1 += &quot;d&quot;;System.out.println(s1); // &quot;abcd&quot;// 内存中有&quot;abc&quot;，&quot;abcd&quot;两个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。 因为String对象是不可变的，所以它们可以被共享。 123String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。 “abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ } 。 123456例如：String str = &quot;abc&quot;;相当于：char data[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;;String str = new String(data);// String底层是靠字符数组实现的。 1.3 使用步骤查看类java.lang.String ：此类不需要导入。查看构造方法public String() ：初始化新创建的 String对象，以使其表示空字符序列。public String(char[] value) ：通过当前参数中的字符数组来构造新的String。public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。构造举例，代码如下： 12345678// 无参构造String str = new String（）；// 通过字符数组构造char chars[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;;String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;;String str3 = new String(bytes); 1.4 常用方法判断功能的方法 public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写。 12345678910111213141516public class String_Demo01 &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; String s3 = &quot;HELLO&quot;; // boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(s1.equals(s2)); // true System.out.println(s1.equals(s3)); // false System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); //boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); // true System.out.println(s1.equalsIgnoreCase(s3)); // true System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); &#125;&#125; Object 是” 对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。 注意 1234567public class String_Demo01 &#123; public static void main(String[] args) &#123; String str5 = null; System.out.println(&quot;abc&quot;.equalsIgnoreCase(str5));// 推荐，false System.out.println(&quot;str5&quot;.equalsIgnoreCase(&quot;abc&quot;));// 不推荐，报错，空指针异常 &#125;&#125; 获取功能的方法public int length () ：返回此字符串的长度。public String concat (String str) ：将指定的字符串连接到该字符串的末尾。public char charAt (int index) ：返回指定索引处的 char值。public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。 1234567891011121314151617181920212223242526272829public class String_Demo02 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;helloworld&quot;; // int length():获取字符串的长度，其实也就是字符个数 System.out.println(s.length()); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String concat (String str):将将指定的字符串连接到该字符串的末尾. String s = &quot;helloworld&quot;; String s2 = s.concat(&quot;**hello itheima&quot;); System.out.println(s2);// helloworld**hello itheima // char charAt(int index):获取指定索引处的字符 System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1 System.out.println(s.indexOf(&quot;l&quot;)); System.out.println(s.indexOf(&quot;owo&quot;)); System.out.println(s.indexOf(&quot;ak&quot;)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String substring(int start):从start开始截取字符串到字符串结尾 System.out.println(s.substring(0)); System.out.println(s.substring(5)); System.out.println(&quot;‐‐‐‐‐‐‐‐&quot;); // String substring(int start,int end):从start到end截取字符串。含start，不含end。 System.out.println(s.substring(0, s.length())); System.out.println(s.substring(3,8)); &#125;&#125; 转换功能的方法public char[] toCharArray () ：将此字符串转换为新的字符数组。public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 1234567891011121314151617181920212223public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;abcde&quot;; // char[] toCharArray():把字符串转换为字符数组 char[] chs = s.toCharArray(); for(int x = 0; x &lt; chs.length; x++) &#123; System.out.println(chs[x]); &#125; System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); // byte[] getBytes ():把字符串转换为字节数组 byte[] bytes = s.getBytes(); for(int x = 0; x &lt; bytes.length; x++) &#123; System.out.println(bytes[x]); &#125; System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); // 替换字母it为大写IT String str = &quot;itcast itheima&quot;; String replace = str.replace(&quot;it&quot;, &quot;IT&quot;); System.out.println(replace); // ITcast ITheima System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;); &#125;&#125; CharSequence 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中。 分割功能的方法public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。 12345678910public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = &quot;aa|bb|cc&quot;; String[] strArray = s.split(&quot;|&quot;); // [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;] for(int x = 0; x &lt; strArray.length; x++) &#123; System.out.println(strArray[x]); // aa bb cc &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java API</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类与对象]]></title>
    <url>%2F2019%2F11%2F08%2FJavaoop_01_object%2F</url>
    <content type="text"><![CDATA[Java面向对象1.类的定义定义类：就是定义类的成员，包括成员变量和成员方法。成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。成员方法：和以前定义方法几乎是一样的。只不过把static去掉。 1234567891011121314public class Student &#123; //成员变量 String name；//姓名 int age；//年龄 //成员方法 //学习的方法 publicvoid study() &#123; System.out.println(&quot;好好学习，天天向上&quot;); &#125; //吃饭的方法 publicvoid eat() &#123; System.out.println(&quot;学习饿了要吃饭&quot;); &#125;&#125; 2.对象的使用123456789101112131415161718192021public class Test01_Student &#123; public static void main(String[] args) &#123; //创建对象格式：类名 对象名 = new 类名(); Student s = new Student(); System.out.println(&quot;s:&quot;+s); //cn.itcast.Student@100363 //直接输出成员变量值 System.out.println(&quot;姓名：&quot;+s.name); //null System.out.println(&quot;年龄：&quot;+s.age); //0 System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐&quot;); //给成员变量赋值 s.name = &quot;赵丽颖&quot;; s.age = 18; //再次输出成员变量的值 System.out.println(&quot;姓名：&quot;+s.name); //赵丽颖 System.out.println(&quot;年龄：&quot;+s.age); //18 System.out.println(&quot;‐‐‐‐‐‐‐‐‐‐&quot;); //调用成员方法 s.study(); // &quot;好好学习，天天向上&quot; s.eat(); // &quot;学习饿了要吃饭&quot; &#125;&#125; 成员变量的默认值 数据类型 默认值 基本类型 基本类型整数（byte，short，int，long） 0 浮点数（float，double） 0.0 字符（char） ‘\u0000’ 布尔（boolean） false 引用类型 数组，类，接口 null 3.对象内存图3.1一个对象，调用一个方法内存图 通过上图，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？ 3.2 两个对象，调用同一方法内存图 对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。 3.3 一个引用，作为参数传递到方法中内存图 引用类型作为参数，传递的是地址值。 4.成员变量和局部变量区别变量根据定义位置的不同，给变量起了不同的名字。如下图所示： 在类中的位置不同成员变量：类中，方法外局部变量：方法中或者方法声明上(形式参数) 作用范围不一样成员变量：类中局部变量：方法中 初始化值的不同成员变量：有默认值局部变量：没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 了解成员变量：堆内存局部变量：栈内存 生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 封装面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。 1.封装的步骤 使用 private 关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对 getXxx 方法 、setXxx 方法。 2.封装的操作——private关键字private的含义 private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 private的使用格式 使用 private 修饰成员变量 1234public class Student &#123; private String name; private int age;&#125; 提供 getXxx 方法 / setXxx 方法，可以访问成员变量 12345678910111213141516public class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125;&#125; 3.this关键字this代表所在类的当前对象的引用（地址值），即对象自己的引用。 方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 123456789101112131415161718public class Student &#123; private String name; private int age; public void setName(String name) &#123; //name = name; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; //age = age; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 4.构造方法当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。 无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。 构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void。使用构造方法后，代码如下： 1234567891011public class Student &#123; private String name; private int age; // 无参数构造方法 public Student() &#123;&#125; // 有参数构造方法 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125;&#125; 注意事项 如果你不提供构造方法，系统会给出无参数构造方法。 如果你提供了构造方法，系统将不再提供无参数构造方法。 构造方法是可以重载的，既可以定义参数，也可以不定义参数。 5.标准代码——JavaBeanJavaBean 是 Java语言编写类的一种标准规范。符合JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的set 和get 方法。 123456789101112131415161718192021222324public class Student &#123; //成员变量 private String name; private int age; //构造方法 public Student() &#123;&#125; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; //成员方法 publicvoid setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; publicvoid setAge(int age) &#123; this.age = age; &#125; publicint getAge() &#123; return age; &#125;&#125;]]></content>
      <categories>
        <category>Java面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用API Random类]]></title>
    <url>%2F2019%2F11%2F08%2FJava_api_02_random%2F</url>
    <content type="text"><![CDATA[1. Random类1.1 概述此类的实例用于生成伪随机数。例如，以下代码使用户能够得到一个随机数： 12Random r = new Random();int i = r.nextInt(); 1.2 Random使用步骤查看类java.util.Random ：该类需要 import导入使后使用。查看构造方法public Random() ：创建一个新的随机数生成器。查看成员方法 public int nextInt(int n) ：返回一个伪随机数，范围在 0 （包括）和指定值 n （不包括）之间的int 值。 使用Random类，完成生成3个10以内的随机整数的操作，代码如下： 1234567891011121314//1. 导包import java.util.Random;public class Demo01_Random &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++)&#123; //3. 随机生成一个数据 int number = r.nextInt(10); //4. 输出数据 System.out.println(&quot;number:&quot;+ number); &#125; &#125;&#125; 创建一个Random 对象，每次调用nextInt() 方法，都会生成一个随机数。 1.3 获取1-n之间的随机数r.next(n)生成[0,n)之间的数 12345678910111213// 导包import java.util.Random;public class Test01Random &#123; public static void main(String[] args) &#123; int n = 50; // 创建对象 Random r = new Random(); // 获取随机数 int number = r.nextInt(n) + 1; // 输出随机数 System.out.println(&quot;number:&quot; + number); &#125;&#125; 1.4 猜数字小游戏游戏开始时，会随机生成一个1-100之间的整数number 。玩家猜测一个数字guessNumber ，会与number 作比较，系统提示大了或者小了，直到玩家猜中，游戏结束。 123456789101112131415161718192021222324// 导包import java.util.Random;public class Test02Random &#123; public static void main(String[] args) &#123; // 系统产生一个随机数1‐100之间的。 Random r = new Random(); int number = r.nextInt(100) + 1; while(true)&#123; // 键盘录入我们要猜的数据 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你要猜的数字(1‐100)：&quot;); int guessNumber = sc.nextInt(); // 比较这两个数据(用if语句) if (guessNumber &gt; number) &#123; System.out.println(&quot;你猜的数据&quot; + guessNumber + &quot;大了&quot;); &#125; else if (guessNumber &lt; number) &#123; System.out.println(&quot;你猜的数据&quot; + guessNumber + &quot;小了&quot;); &#125; else &#123; System.out.println(&quot;恭喜你,猜中了&quot;); break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java API</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用API Scanner类]]></title>
    <url>%2F2019%2F11%2F08%2FJava_api_01_scanner%2F</url>
    <content type="text"><![CDATA[1. API1.1 概述API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。 1.2 API使用步骤 打开帮助文档。 点击显示，找到索引，看到输入框。 你要找谁？在输入框里输入，然后回车。 看包。java.lang下的类不需要导包，其他需要。 看类的解释和说明。 学习构造方法。 使用成员方法。 2.Scanner类一个可以解析基本类型和字符串的简单文本扫描器。 例如，以下代码使用户能够从 System.in 中读取一个数： 12Scanner sc = new Scanner(System.in);int i = sc.nextInt(); System.in 系统输入指的是通过键盘录入数据。 2.1 引用类型使用步骤导包使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。 格式： 1java.util.Scanner; 创建对象使用该类的构造方法，创建一个该类的对象。 格式： 1Scanner sc = new Scanner(System.in); 调用方法 调用该类的成员方法，完成指定功能。 格式： 1int i = sc.nextInt(); // 接收一个键盘录入的整数 2.2 Scanner使用步骤查看类java.util.Scanner ：该类需要import导入后使用。查看构造方法public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。 System.in表示从键盘输入 查看成员方法public int nextInt() ：将输入信息的下一个标记扫描为一个 int 值。 使用Scanner类，完成接收键盘录入数据的操作，代码如下： 12345678910111213//1. 导包import java.util.Scanner;public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println(&quot;请录入一个整数：&quot;); int i = sc.nextInt(); //4. 输出数据 System.out.println(&quot;i:&quot;+i); &#125;&#125; 3.匿名对象创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。匿名对象 ：没有变量名的对象。 1new Scanner(System.in)； 3.1 应用场景 创建匿名对象直接调用方法，没有变量名。 1new Scanner(System.in).nextInt(); 一旦调用两次方法，就是创建了两个对象，造成浪费，请看如下代码。一个匿名对象，只能使用一次。 12new Scanner(System.in).nextInt();new Scanner(System.in).nextInt(); 匿名对象可以作为方法的参数和返回值 作为参数： 123456789101112class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125;&#125; 作为返回值 1234567891011121314class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125;&#125;]]></content>
      <categories>
        <category>Java API</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web response对象]]></title>
    <url>%2F2019%2F11%2F08%2FJavaweb_04_response%2F</url>
    <content type="text"><![CDATA[1. HTTP协议：响应消息1.1 请求消息：客户端发送给服务器端的数据数据格式： 请求行 请求头 请求空行 请求体 1.2 响应消息：服务器端发送给客户端的数据数据格式： 1.2.1 响应行a. 组成：协议/版本 响应状态码 状态码描述 b. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 状态码都是3位数字 分类： 1xx：服务器接收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。 404（请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 1.2.2 响应头格式：头名称： 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 值： in-line:默认值，在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。文件下载 1.2.3 响应空行1.2.4 响应体传输的数据 1.2.5 响应字符串格式12345678910111213HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 2.Response对象功能：设置响应消息 2.1设置响应行格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 2.2设置响应头setHeader(String name, String value) 2.3 设置响应体使用步骤： 1.获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 2.使用输出流， 将数据输出到客户端浏览器 2.4案例1.完成重定向 重定向：资源跳转的方式 代码实现： 12345678//1. 设置状态码为302response.setStatus(302);//2.设置响应头locationresponse.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);//简单的重定向方法，方法2response.sendRedirect(&quot;/day15/responseDemo2&quot;); 2.重定向的特点:redirect 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 3.转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 forward 和 redirect 区别 3.路径写法3.1路径分类1.相对路径：通过相对路径不可以确定唯一资源 1如：./index.html 不以/开头，以.开头路径 规则：找到当前资源和目标资源之间的相对位置关系 12./：当前目录../:后退一级目录 2.绝对路径：通过绝对路径可以确定唯一资源 1如：http://localhost/day15/responseDemo2 /day15/responseDemo2 以/开头的路径 3.规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)，重定向也需要 123建议虚拟目录动态获取：String contextPath = request.getContextPath() // 等于/day15&lt;a href=&quot;/day15/responseDemo2&quot;&gt; , &lt;form&gt; 给服务器使用：不需要加虚拟目录 12转发路径request.getRequestDispatcher(&quot;/responseDemo2&quot;).forward(request,response); 4.服务器输出字符数据到浏览器步骤： 1. 获取字符输出流 2. 输出数据 12PrintWriter pw = response.getWriter();pw.write(&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;) //可以输出html 乱码问题： PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码 //1.设置编码，是在获取流之前设置 response.setCharacterEncoding(“utf-8”); //2.告诉浏览器，服务器发送的消息体数据的编码，建议使用该编码解码，text/html是mime类型 response.setHeader(“content-type”,”text/html;charset=utf-8”); //3.简单的形式 response.setContentType(“text/html;charset=utf-8”) 5.服务器输出字节数据到浏览器 获取字节输出流 输出数据 1234response.setContentType(&quot;text/html;charset=utf-8&quot;) // 设置response编码ServletOutputStream sos = response.getOutputStream();sos.write(&quot;hello&quot;.getBytes(“utf-8&quot;)); 6.验证码本质：图片目的：防止恶意表单注册 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@WebServlet(&quot;/checkCodeServlet&quot;)public class CheckCodeServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.BLUE); g.drawRect(0,0,width - 1,height - 1); String str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789&quot;; //生成随机角标 Random ran = new Random(); for (int i = 1; i &lt;= 4; i++) &#123; int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 //2.3写验证码 g.drawString(ch+&quot;&quot;,width/5*i,height/2); &#125; //2.4画干扰线 g.setColor(Color.GREEN); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); &#125; //3.将图片输出到页面展示 ImageIO.write(image,&quot;jpg&quot;,response.getOutputStream()); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; 编写HTML文件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; /* 分析： 点击超链接或者图片，需要换一张 1.给超链接和图片绑定单击事件 2.重新设置图片的src属性值 */ window.onload = function()&#123; //1.获取图片对象 var img = document.getElementById(&quot;checkCode&quot;); //2.绑定单击事件 img.onclick = function()&#123; //加时间戳 var date = new Date().getTime(); img.src = &quot;/day15/checkCodeServlet?&quot;+date; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;checkCode&quot; src=&quot;/day15/checkCodeServlet&quot; /&gt; &lt;a id=&quot;change&quot; href=&quot;&quot;&gt;看不清换一张？&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Django框架笔记]]></title>
    <url>%2F2019%2F11%2F06%2Fpythonweb_02_django%2F</url>
    <content type="text"><![CDATA[Django1 软件框架一个公司是由公司中的各部部门来组成的，每一个部门拥有特定的职能，部门与部门之间通过相互的配合来完成让公司运转起来。 一个软件框架是由其中各个软件模块组成的，每一个模块都有特定的功能，模块与模块之间通过相互配合来完成软件的开发。 软件框架是针对某一类软件设计问题而产生的。 2 MVC框架2.1 MVC简介MVC最初是由施乐公司旗下的帕罗奥多研究中心中的一位研究人员给 smalltalk语言发明的一中软件设计模式。 MVC的产生理念： 分工。让专门的人去做专门的事。 MVC的核心思想： 解耦。 MVC的思想被应用在的web开发的方面，产生了web MVC框架。 2.2 Web MVC框架模块功能通过浏览器注册用户信息。 M:Model,模型，和数据库进行交互。 V:View,视图， 产生html页面。 C:Controller,控制器, 接收请求，进行处理，与M和V进行交互，返回应答。 3 Django框架3.1 简介Django是劳伦斯出版集团的开发人员为开发新闻内容网站而设计出来的一个软件，它遵循MVC思想，但是有自己的一个名词，叫做MVT。 Django遵循快速开发和DRY原则。Do not repeat yourself.不要自己去重复一些工作。 3.2 MVT各部分功能 M:Model,模型， 和MVC中M功能相同，和数据库进行交互。 V:View,视图， 和MVC中C功能相同，接收请求，进行处理，与M和T进行交互，返回应答。 T:Template,模板， 和MVC中V功能相同，产生html页面。 4 项目创建4.1 创建Django项目命令：django-admin startproject 项目名 注意：创建应用必须先进入虚拟环境。 项目目录如下： init.py: 说明test1是一个python包。 settings.py: 项目的配置文件。 urls.py: 进行url路由的配置。 wsgi.py: web服务器和Django交互的入口。 manage.py: 项目的管理文件。 4.2 创建Django应用 一个项目由很多个应用组成的，每一个应用完成一个功能模块。 创建应用的命令如下： python manage.py startapp 应用名 注意：创建应用时需要先进入项目目录。 应用目录如下： init.py: 说明目录是一个Python模块。 models.py: 写和数据库项目的内容, 设计模型类。 views.py: ，接收请求，进行处理，与M和T进行交互，返回应答。 定义处理函数，视图函数。 tests.py: 写测试代码的文件。 admin.py: 网站后台管理相关的文件。 4.3 应用注册建立应用和项目之间的联系，需要对应用进行注册。 修改settings.py中的INSTALLED_APPS配置项。 4.4 启动项目运行开发web服务器命令： python manage.py runserver 5.模型类5.1 ORM框架 django中内嵌了ORM框架，ORM框架可以将类和数据表进行对应起来，只需要通过类和对象就可以对数据表进行操作。 在Django中主要是设计类：模型类。 ORM另外一个作用：根据设计的类生成数据库中的表。 5.2 模型类设计在应用models.py中设计模型类。 必须继承与models.Model类。 1） 设计BookInfo类。 2） 设计HeroInfo类。 Models.ForeignKey可以建立两个模型类之间一对多的关系，django在生成表的时候，就会在多端的表中创建一列作为外键，建立两个表之间一对多的关系。 123456789101112131415161718192021222324# 一类# booktest2_bookinfoclass BookInfo(models.Model): &apos;&apos;&apos;图书模型类&apos;&apos;&apos; # 图书名称 btitle = models.CharField(max_length=20, db_column=&apos;title&apos;) # 图书名字唯一 # btitle = models.CharField(max_length=20, unique=True, db_index=True) # 出版日期 bpub_date = models.DateField() # bpub_date = models.DateField(auto_now_add=True) # 创建时间 # bpub_date = models.DateField(auto_now=True) # 更新时间# 多类class HeroInfo(models.Model): &apos;&apos;&apos;英雄人物模型类&apos;&apos;&apos; # 英雄名 hname = models.CharField(max_length=20) # 性别 hgender = models.BooleanField(default=False) # 备注 hcomment = models.CharField(max_length=200, null=True, blank=False) # 关系属性 hbook = models.ForeignKey(&apos;BookInfo&apos;) 5.3 模型类生成表1) 生成迁移文件 命令：python manage.py makemigrations 迁移文件是根据模型类生成的。 2) 执行迁移生成表 命令：python mange.py migrate 根据迁移文件生成表。 生成表名的默认格式： ​ 应用名_模型类名小写 5.4 通过模型类操作数据表进入项目shell的命令: 1python manage.py shell 以下为在相互shell终端中演示的例子： 首先导入模型类： 1from booktest.models import BookInfo,HeroInfo 1) 向booktest_bookinfo表中插入一条数据。 1234567b = BookInfo() #定义一个BookInfo类的对象b.btitle =&apos;天龙八部&apos; #定义b对象的属性并赋值b.bpub_date = date(1990,10,11) b.save() #才会将数据保存进数据库 2) 查询出booktest_bookinfo表中id为1的数据。 1b = BookInfo.objects.get(id=1) 3) 在上一步的基础上改变b对应图书的出版日期。 123b.bpub_date = date(1989,10,21)b.save() #才会更新表格中的数据 4) 紧接上一步，删除b对应的图书的数据。 1b.delete() #才会删除 5) 向booktest_heroInfo表中插入一条数据。 123456789101112h = HeroInfo()h.hname = &apos;郭靖&apos;h.hgender = Falseh.hcomment = ‘降龙十八掌’b2 = BookInfo.objects.get(id=2)h.hbook = b2 #给关系属性赋值，英雄对象所属的图书对象h.save() 6) 查询图书表里面的所有内容。 123BookInfo.objects.all()HeroInfo.objects.all() 5.5 关联操作 1) 查询出id为2的图书中所有英雄人物的信息。 123b = BookInfo.objects.get(id=2) b.heroinfo_set.all() #查询出b图书中所有英雄人物的信息 6. 后台管理1) 本地化 ​ 语言和时区的本地化。 ​ 修改settings.py文件。 123456# Internationalization# https://docs.djangoproject.com/en/1.8/topics/i18n/LANGUAGE_CODE = &apos;zh-hans&apos;TIME_ZONE = &apos;Asia/Shanghai&apos; 2) 创建管理员 命令： 1python manage.py createsuperuser 3) 注册模型类 在应用下的admin.py中注册模型类。 1234from django.contrib import adminfrom booktest.models import HeroInfoadmin.site.register(HeroInfo) 告诉djang框架根据注册的模型类来生成对应表管理页面。可以通过重写str()方法来改变显示的内容。 123b = BookInfo() # 相当于创建了BookInfo()对象，然后调用str()方法str(b) __str__ 4) 自定义管理页面 自定义模型管理类。模型管理类就是告诉django在生成的管理页面上显示哪些内容。]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python虚拟环境]]></title>
    <url>%2F2019%2F11%2F06%2Fpythonweb_01_virtualenv%2F</url>
    <content type="text"><![CDATA[虚拟环境1 概念 安装python包的命令： sudo pip3 install 包名 包的安装路径：/usr/local/lib/python3.5/dist-packages 在同一个python环境中安装同一个包的不同版本，后安装的包会把原来安装的包覆盖掉。这样，如果同一台机器上两个项目依赖于相同包的不同版本，则会导致一些项目运行失败。 解决的方案就是：虚拟环境。 虚拟环境是真实python环境的复制版本。 在虚拟环境中使用的python是复制的python,安装python包也是安装在复制的python中。 2 安装和配置安装虚拟环境的命令： 1）sudo pip install virtualenv #安装虚拟环境 2）sudo pip install virtualenvwrapper #安装虚拟环境扩展包 3）编辑家目录下面的.bashrc文件，添加下面两行。 123export WORKON_HOME=$HOME/.virtualenvssource /usr/local/bin/virtualenvwrapper.sh 4）使用source .bashrc使其生效一下。 3 使用3.1 创建虚拟环境命令： mkvirtualenv 虚拟环境名 3.2 创建python3虚拟环境：mkvirtualenv -p python3 bj11_py3 3.3 进入虚拟环境工作：workon 虚拟环境名 3.4 查看机器上有多少个虚拟环境： workon 空格 + 两个tab键 3.5 退出虚拟环境： deactivate 3.6 删除虚拟环境：rmvirtualenv 虚拟环境名 虚拟环境下安装包的命令： pip install 包名 注意：不能使用sudo pip install 包名，这个命令会把包安装到真实的主机环境上而不是安装到虚拟环境中。 3.7 查看虚拟环境中安装了哪些python包： pip list pip freeze 3.8 安装django环境： pip install django==1.8.2 3.8 拓展:apt-get install 软件名 pip install python包名]]></content>
      <categories>
        <category>virtualenv</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA工具常用命令]]></title>
    <url>%2F2019%2F11%2F05%2FJava_16_IDEA%2F</url>
    <content type="text"><![CDATA[集成开发工具IDEAIDEA是一个专门针对Java的集成开发工具(IDE)，由Java语言编写。所以，需要有JRE运行环境并配置好环境变量。它可以极大地提升我们的开发效率。可以自动编译，检查错误。 1.1 IDEA的项目目录我们创建的项目，有以下目录： idea 目录和demo.iml 和我们开发无关，是IDEA工具自己使用的 out 目录是存储编译后的.class文件 src 目录是存储我们编写的.java源文件 1.2 IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标位置下面 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Alt+Ins 自动生成代码，toString，get，set等方法 Alt+Shift+上下箭头 移动当前代码行 1.3 IDEA修改快捷键在IDEA工具中， Ctrl+空格的快捷键，可以帮助我们补全代码，但是这个快捷键和Windows中的输入法切换快捷键冲突，需要修改IDEA中的快捷键。 1File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic 双击Basic-&gt;remove-&gt;Ctrl+空格 再次双击Basic-&gt;Add Keyboard-&gt;键入 Alt+/-&gt;点击OK]]></content>
      <categories>
        <category>Java Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web Request对象]]></title>
    <url>%2F2019%2F10%2F22%2FJavaweb_03_request%2F</url>
    <content type="text"><![CDATA[Request对象1. request对象和response对象的原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构：ServletRequest – 接口 | 继承HttpServletRequest – 接口 | 实现org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能：获取请求消息数据 获取请求行数据 1GET /day14/demo1?name=zhangsan HTTP/1.1 方法： 获取请求方式 ：GET String getMethod() (*)获取虚拟目录：/day14 String getContextPath() 获取Servlet路径: /demo1 * String getServletPath() 获取get方式请求参数：name=zhangsan&amp;age=18 String getQueryString() 获取的请求参数之间用&amp;分割 (*)获取请求URI：/day14/demo1 String getRequestURI(): /day14/demo1 StringBuffer getRequestURL() :http://localhost/day14/demo1 URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 URI：统一资源标识符 : /day14/demo1 共和国 获取协议及版本：HTTP/1.1 String getProtocol() 不在HttpServletRequest中，在父类ServletRequest中 获取客户机的IP地址： String getRemoteAddr() 获取请求头数据 String getHeader(String name):通过请求头的名称获取请求头的值Enumeration getHeaderNames():获取所有的请求头名称 12345678910111213protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //演示获取请求头数据 //1.获取所有请求头名称 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); //2.遍历 while(headerNames.hasMoreElements())&#123; String name = headerNames.nextElement(); //根据名称获取请求头的值 String value = request.getHeader(name); System.out.println(name+&quot;---&quot;+value); &#125; &#125; 也可以直接获取指定的请求头。 12345678910111213protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //演示获取请求头数据:user-agent String agent = request.getHeader(&quot;user-agent&quot;); //判断agent的浏览器版本 if(agent.contains(&quot;Chrome&quot;))&#123; //谷歌 System.out.println(&quot;谷歌...&quot;); &#125;else if(agent.contains(&quot;Firefox&quot;))&#123; //火狐 System.out.println(&quot;火狐...&quot;); &#125; &#125; 使用referer请求头防盗链。 1234567891011121314151617181920protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //演示获取请求头数据:referer String referer = request.getHeader(&quot;referer&quot;); System.out.println(referer); //http://localhost/day14/login.html //防盗链 if(referer != null )&#123; if(referer.contains(&quot;/day14&quot;))&#123; //正常访问 response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;播放电影....&quot;); &#125;else&#123; //盗链 response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;想看电影吗？来优酷吧...&quot;); &#125; &#125; &#125; 获取请求体数据: 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象* BufferedReader getReader()：**获取字符输入流，只能操作字符数据**（BufferedReader 高效，带有缓冲区，有readline()） ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 再从流对象中拿数据 1234567891011protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取请求消息体--请求参数 //1.获取字符流 BufferedReader br = request.getReader(); //2.读取数据 String line = null; while((line = br.readLine()) != null)&#123; System.out.println(line); &#125; &#125; 4. request其他功能 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game Enumeration getParameterNames():获取所有请求的参数名 Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 123456789101112131415161718192021222324252627282930313233343536373839protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //post 获取请求参数 //根据参数名称获取参数值 System.out.println(&quot;-------------------&quot;+&quot;getParameter&quot;); String username = request.getParameter(&quot;username&quot;); System.out.println(username); //根据参数名称获取参数值的数组 System.out.println(&quot;-------------------&quot;+&quot;getParameterValues&quot;); String[] hobbies = request.getParameterValues(&quot;hobby&quot;); for (String hobby:hobbies)&#123; System.out.println(hobby); &#125; //获取所有请求的参数名称 System.out.println(&quot;-------------------&quot;+&quot;getParameterNames&quot;); Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); while(parameterNames.hasMoreElements())&#123; String name = parameterNames.nextElement(); String value = request.getParameter(name); System.out.println(name+&quot;:&quot;+value); &#125; // 获取所有参数的map集合 System.out.println(&quot;-------------------&quot;+&quot;getParameterMap&quot;); Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); //遍历 Set&lt;String&gt; keyset = parameterMap.keySet(); for (String name : keyset) &#123; //获取键获取值 String[] values = parameterMap.get(name); System.out.println(name); for (String value : values) &#123; System.out.println(value); &#125; System.out.println(&quot;-----------------&quot;); &#125; &#125; 5. 中文乱码问题： get方式：tomcat 8 已经将get方式乱码问题解决了 post方式：会乱码 * 解决：在获取参数前，设置request的编码 1request.setCharacterEncoding(&quot;utf-8&quot;); 请求转发：一种在服务器内部的资源跳转方式 步骤： 通过request对象获取请求转发器对象： 1RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发： 1forward(ServletRequest request, ServletResponse response) 3. 特点： 1request.getRequestDispatcher(&quot;/requestDemo9&quot;).forward(request,response); - **浏览器地址栏路径不发生变化** - 只能转发到当前服务器内部资源中，不能访问外部资源 - 转发是一次请求 共享数据： 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj):存储数据 Object getAttitude(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 获取ServletContext：* ServletContext getServletContext() 5. 用户登录案例5.1 用户登录案例需求：1234561.编写login.html登录页面 username &amp; password 两个输入框2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表3.使用JdbcTemplate技术封装JDBC4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 5.2 分析 5.3 开发步骤 创建项目，导入html页面，配置文件，jar包 druid数据库连接池druid.properties 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///day14username=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 配置jar包 创建数据库环境 12345678CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 创建包cn.app.domain,创建类User 1234567891011121314151617181920212223242526272829303132333435363738public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 创建包cn.app.dao,创建类UserDao，提供login方法 12345678910111213141516171819202122232425262728293031323334import cn.app.domain.User;import cn.app.util.JDBCUtils;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;/** * 操作数据库中User表的类 */public class UserDao &#123; //声明JDBCTemplate对象共用,用于其他对象连接数据库 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser)&#123; try &#123; //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; &#125; catch (DataAccessException e) &#123; e.printStackTrace();//记录日志 return null; // 没有查询到user对象，返回null &#125; &#125;&#125; 创建包cn.app.util,编写工具类JDBCUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import javax.xml.crypto.Data;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * JDBC工具类 使用Durid连接池 */public class JDBCUtils &#123; private static DataSource ds ; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接池对象 */ public static DataSource getDataSource()&#123; return ds; &#125; /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125;&#125; 创建包cn.app.test,创建类UserDaoTest,测试login方法是否正确 12345678910111213public class UserDaoTest &#123; @Test public void testLogin()&#123; User loginuser = new User(); loginuser.setUsername(&quot;super&quot;); loginuser.setPassword(&quot;123&quot;); UserDao dao = new UserDao(); User user = dao.login(loginuser); System.out.println(user); &#125;&#125; 编写cn.itcast.web.servlet.LoginServlet类，完成登录逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import cn.itcast.dao.UserDao;import cn.itcast.domain.User;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;/loginServlet&quot;)public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null)&#123; //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); &#125;else&#123; //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 编写FailServlet和SuccessServlet类 1234567891011121314151617181920212223import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/failServlet&quot;)public class FailServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; 1234567891011121314151617181920212223242526272829import cn.itcast.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/successServlet&quot;)public class SuccessServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null)&#123; //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; login.html中form表单的action路径的写法 虚拟目录+Servlet的资源路径 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/day14/loginServlet&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; BeanUtils工具类，简化数据封装 123456789101112//2.获取所有请求参数 Map&lt;String, String[]&gt; map = req.getParameterMap(); //3.创建User对象 User loginUser = new User(); //3.2使用BeanUtils封装 try &#123; BeanUtils.populate(loginUser,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; 6. BeanUtils工具类（用于封装JavaBean）6.1 JavaBeanJavaBean：标准的Java类 要求： 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据 6.2 成员变量和属性成员变量：private int name;属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username 6.3 方法 setProperty() // 操作的是属性 set和get方法 123456789101112131415161718192021public class BeanUtilsTest &#123; @Test public void test()&#123; User user = new User(); try &#123; BeanUtils.setProperty(user,&quot;haha&quot;,&quot;male&quot;); System.out.println(user); String gender = BeanUtils.getProperty(user, &quot;haha&quot;); System.out.println(gender); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125;&#125; getProperty() populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Http使用]]></title>
    <url>%2F2019%2F10%2F21%2FJavaweb_02_http%2F</url>
    <content type="text"><![CDATA[Http协议1. 概念Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 特点：1. 基于TCP/IP的高级协议（基于TCP，所以也是安全的） 2. 默认端口号:80（访问https://www.baidu.com:80） 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据（请求之间不能通信） 历史版本： 1.0：每一次请求响应都会建立新的连接，消耗资源 1.1：复用连接，对缓存支持较好 2. 请求消息数据格式 请求行 12请求方式 请求url 请求协议/版本GET /login.html HTTP/1.1 请求方式: HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求头 客户端浏览器告诉服务器一些信息请求头名称: 请求头值 常见的请求头： User-Agent：浏览器告诉服务器，访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/login.html 告诉服务器，我(当前请求)从哪里来？ 作用： 防盗链： 统计工作：统计流量来源 请求空行空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文)： 封装POST请求消息的请求参数的 字符串格式 1234567891011POST /login.html HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1 username=zhangsan]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Servlet使用]]></title>
    <url>%2F2019%2F10%2F20%2FJavaweb_01_servlet%2F</url>
    <content type="text"><![CDATA[Servlet使用 1. 概念:servlet: server applet 运行在服务器端的程序。 Servelet是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则。 我们自定义一个类，实现servelet接口，复写方法 2. 步骤 创建javaEE项目 定义一个类，实现servlet接口 实现接口中的抽象方法 配置servlet 3. 执行原理 4. 生命周期 修改servlet创建时机：** 5. Servlet3.0 注解配置 创建 Java EE 7以上项目，可以使用servlet 3.1以上版本。 查看WebServlet接口实现 使用注解配置访问路径映射的类。不需要再用web.xml配置 6. IDEA与tomcat配置 WEB-INF目录下的资源浏览器不能直接访问到。 Tomcat断点调试：使用“debug”启动 7. Servlet的体系结构 Servlet 接口 GenericServlet – 抽象类 （实现Servlet接口） HttpServlet – 抽象类（继承自GenericServlet ） HttpServlet封装了Post和Get方法判断。对http协议的一种封装，简化操作。 定义类继承HttpServlet 复写doGet/doPost方法 查看源码 通过浏览器直接访问是Get方式。 可以通过表单访问doPost方法。]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit测试框架使用]]></title>
    <url>%2F2019%2F10%2F20%2FJava_15_junit%2F</url>
    <content type="text"><![CDATA[Junit单元测试测试分类： 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 白盒测试：需要写代码的。关注程序具体的执行流程。 Junit白盒测试步骤 定义一个测试类(测试用例) 建议： 测试类名：被测试的类名Test CalculatorTest 包名：xxx.xxx.xx.test com.exercise.test 定义测试方法：可以独立运行 建议： 方法名：test测试的方法名 testAdd() 返回值：void 参数列表：空参 给方法加@Test 导入junit依赖环境 Junit白盒测试结果判定红色：失败 绿色：成功一般我们会使用断言操作来处理结果 Assert.assertEquals(期望的结果,运算的结果) Junit白盒测试常用注解 @Before: 修饰的方法会在测试方法之前被自动执行 @After: 修饰的方法会在测试方法执行之后自动被执行]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类初始化顺序]]></title>
    <url>%2F2019%2F06%2F14%2FJava_14_construction%2F</url>
    <content type="text"><![CDATA[Java类初始化顺序本文总结Java静态代码块、构造代码块、构造函数以及Java类初始化顺序。 1.构造方法123public Hello()&#123; //构造方法 &#125; 构造方法：1.对象一建立，就会调用与之相应的构造方法，也就是说，不建立对象，构造方法不会运行。2.构造方法的作用是给对象进行初始化。3.一个对象建立，构造方法只运行一次，而一般方法可以被该对象调用多次。 2.构造代码块123&#123; //构造代码块 &#125; 构造代码块： 构造代码块的作用是给对象进行初始化。 对象一建立就运行构造代码块了，而且优先于构造方法执行。注意，有对象建立，才会运行构造代码块，类不能调用构造代码块的，而且构造代码块先于构造方法执行。 构造代码块与构造方法的区别是：构造代码块是给所有对象进行统一初始化，而构造方法是给对应的对象初始化，因为构造方法可以有多个，运行哪个构造方法就会建立相应的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 3.静态代码块123static &#123; //静态代码块 &#125; 静态代码块： 它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。 静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。 静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。 一个类中可以有多个静态代码块 4.Java类初始化顺序 对于一个类的情况 123456789101112131415public class Hello &#123; public Hello()&#123;//构造方法 System.out.println(&quot;构造方法&quot;); &#125; &#123;//构造代码块 System.out.println(&quot;构造代码块&quot;); &#125; static &#123;//静态代码块 System.out.println(&quot;静态代码块&quot;); &#125; public static void main(String[] args) &#123; &#125;&#125;运行结果：静态代码块 创建对象 1234567891011121314151617181920212223public class Hello &#123; public Hello()&#123;//构造方法 System.out.println(&quot;构造方法&quot;); &#125; &#123;//构造代码块 System.out.println(&quot;构造代码块&quot;); &#125; static &#123;//静态代码块 System.out.println(&quot;静态代码块&quot;); &#125; public static void main(String[] args) &#123; Hello a=new Hello(); Hello b=new Hello(); &#125;&#125;运行结果：静态代码块构造代码块构造方法构造代码块构造方法 对于一个类而言，按照如下顺序执行： 执行静态代码块 执行构造代码块 执行构造函数 5.带变量的类初始化顺序1234567891011121314151617181920212223242526272829303132 public class InitialOrderTest &#123; public static String staticField = &quot;静态变量&quot;; public String field = &quot;变量&quot;; static &#123; System.out.println( staticField ); System.out.println( &quot;静态初始化块&quot; ); &#125; &#123; System.out.println( field ); System.out.println( &quot;初始化块&quot; ); &#125; public InitialOrderTest() &#123; System.out.println( &quot;构造方法&quot; ); &#125; public static void main( String[] args ) &#123; new InitialOrderTest(); &#125;&#125;运行结果：1. 静态变量2. 静态初始化块3. 变量4. 初始化块5. 构造方法 6.继承情况下类初始化顺序1234567891011121314151617181920212223242526272829303132public class HelloA &#123; public HelloA()&#123; System.out.println(&quot;A的构造函数&quot;); &#125; &#123; System.out.println(&quot;A的构造代码块&quot;); &#125; static &#123; System.out.println(&quot;A的静态代码块&quot;); &#125;&#125;public class HelloB extends HelloA&#123; public HelloB()&#123; System.out.println(&quot;B的构造函数&quot;); &#125; &#123; System.out.println(&quot;B的构造代码块&quot;); &#125; static &#123; System.out.println(&quot;B的静态代码块&quot;); &#125; public static void main(String[] args) &#123; HelloB b = new HelloB(); &#125;&#125;运行结果：A的静态代码块B的静态代码块A的构造代码块A的构造函数B的构造代码块B的构造函数 当涉及到继承时，按照如下顺序执行： 执行父类的静态代码块，并初始化父类静态成员变量 执行子类的静态代码块，并初始化子类静态成员变量 执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量 执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量 参考文献 https://www.cnblogs.com/Qian123/p/5713440.html http://how2j.cn/k/class-object/class-object-init/297.html#nowhere]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能深度学习推断框架—TensorRT]]></title>
    <url>%2F2019%2F05%2F27%2Ftensor_11_TensorRT%2F</url>
    <content type="text"><![CDATA[一.TensorRT介绍TensorRT项目立项的时候名字叫做GPU Inference Engine（简称GIE），Tensor表示数据流动以张量的形式，RT表示的是Runtime。下图是TensorRT的架构图。TensorRT是英伟达公司出品的高性能的推断C++库，专门应用于边缘设备的推断，TensorRT可以将我们训练好的模型分解再进行融合，融合后的模型具有高度的集合度。我们平时所见到了深度学习落地技术：模型量化、动态内存优化以及其他的一些优化技术TensorRT都已经有实现，更主要的，其推断代码是直接利用cuda语言在显卡上运行的，所有的代码库仅仅包括C++和cuda，当然也有python的包装，在利用这个优化库运行训练好的代码，运行速度和所占内存的大小都会大大缩减。 1.训练和推断深度学习分为训练和部署两部分。训练部分首先构建网络结构，准备数据集，使用各种模型进行训练，训练包含validation和test的过程。训练的操作一般在线下，实时数据在线训练的情况比较少，大多数情况下数据是离线的，数据更新不频繁。线下有大规模的集群对数据或模型进行更新，训练需要消耗大量的GPU，batch size较大，一般训练模型batch size是128，甚至极端的1024，大的batch可以充分的利用GPU设备，实时性要求相对较低。 推断（Inference）的时候只需前向计算，将输入通过神经网络得出预测的结果。而推断（Inference）的实际部署可能部署在云端数据中心，比如手机语音输入，声音是传到云端处理好之后把数据返回；还可能部署在嵌入式的摄像头、无人机、机器人或车载的自动驾驶主机上。推断的特点是对实时性要求很高。语音识别对latency非常敏感，要能非常快的给出推断结果。模型如果做得不好，没有优化，可能需要二三百毫秒才能做完一次推断，加上来回网络传输，用户可能一秒后才能得到结果，对于语音识别和自动驾驶影响是非常大的。 2.推断应用在部署阶段，latency是非常重要指标，TensorRT是专门针对部署进行优化的，目前TensorRT支持大部分主流的深度学习应用，除了CNN（卷积神经网络）领域，TensorRT 3.0支持RNN。 最典型的应用是图片分类，图片的语义分割、目标检测等都是以图片分类网络为基础进行改进的。目标检测训练是对已经打好框的图片进行前向计算，得出的框和实际的框（ground truth）进行对比，然后再做后向更新，更新模型。推断的时候，是一个摄像头实时拍摄图片并进行目标检测，摄像头每秒拍摄25-30帧图片，鉴于实际应用可能是二十路摄像头同时传输进来的数据，必须保证一块卡做到实时处理。 3.推断和训练区别 推断的网络权值已经固定，无后向传播过程，因此 模型固定，可以对计算图进行优化 输入输出大小固定，可以做memory优化 推断的batch size要小很多，因为如果batch size很大，吞吐可以很大，可以很好地利用GPU，但是推断latency会增加。 推断可以使用低精度技术，训练的时候因为要保证前后向传播，每次梯度的更新是很微小的，需要相对较高的精度，一般需要float型，如FP32位的浮点型来处理数据。但是推断对精度的要求没有那么高，研究表明可以用半长的float型，即FP16，也可以用8位的整型（INT8）来做推断。研究结果表明没有特别大的精度损失，尤其对CNN。对Binary（二进制）的使用也处在研究过程中，即权值只有0和1。低精度计算的好处是一方面可以减少计算量，原来计算32位的单元处理FP16的时候，理论上可以达到两倍的速度，处理INT8的时候理论上可以达到四倍的速度。另一方面是模型需要的空间减少，不管是权值的存储还是中间值的存储。 4.TensorRT的效果使用GPU卡V100，V100有专门针对深度学习优化的TensorCore，TensorCore可以完成4×4矩阵的半精度乘法，（一个4×4的FP16矩阵和另外一个4×4的FP16矩阵相乘，当然可以再加一个矩阵（FP16 或FP32），得到一个FP32或者FP16的矩阵），TensorCore在V100上理论峰值可以达到120 Tflops。 如图所示，如果只是用CPU来做推断，它的吞吐只能达到140，每秒只能处理140张图片，同时整个处理过程需要有14ms的延迟，也就是说用户提交请求后，推断阶段最快需要14ms才能返回结果；如果使用V100，在TensorFlow中去做推断，大概是6.67ms的延时，但是吞吐只能达到305；如果使用V100加TensorRT，在保证延迟不变的情况下，吞吐可以提高15倍，高达5700张图片每秒，这个差别是很大的。 NVIDIA TensorRT通过针对基于GPU的平台的优化和高性能运行时，加速所有框架（包括TensorFlow）的深度学习推理。ResNet-50模型在7毫秒延迟下的吞吐量提高了8倍。 二.TensorRT进行的优化TensorFlow在实现神经网络的过程中可以使用各种各样的高级库，如用nn来搭建，tf.nn中的convolution中可以加一个卷积，可以用slim来实现卷积，不同的卷积实现效果不同，但是对计算图和GPU都没有做优化，甚至在中间卷积算法的选择上也没有做优化，而TensorRT在这方面做了很多工作。 1.TensorRT流程TensorRT的流程， 首先输入是一个预先训练好的FP32的模型和网络，将模型通过parser等方式输入到TensorRT中，TensorRT可以生成一个Serialization，也就是说将输入串流到内存或文件中。模型解析后，engine会进行优化。得到优化好的engine可以序列化到内存（buffer）或文件（file），读的时候需要反序列化，将其变成engine以供使用。然后在执行的时候创建context，主要是分配预先的资源，engine加context就可以做推断。 如图所示，TensorRT整个过程可以分三个步骤，即模型的解析（Parser），Engine优化和执行（Execution）。 一个深度学习模型的前向过程，包括： 1) 首先实现神经网络的layer，如卷积，pooling的实现。 2) 管理memory，数据在各层之间如何流动。 3) 推断的engine来调用各层的实现。 以上三个步骤在TendorRT都已经实现好了，用户需要做的是如何将网络输入到TensorRT中。目前TensorRT支持两种输入方式： Parser的方式（即模型解析器），输入一个TF的模型，可以通过API解析出其中的网络层及网络层之间的连接关系，然后将其输入到TensorRT中。 API接口可以添加一个convolution或pooling操作。Parser解析模型文件，比如TensorFlow转换成的uff文件，再用API添加到TensorRT中，构建好网络并进行优化。 a) TensorRT只支持主流的操作，如果有一个网络层不支持，TensorRT是不知道是做什么的。可以构建用户自定义层需要告诉TensorRT该层的连接关系和实现方式。 b) 目前API支持C++和Python，Python接口实现比较方便。 c) Parser目前有三个，一个是caffe Parser，支持最完善；另一个是uff，这个是Nvidia定义的一种网络模型文件结构，现在TensorFlow可以直接转成uff；3.5或4.0版本支持的onnx，是Facebook主导的开源、可交换的网络模型文件结构，这个格式目前只在NGC (NVDIA GPU Cloud)上支持，但是下一个版本都会支持。 2.TensorRT所做优化 TensorRT把一些网络层进行了合并。在GPU上跑的函数叫Kernel，TensorRT可以对Kernel进行调用。在绝大部分框架中，比如convolution、bias和ReLU层，这三层需要调用三次cuDNN对应的API，但实际上这三层的实现完全是可以合并到一起，TensorRT会对一些可以合并网络进行合并。另外网络可能并行做若干个相同大小的卷积，这些卷积计算其实也是可以合并到一起，包括垂直层融合和水平层融合。 消除未使用的输出的层以避免不必要的计算：比如concat这一层，一边计算出来一个1×3×24×24，另一边计算出来1×5×24×24，concat到一起，变成一个1×8×24×24的矩阵。但concat这层这其实是完全没有必要的，因为TensorRT可以把矩阵直接接到需要的地方，不用专门做concat操作，所以这一层可以取消。 convolution, Bias和ReLU这三个操作可以合并成CBR，合并后的结果如图所示，其中包含四个1×1的CBR，一个3×3的CBR和一个5×5的CBR。接下来可以继续合并三个相连的1×1的CBR为一个大的1×1的CBR，这个合并就可以更好地利用GPU。接着concat层可以消除掉，直接连接到下一层的next input。另外还可以做并发（Concurrency），如图右半部分（max pool和1×1 CBR）与左半部分（大的1×1 CBR，3×3 CBR和5×5 CBR）是相互独立的两条路径，本质上是不相关的，可以在GPU上通过并发来达到的优化的目标。 如图所示，效果是很好的。 FP16和INT8降低精度，并进行校准：通过降低权重和激活精度，将模型量化为INT8来最大化吞吐量，同时保持准确性。 大多数深度学习框架以32位精度（FP32）训练神经网络。•一旦模型完全训练，推理计算可以使用半精度FP16甚至INT8张量操作，因为推理不需要梯度反向传播。•使用较低的精度可以缩小模型尺寸，降低内存利用率和延迟，并提高吞吐量。•TensorRT可以在FP32，FP16和INT8中部署模型 为了将全精度信息量化为INT8，同时最大限度地降低精度损失，TensorRT必须执行一个校准的过程，以确定如何最好地将权重和激活表示为8位整数。•校准步骤要求向TensorRT提供输入训练数据的代表性样本。•无需对模型进行额外的微调或重新训练，也无需访问整个训练数据集。•校准是一种完全自动化且无参数的方法，用于将FP32转换为INT8。 Kernel可以根据不同的batch size 大小和问题的复杂程度，以及所使用的GPU，去选择最合适的算法，TensorRT预先写了很多GPU Kernel实现，可以进行自动选择。 在优化阶段，TensorRT还从数百个专用内核中进行选择，其中许多内核针对一系列参数和目标平台进行了手动调整和优化。•例如，有几种不同的算法可以进行卷积。•TensorRT将从内核库中选择实现，这些内核库可为目标GPU提供最佳性能，输入数据大小，过滤器大小，张量布局，批量大小和其他参数。•这可确保部署的模型针对特定部署平台以及正在部署的特定神经网络进行性能调整。 动态内存优化：TensorRT通过仅在其使用期间为每个张量分配内存来减少内存占用并改善内存重用，从而避免内存分配开销以实现快速高效的执行。 多流执行：通过使用相同的模型和权重并行处理它们，可以扩展到多个输入流 参考文献 https://yq.aliyun.com/articles/580307 https://developer.nvidia.com/tensorrt https://m.oldpan.me/archives/use-tensorrt-speed-up-deep-learning-1 http://on-demand.gputechconf.com/gtcdc/2017/presentation/dc7172-shashank-prasanna-deep-learning-deployment-with-nvidia-tensorrt.pdf]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——抽象工厂模式]]></title>
    <url>%2F2019%2F05%2F26%2Fdesign_02_abstract%20factory%20%2F</url>
    <content type="text"><![CDATA[1.抽象工厂模式1.1 抽象工厂模式介绍抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 使用场景： 和工厂方法一样客户端不需要知道它所创建的对象的类。 需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品） 系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则） 1.2 抽象工厂模式的优点/缺点 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 1.4 抽象工厂模式实例创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 （1）创建形状接口 123public interface Shape &#123; void draw();&#125; （2）创建实现接口的实体类。 长方形 1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125; 正方形 1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125; 圆形 1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; （3）创建颜色接口 123public interface Color &#123; void fill();&#125; （4）创建实现接口的实体类 红色 1234567public class Red implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Red::fill() method.&quot;); &#125;&#125; 绿色 1234567public class Green implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Green::fill() method.&quot;); &#125;&#125; 蓝色 1234567public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Blue::fill() method.&quot;); &#125;&#125; （5）为 Color 和 Shape 对象创建抽象类来获取工厂。 1234public abstract class AbstractFactory &#123; public abstract Color getColor(String color); public abstract Shape getShape(String shape) ;&#125; （6）创建扩展了AbstractFactory 的工厂类，基于给定的信息生成实体类的对象 形状工厂 12345678910111213141516171819202122public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125; @Override public Color getColor(String color) &#123; return null; &#125;&#125; 颜色工厂 12345678910111213141516171819202122public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override public Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase(&quot;RED&quot;))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123; return new Blue(); &#125; return null; &#125;&#125; （7）创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂 12345678910public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; （8）创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(&quot;RED&quot;); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(&quot;Green&quot;); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(&quot;BLUE&quot;); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 2.参考资料 https://blog.csdn.net/qq_34337272/article/details/80472071 https://www.cnblogs.com/toutou/p/4899388.html https://www.runoob.com/design-pattern/abstract-factory-pattern.html]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2F2019%2F05%2F25%2Fdesign_07_%20strategy%2F</url>
    <content type="text"><![CDATA[1.策略模式1.1 策略模式介绍策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 其思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换。策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 1.2 策略模式的优点/缺点 优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。 1.4 策略模式实例创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。 StrategyPatternDemo，使用 Context 和策略对象来演示 Context 在它使用的策略改变时的行为变化。 （1）创建Strategy接口 123public interface Strategy &#123; public int doOperation(int num1, int num2);&#125; （2）创建实现接口的实体类。 加法 123456public class OperationAdd implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 + num2; &#125;&#125; 减法 123456public class OperationSubstract implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 - num2; &#125;&#125; 乘法 123456public class OperationMultiply implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 * num2; &#125;&#125; （3）创建Context 类 1234567891011public class Context &#123; private Strategy strategy; public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public int executeStrategy(int num1, int num2)&#123; return strategy.doOperation(num1, num2); &#125;&#125; （4）使用 Context 来查看当它改变策略 Strategy 时的行为变化 123456789101112public class StrategyPatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(new OperationAdd()); System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5)); &#125;&#125; 2.参考资料 https://www.runoob.com/design-pattern/strategy-pattern.html http://baijiahao.baidu.com/s?id=1601547440739500969&amp;wfr=spider&amp;for=pc https://www.jianshu.com/p/7b7de81cdfbe]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报错Cannot resolve symbol 'bouncycastle']]></title>
    <url>%2F2019%2F05%2F24%2FJava_13_boucycastle%2F</url>
    <content type="text"><![CDATA[Cannot resolve symbol ‘bouncycastle‘Bouncycastle是一个Java的密码库，因为加入了jdk的第三方安全库，在使用的时候需要进行配置。缺少相应的配置会报错java.lang.NoClassDefFoundError: org/bouncycastle/jce/provider/BouncyCastleProvider，或者在IDEA下Cannot resolve symbol ‘bouncycastle‘。 解决方法BouncyCastle可以从www.bouncycastle.org下载（对应JDK版本的BouncyCastle）。 使用的是JDK1.8，所以下载对应的bcprov-jdk15on-161.jar from https://www.bouncycastle.org/latest_releases.html 查看/etc/profile下JAVA_HOME配置路径 使用whereis java命令可以看到JAVA_HOME路径 1java: /usr/bin/java /etc/java /usr/lib/java /usr/share/java 安装 在Windows中，找到Java的安装目录。例如：C:\ProgramFiles\Java\jdk1.8.0_38\jre\lib\ext目录下，把bcprov-jdk15on-161.jar文件放于其中。 配置安全属性文件 安全属性文件java.security位于和/lib/ext平行的另一个目录/lib/security下，它定义了当前可以使用的加密提供者。 123security.provider.1=sun.security.provider.Sunsecurity.provider.2=sun.security.rsa.SunRsaSign 它表明加密提供者以及他们的优先级和访问时使用的名称。当需要用到一个加密算法时，虚拟机会依次访问这里列出的提供者，寻找想要的算法，并按这里的优先级顺序使用第一个找到的算法。在文件中插入新的提供者： 1security.provider.x=org.bouncycastle.jce.provider.BouncyCastleProvider 4.在项目中导入相应jar包 Eclipse中：Right click on Project–&gt;Properties–&gt;Java Build Path–&gt;Libraries tab–&gt; Click on Add External JARs.. Select the path where you have the dowlnloaded bcprov-jdk15on-152.jar. Then click OK. That&apos;s it. IDEA中：点击 File -&gt; Project Structure（快捷键 Ctrl + Alt + Shift + s），点击Project Structure界面左侧的“Modules”显示下图界面；在 “Dependencies” 标签界面下，点击右边绿色的 “+”号，选择第一个选项“JARs or directories…”，选择相应的jar包，点“OK”，jar包添加成功。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——工厂模式]]></title>
    <url>%2F2019%2F05%2F24%2Fdesign_01_%20factory%2F</url>
    <content type="text"><![CDATA[由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版的 Design Patterns - Elements of Reusable Object-Oriented Software（设计模式 - 可复用的面向对象软件元素），该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 GOF对工厂模式的定义：在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。 1.简单工厂模式1.1 开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。 1.2 简单工厂介绍简单工厂模式属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式在实际中的应用相对于其他2个工厂模式用的还是相对少得多，因为它只适应很多简单的情况，而且它违背了开放-封闭原则。 适用于： （1）需要创建的对象较少。 （2）客户端不关心对象的创建过程。 1.3 简单工厂的优点/缺点 优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。 缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则 1.4 简单工厂实例创建一个可以绘制圆形，正方形，三角形的绘图工具，每个图形都会有一个draw()方法用于绘图。 （1）创建Shape接口 123public interface Shape &#123; void draw();&#125; （2）创建实现该接口的具体图形类 圆形 123456789public class Circle implements Shape &#123; public Circle() &#123; System.out.println(&quot;Circle&quot;); &#125; @Override public void draw() &#123; System.out.println(&quot;Draw Circle&quot;); &#125;&#125; 长方形 123456789public class Rectangle implements Shape &#123; public Rectangle() &#123; System.out.println(&quot;Rectangle&quot;); &#125; @Override public void draw() &#123; System.out.println(&quot;Draw Rectangle&quot;); &#125;&#125; 正方形 12345678910public class Square implements Shape &#123; public Square() &#123; System.out.println(&quot;Square&quot;); &#125; @Override public void draw() &#123; System.out.println(&quot;Draw Square&quot;); &#125;&#125; （3）创建工厂类： 1234567891011121314151617public class ShapeFactory &#123; // 使用 getShape 方法获取形状类型的对象 public static Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)) &#123; return new Square(); &#125; return null; &#125;&#125; （4）测试： 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; // 获取 Circle 的对象，并调用它的 draw 方法 Shape circle = ShapeFactory.getShape(&quot;CIRCLE&quot;); circle.draw(); // 获取 Rectangle 的对象，并调用它的 draw 方法 Shape rectangle = ShapeFactory.getShape(&quot;RECTANGLE&quot;); rectangle.draw(); // 获取 Square 的对象，并调用它的 draw 方法 Shape square = ShapeFactory.getShape(&quot;SQUARE&quot;); square.draw(); &#125;&#125; 如果我们新增产品类的，就需要修改工厂类中的getShape（）方法，这很明显不符合 开放-封闭原则 。 2.工厂方法模式2.1 工厂方法介绍工厂方法模式在工厂模式家族中是用的最多的模式，工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 每个对象都有一个与之对应的工厂 。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 适用于： （1）一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。（2）一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏（3）将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 2.2 工厂方法优点/缺点优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 2.3 工厂方法实例之前例子中的图形接口以及相关图像实现类不变。我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。 (1)增加一个工厂接口： 123public interface Factory &#123; public Shape getShape();&#125; （2）增加相关工厂类: 圆形工厂类 123456789public class CircleFactory implements Factory &#123; @Override public Shape getShape() &#123; // TODO Auto-generated method stub return new Circle(); &#125;&#125; 长方形工厂类 public class RectangleFactory implements Factory{ @Override public Shape getShape() { // TODO Auto-generated method stub return new Rectangle(); } } 圆形工厂类 123456789public class SquareFactory implements Factory&#123; @Override public Shape getShape() &#123; // TODO Auto-generated method stub return new Square(); &#125;&#125; （3）测试： 123456789public class Test &#123; public static void main(String[] args) &#123; Factory circlefactory = new CircleFactory(); Shape circle = circlefactory.getShape(); circle.draw(); &#125;&#125; 3.参考资料 https://blog.csdn.net/qq_34337272/article/details/80472071 https://www.cnblogs.com/toutou/p/4899388.html https://www.runoob.com/design-pattern/factory-pattern.html]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA配置struts2时报错]]></title>
    <url>%2F2019%2F05%2F21%2FJava_12_%20struts2%2F</url>
    <content type="text"><![CDATA[IDEA配置struts2时报错Intellij IDEA 创建Struts2框架时，若新建项目时并未导入Struts2框架，而是在手动新建lib目录导入Struts2框架JAR包，可能出现配置struts.xml时extends=”struts-default”报错，如图： 显示的错误为Cannot resolve Struts Package ‘struts-default’. Validates struts.xml files for syntactic and reference errors，原因是引用struts-default错误。 解决的方法： 依次打开File &gt; Project Structure &gt; Facets &gt; Struts2，点击铅笔进行修改： 勾选上Struts2-core-xxxx.jar即可，struts-default.xml会被自动勾选上，保存设置即可： struts.xml中extends=”struts-default”的报错已经消失。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven笔记]]></title>
    <url>%2F2019%2F05%2F16%2FJava_11_%20maven%2F</url>
    <content type="text"><![CDATA[第1章 Maven介绍1.1 什么是Maven1.1 MavenMaven是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 1.2 Maven能解决什么项目开发不仅仅是写代码而已，期间会伴随着各种必不可少的事情要做，比如：1、我们需要引用各种jar包，尤其是比较大的工程，引用的jar包往往有几十个乃至上百个， 每用到一种jar包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的jar包冲突，版本冲突。2、写好了Java文件，电脑需要将它编译成二进制字节码。现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA等都可以将代码即时编译。3、为了减少bug，写完代码我们还要写一些单元测试，然后一个个的运行来检验代码质量。4、再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型打包，如果是web项目，还需要将之发布到服务器。如果现在有一种工具，可以把你从上面的繁琐工作中解放出来，能帮你构建工程，管理jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成Web站点，你会心动吗？Maven就可以解决上面所提到的这些问题。 1.3 Maven优点要将web项目运行起来，就必须将该项目所依赖的一些jar包添加到工程中，否则项目就不能运行。试想如果具有相同架构的项目有十个，那么我们就需要将这一份jar包复制到十个不同的工程中。使用传统Web项目构建的CRM项目如下： 因为上面的WEB程序要运行，我们必须将项目运行所需的Jar包复制到工程目录中，导致了工程很大。同样的项目，如果使用Maven工程来构建，会发现总体上工程的大小会少很多。如下图: 1.2 Maven的作用1.2.1 Maven的依赖管理Maven的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven展示出了它对处理这种情形的高度控制。传统的WEB项目中，我们必须将工程所依赖的jar包复制到工程中，导致了工程的变得很大。那么maven工程是如何使得工程变得很少呢？ 通过分析发现：maven工程中不直接将jar包导入到工程中，而是通过在pom.xml文件中添加所需jar包的坐标，这样就很好的避免了jar直接引入进来，在需要用到jar包的时候，只要查找pom.xml文件，再通过pom.xml文件中的坐标，到一个专门用于”存放jar包的仓库”(maven仓库)中根据坐标从而找到这些jar包，再把这些jar包拿去运行 通过读取pom.xml 文件中的坐标，再到仓库中找到jar包，会不会很慢？ 通过pom.xml文件配置要引入的jar包的坐标，再读取坐标并到仓库中加载jar包，这样我们就可以直接使用jar包了，为了解决这个过程中速度慢的问题，maven中也有索引的概念，通过建立索引，可以大大提高加载jar包的速度，使得我们认为jar包基本跟放在本地的工程文件中再读取出来的速度是一样的。这个过程就好比我们查阅字典时，为了能够加快查找到内容，书前面的目录就好比是索引，有了这个目录我们就可以方便找到内容了，一样的在maven仓库中有了索引我们就可以认为可以快速找到jar包。 1.2.2 项目的一键构建我们的项目，往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。 什么是构建？指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven进行管理，这个过程称为构建 一键构建指的是整个构建过程，使用maven一个命令可以轻松完成整个工作。Maven规范化构建流程如下： 通过tomcat:run的这个命令，我们发现现在的工程编译，测试，运行都变得非常简单。 第2章 Maven的使用2.1 Maven的安装Maven下载后，将Maven解压。解压后目录结构如下： bin:存放了maven的命令，比如我们前面用到的mvn tomcat:runboot:存放了一些maven本身的引导程序，如类加载器等conf:存放了maven的一些配置文件，如setting.xml文件lib:存放了maven本身运行所需的一些jar包 通过 mvn -v命令检查 maven是否安装成功，看到maven的版本为3.5.2及java版本为1.8即为安装成功。 2.2 Maven仓库maven的工作需要从仓库下载一些jar包，如下图所示，本地的项目A、项目B等都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。 下图描述了maven中仓库的类型： 本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示windows用户目录。 远程仓库：如果本地需要插件或者jar包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。 中央仓库 ：在maven软件中内置一个远程仓库地址http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。 2.2.2 Maven本地仓库的配置在MAVE_HOME/conf/settings.xml文件中配置本地仓库位置（maven的安装目录下）： 2.2.3 全局setting与用户settingmaven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。 在maven安装目录下的有 conf/setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。 如需要个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在：${user.dir} /.m2/settings.xml目录中,${user.dir} 指windows 中的用户目录。 maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。 2.3 Maven工程2.3.1 Maven工程的目录结构 作为一个maven工程，它的src目录和pom.xml是必备的。进入src目录后，里面的目录结构如下： src/main/java —— 存放项目的.java文件src/main/resources —— 存放项目资源文件，如spring, hibernate配置文件src/test/java —— 存放所有单元测试.java文件，如JUnit测试类src/test/resources —— 测试资源文件target —— 项目输出位置，编译后的class文件会输出到此目录pom.xml——maven项目核心配置文件 如果是普通的java项目，那么就没有webapp目录。 2.3.2 Maven工程的运行进入maven工程目录（当前目录有pom.xml文件），运行tomcat:run命令。 根据上边的提示信息，通过浏览器访问：http://localhost:8080/maven-helloworld/ 2.3.3 问题处理如果本地仓库配置错误会报下边的错误 maven工程运行先从本地仓库找jar包，本地仓库没有再从中央仓库找，上边提示downloading…表示 从中央仓库下载jar，由于本地没有联网，报错。解决：在maven安装目录的conf/setting.xml文件中配置本地仓库。 第3章 Maven常用命令可以在cmd中通过一系列的maven命令来对工程进行编译、测试、运行、打包、安装、部署。 3.1.1 compilecompile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。 进入命令状态，执行mvn compile，如下图提示成功： 查看 target目录，class文件已生成，编译完成。 3.1.2 testtest是maven工程的测试命令 mvn test，会执行src/test/java下的单元测试类。cmd执行mvn test执行src/test/java下单元测试类，下图为测试结果，运行1个测试用例，全部成功。 3.1.3 cleanclean是maven工程的清理命令，执行 clean会删除target目录及内容。 3.1.4 packagepackage是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。 3.1.5 installinstall是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。从运行结果中，可以看出：当后面的命令执行时，前面的操作过程也都会自动执行， 3.1.6 Maven指令的生命周期maven对项目构建过程分为三套相互独立的生命周期： Clean Lifecycle 在进行真正的构建之前进行一些清理工作。Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle 生成项目报告，站点，发布站点。 3.1.7 maven的概念模型Maven包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目对象模型 (Project Object Model)一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。 依赖管理系统(Dependency Management System)通过maven的依赖管理对项目所依赖的jar 包进行统一管理。比如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即使用junit4.9，如下所示是junit4.9的依赖定义： 12345678910111213&lt;!-- 依赖关系 --&gt;&lt;dependencies&gt;&lt;!-- 此项目运行使用junit，所以此项目依赖junit --&gt;&lt;dependency&gt;&lt;!-- junit的项目名称 --&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;!-- junit的模块名称 --&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;!-- junit版本 --&gt;&lt;version&gt;4.9&lt;/version&gt;&lt;!-- 依赖范围：单元测试时使用junit --&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 一个项目生命周期(Project Lifecycle)使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段： maven通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行mvn compile执行编译、执行mvn clean执行清理。 一组标准集合maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等 插件(plugin)目标(goal)maven 管理项目生命周期过程都是基于插件完成的。 3.2 idea开发maven项目3.2.1 idea的maven配置选择本地maven安装目录，指定maven安装目录下conf文件夹中settings配置文件。 3.2.2 创建maven的web工程打开idea，选择创建一个新工程 选择idea提供好的maven的web工程模板 点击Next填写项目信息 点击Next，此处不做改动。 点击Next选择项目所在目录 点击Finish后开始创建工程，耐心等待，直到出现如下界面。 第4章 总结4.1 坐标定义在pom.xml中定义坐标，内容包括：groupId、artifactId、version，详细内容如下： 12345678910&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt;&lt;!-- 模块名称 --&gt;&lt;artifactId&gt;maven-first&lt;/artifactId&gt;&lt;!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging &gt; ：打包类型jar：执行package会打成jar包war：执行package会打成war包pom ：用于maven工程的继承，通常父工程设置为pom 4.2 pom基本配置pom.xml是Maven项目的核心配置文件，位于每个工程的根目录，基本配置如下: 12345678910&lt;project &gt; ：文件的根节点 . &lt;modelversion &gt; ： pom.xml使用的对象模型版本 &lt;groupId &gt; ：项目名称，一般写项目的域名 &lt;artifactId &gt; ：模块名称，子项目名或模块名称 &lt;version &gt; ：产品的版本号 .&lt;packaging &gt; ：打包类型，一般有jar、war、pom 等 &lt;name &gt; ：项目的显示名，常用于 Maven 生成的文档。 &lt;description &gt; ：项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; ：项目构建配置，配置编译、运行插件等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA Visual Profiler总结]]></title>
    <url>%2F2019%2F05%2F11%2Ftensor_10_Nvidia%20visual%20profiler%2F</url>
    <content type="text"><![CDATA[NVIDIA Visual ProfilerNVIDIA Visual Profiler提供了丰富的图形用户环境，可以给出CUDA在后台工作的更多细节。除了提供每个CUDA函数调用的时间分析外，它还能给出如何调用内核函数以及存储器的使用情况等。它有助于定位瓶颈可能出现的位置，并详细解释如何调用内核。 1.使用NVIDIA Visual Profiler进行CUDA分析Visual Profiler是NVIDIA提供的图形化分析工具，其在成功安装CUDA toolkit后，就能够使用。通过Profiler能够对CUDA应用的CPU和GPU的时间节点进行分析，并能够调优CUDA应用的性能。Visual Profiler的简单使用方法如下所示： 启动：在控制终端输入命令：nvvp；如图 5所示的启动后界面。 新建session：其创建入口为：FileNew Session，如图所示是新建Session对话框，在该对话框中的File输入框中输入需被分析的可执行文件。 分析结果：在新建Session对话框中输入相应的可执行文件后，就能产生分析结果，如图所示。 2.nvprof Profiler：命令行通过nvprof可以以命令行的形式分析和调优CUDA应用程序。nvprof的使用形式是： nvprof [options] [CUDA-application] [application-arguments] summary模型 这是nvprof的默认模型，在这个模型中只简单输出核函数和CUDA内存复制性能。如对于需要被测试的可执行文件boxFilterNPP，可直接执行命令：nvprof boxFilterNPP。如图所示的结果。 GPU-Trace和API-Trace模型 这个模型能够以时间轴顺序提供所有在GPU发生的活动点，每个核函数的执行或是复制/赋值都能够详细的显示。如图所示。 Event/metric Summary模型 通过这个模型能够在指定的NVIDIA GPU上显示所有可用的Event/metric， Event/metric Trace Mode 通过这个模型能够显示每个核函数的event和metric值。如图所示。 使用Visual Profiler分析Python程序 命令行格式 1$ nvprof python train_mnist.py 输出如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546$ nvprof python examples/stream/cusolver.py [10/1910]==27986== NVPROF is profiling process 27986, command: python examples/stream/cusolver.py==27986== Profiling application: python examples/stream/cusolver.py==27986== Profiling result:Time(%) Time Calls Avg Min Max Name 41.70% 125.73us 4 31.431us 30.336us 33.312us void nrm2_kernel&lt;double, double, double, int=0, int=0, int=128, int=0&gt;(cublasNrm2Params&lt;double, double&gt;) 21.94% 66.144us 36 1.8370us 1.7600us 2.1760us [CUDA memcpy DtoH] 13.77% 41.536us 48 865ns 800ns 1.4400us [CUDA memcpy HtoD] 3.02% 9.1200us 2 4.5600us 3.8720us 5.2480us void syhemv_kernel&lt;double, int=64, int=128, int=4, int=5, bool=1, bool=0&gt;(cublasSyhemvParams&lt;double&gt;) 2.65% 8.0000us 2 4.0000us 3.8720us 4.1280us void gemv2T_kernel_val&lt;double, double, double, int=128, int=16, int=2, int=2, bool=0&gt;(int, int, double, double const *, int, double const *, int, double, double*, int) 2.63% 7.9360us 2 3.9680us 3.8720us 4.0640us cupy_copy 2.44% 7.3600us 2 3.6800us 3.1680us 4.1920us void syr2_kernel&lt;double, int=128, int=5, bool=1&gt;(cublasSyher2Params&lt;double&gt;, int, double const *, double) 2.23% 6.7200us 2 3.3600us 3.2960us 3.4240us void dot_kernel&lt;double, double, double, int=128, int=0, int=0&gt;(cublasDotParams&lt;double, double&gt;) 1.88% 5.6640us 2 2.8320us 2.7840us 2.8800us void reduce_1Block_kernel&lt;double, double, double, int=128, int=7&gt;(double*, int, double*) 1.74% 5.2480us 2 2.6240us 2.5600us 2.6880us void ger_kernel&lt;double, double, int=256, int=5, bool=0&gt;(cublasGerParams&lt;double, double&gt;) 1.57% 4.7360us 2 2.3680us 2.1760us 2.5600us void axpy_kernel_val&lt;double, double, int=0&gt;(cublasAxpyParamsVal&lt;double, double, double&gt;) 1.28% 3.8720us 2 1.9360us 1.7920us 2.0800us void lacpy_kernel&lt;double, int=5, int=3&gt;(int, int, double const *, int, double*, int, int, int) 1.19% 3.5840us 2 1.7920us 1.6960us 1.8880us void scal_kernel_val&lt;double, double, int=0&gt;(cublasScalParamsVal&lt;double, double&gt;) 0.98% 2.9440us 2 1.4720us 1.2160us 1.7280us void reset_diagonal_real&lt;double, int=8&gt;(int, double*, int) 0.98% 2.9440us 4 736ns 736ns 736ns [CUDA memset]==27986== API calls:Time(%) Time Calls Avg Min Max Name 60.34% 408.55ms 9 45.395ms 4.8480us 407.94ms cudaMalloc 37.60% 254.60ms 2 127.30ms 556ns 254.60ms cudaFree 0.94% 6.3542ms 712 8.9240us 119ns 428.32us cuDeviceGetAttribute 0.72% 4.8747ms 8 609.33us 320.37us 885.26us cuDeviceTotalMem 0.10% 693.60us 82 8.4580us 2.8370us 72.004us cudaMemcpyAsync 0.08% 511.79us 1 511.79us 511.79us 511.79us cudaHostAlloc 0.08% 511.75us 8 63.969us 41.317us 99.232us cuDeviceGetName 0.05% 310.04us 1 310.04us 310.04us 310.04us cuModuleLoadData 0.03% 234.87us 24 9.7860us 5.7190us 50.465us cudaLaunch 0.01% 50.874us 2 25.437us 16.898us 33.976us cuLaunchKernel 0.01% 49.923us 2 24.961us 15.602us 34.321us cudaMemcpy 0.01% 47.622us 4 11.905us 8.6190us 19.889us cudaMemsetAsync 0.01% 44.811us 2 22.405us 9.5590us 35.252us cudaStreamDestroy 0.01% 35.136us 27 1.3010us 289ns 5.8480us cudaGetDevice 0.00% 31.113us 24 1.2960us 972ns 3.2380us cudaStreamSynchronize 0.00% 30.736us 2 15.368us 4.4580us 26.278us cudaStreamCreate 0.00% 13.932us 17 819ns 414ns 3.7090us cudaEventCreateWithFlags 0.00% 13.678us 70 195ns 130ns 801ns cudaSetupArgument 0.00% 12.050us 4 3.0120us 2.1290us 4.5130us cudaFuncGetAttributes 0.00% 10.407us 22 473ns 268ns 1.9540us cudaDeviceGetAttribute 0.00% 10.370us 40 259ns 126ns 1.4100us cudaGetLastError 0.00% 9.9680us 16 623ns 185ns 2.9600us cuDeviceGet 可以增加额外参数，指定模式。 1$ nvprof --print-gpu-trace python train_mnist.py 输出如下 123456789101112131415161718192021222324252627282930313233343536$ nvprof --print-gpu-trace python examples/stream/cusolver.py==28079== NVPROF is profiling process 28079, command: python examples/stream/cusolver.py==28079== Profiling application: python examples/stream/cusolver.py==28079== Profiling result: Start Duration Grid Size Block Size Regs* SSMem* DSMem* Size Throughput Device Context Stream Name652.12ms 1.5360us - - - - - 72B 44.703MB/s GeForce GTX TIT 1 7 [CUDA memcpy HtoD]885.35ms 3.5520us (1 1 1) (9 1 1) 35 0B 0B - - GeForce GTX TIT 1 13 cupy_copy [412]1.17031s 1.2160us - - - - - 112B 87.838MB/s GeForce GTX TIT 1 7 [CUDA memcpy HtoD]1.17104s 1.2800us - - - - - 4B 2.9802MB/s GeForce GTX TIT 1 13 [CUDA memcpy HtoD]1.17117s 2.2400us - - - - - 72B 30.654MB/s GeForce GTX TIT 1 13 [CUDA memcpy DtoH]1.17119s 864ns - - - - - 4B 4.4152MB/s GeForce GTX TIT 1 13 [CUDA memcpy HtoD]1.17123s 1.3760us (1 1 1) (256 1 1) 8 0B 0B - - GeForce GTX TIT 1 13 void reset_diagonal_real&lt;double, int=8&gt;(int, double*, int) [840]1.17125s 768ns - - - - - 16B 19.868MB/s GeForce GTX TIT 1 13 [CUDA memset]1.17127s 32.928us (1 1 1) (128 1 1) 30 1.0000KB 0B - - GeForce GTX TIT 1 13 void nrm2_kernel&lt;double, double, double, int=0, int=0,int=128, int=0&gt;(cublasNrm2Params&lt;double, double&gt;) [848]1.17130s 30.016us (1 1 1) (128 1 1) 30 1.0000KB 0B - - GeForce GTX TIT 1 13 void nrm2_kernel&lt;double, double, double, int=0, int=0,int=128, int=0&gt;(cublasNrm2Params&lt;double, double&gt;) [853]1.17134s 2.0160us - - - - - 8B 3.7844MB/s GeForce GTX TIT 1 13 [CUDA memcpy DtoH]1.17135s 1.7920us - - - - - 8B 4.2575MB/s GeForce GTX TIT 1 13 [CUDA memcpy DtoH]1.17137s 1.8560us (1 1 1) (384 1 1) 10 0B 0B - - GeForce GTX TIT 1 13 void scal_kernel_val&lt;double, double, int=0&gt;(cublasScalParamsVal&lt;double, double&gt;) [863]1.17138s 832ns - - - - - 8B 9.1699MB/s GeForce GTX TIT 1 13 [CUDA memcpy HtoD]1.17138s 864ns - - - - - 8B 8.8303MB/s GeForce GTX TIT 1 13 [CUDA memcpy HtoD]1.17139s 1.8240us - - - - - 8B 4.1828MB/s GeForce GTX TIT 1 13 [CUDA memcpy DtoH]1.17140s 1.8880us - - - - - 8B 4.0410MB/s GeForce GTX TIT 1 13 [CUDA memcpy DtoH]1.17141s 864ns - - - - - 8B 8.8303MB/s GeForce GTX TIT 1 13 [CUDA memcpy HtoD]1.17142s 832ns - - - - - 8B 9.1699MB/s GeForce GTX TIT 1 13 [CUDA memcpy HtoD]1.17143s 5.6320us (64 1 1) (128 1 1) 48 5.5000KB 0B - - GeForce GTX TIT 1 13 void syhemv_kernel&lt;double, int=64, int=128, int=4, int=5, bool=1, bool=0&gt;(cublasSyhemvParams&lt;double&gt;) [875]1.17145s 3.9360us (1 1 1) (128 1 1) 14 1.0000KB 0B - - GeForce GTX TIT 1 13 void dot_kernel&lt;double, double, double, int=128, int=0, int=0&gt;(cublasDotParams&lt;double, double&gt;) [882]1.17146s 3.0400us (1 1 1) (128 1 1) 16 1.5000KB 0B - - GeForce GTX TIT 1 13 void reduce_1Block_kernel&lt;double, double, double, int=128, int=7&gt;(double*, int, double*) [888][omitted] 图形化界面 首先使用nvvp将记录文件输出 1$ nvprof -o prof.nvvp python train_mnist.py 然后把.nvvp文件拷贝到要分析的文件夹下，启动nvidia visual profiler 1$ nvvp prof.nvvp 输出如下 参考文献 CUDA_Profiler_Users_Guide.pdf]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动乱码问题]]></title>
    <url>%2F2019%2F04%2F15%2Ftomcat_01_%20encoding%2F</url>
    <content type="text"><![CDATA[Tomcat启动乱码使用的是tomcat8.5，环境变量配置没问题，可以正常使用start.bat启动，但是启动后的命令行日志显示乱码。将tomcat配置到idea中也有同样的问题。可以通过修改Tomcat配置文件解决。 12312鏈?17, 2018 9:09:22 涓嬪崍 org.apache.catalina.startup.Catalina start淇℃伅: Server startup in 2284 ms 找到tomcat/conf/目录下的logging.properties 找到 java.util.logging.ConsoleHandler.encoding = utf-8 更改为 java.util.logging.ConsoleHandler.encoding = GBK 保存，重启Tomcat即可]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NVIDIA MPS总结]]></title>
    <url>%2F2019%2F04%2F14%2Ftensor_09_MPS%2F</url>
    <content type="text"><![CDATA[1.NVIDIA MPS介绍MPS多进程服务（Multi-Process Scheduling）是CUDA应用程序编程接口（API）的替代二进制兼容实现。从Kepler的GP10架构开始，NVIDIA就引入了MPS（基于软件的多进程服务），这种技术在当时实际上是称为HyperQ ，允许多个 流（stream）或者CPU的进程同时向GPU发射Kernel函数，结合为一个单一应用程序的上下文在GPU上运行，从而实现更好的GPU利用率。在单个进程的任务处理，对GPU利用率不高的情况下是非常有用的。实际上，在Pascal架构出现之后的MPS可以认为是HyperQ的一种实现方式。 最近需要使用到MPS，但是发现网上资料不多，而且很杂乱，所以在此总结一下。官方文档链接 MPS作用：多容器共享GPU会引发资源竞争和浪费的问题，不仅GPU利用率不高，也无法保证QoS。当使用NVIDIA MPS时，MPS Sever会通过一个CUDA Context管理GPU硬件资源，多个MPS Clients会将它们的任务通过MPS Server传入GPU，从而越过了硬件时间分片调度的限制，使得它们的CUDA kernels实现真正意义上的并行。特别地，Volta MPS可以兼容docker容器，并且支持执行资源配置（即每个Client context只能获取一定比例的threads），提高了多容器共享GPU的QoS。 增加GPU的利用率； 减少多个CUDA进程在GPU上的上下文空间。该空间主要是用于存储和调度资源； 减少GPU的上下文的切换。 但MPS实际上也是有一些使用限制的，比方它现在仅支持Linux操作系统，还要求GPU的运算能力必须大于3.5。 MPS实例 假设在CPU端有A、B、C三个进程，每个进程都要发射CUDA Kernel的任务到GPU上去，并且假设它们每一个独立的任务对GPU利用率都不高。 在不使用MPS服务的情况下，A、B、C三个进程实际上也可以同时把CUDA任务发射到GPU上去，但是默认采用时间片轮转调度的方式。首先第一个时间片，A任务被执行，接着第二个时间片，执行B任务，第三个时间片， C任务将被执行。时间片是依次进行轮转调度的，分别执行A、B、C中的任务。 可以直观地看到， 在GPU中，每一个时刻只有一个任务在执行。这种情况下，CPU中的process（进程）发射的CUDA任务对GPU的利用率很低。 MPS与Hyper-Q区别MPS与Hyper-Q的区别是：来自单个进程的CUDA任务与来自多个进程的CUDA任务之间存在差异。 Hyper-Q消除了来自单个进程的请求并发性的一些人为障碍。但是由于与Hyper-Q无关的CUDA行为，来自多个进程的请求仍然序列化。 MPS作为一个“漏斗”，用于从多个进程/级别收集CUDA任务，并将它们发布到GPU，就好像它们来自单个进程一样，以便Hyper-Q可以生效。 2.Pascal架构和Volta架构我们常用的GTX 1080 ti和GP100是Pascal架构的，NVIDIA基于深度学习的任务特点推出了Volta架构的Tesla V100数据中心级显卡。我们简单低看一下两种架构的GPU区别。 上图是Pascal SM 架构图，可以看到一个 GP100 SM 分成两个处理块，每块有32768 个 32 位寄存器 + 32 个单精度 CUDA 核心 + 16 个双精度 CUDA 核心 + 8 个特殊功能单元（SFU） + 8 个存取单元 + 一个指令缓冲区 + 一个 warp 调度器 + 两个分发单元。LD/ST加载存储单元，SFU为特殊功能单元，用来执行超越函数指令，如正弦函数。 上图是Volta SM架构图，每个 SM 有 64 个 FP32 核、64 个 INT32 核、32 个 FP64 核与 8 个全新的 Tensor Core。新的 Tensor Core 是 Volta GV100 最重要的特征，有助于提高训练神经网络所需的性能。Tesla V100 的 Tensor Core 能够为训练、推理应用的提供 120 Tensor TFLOPS。相比于在 P100 FP 32 上，在 Tesla V100 上进行深度学习训练有 12 倍的峰值 TFLOPS 提升。而在深度学习推理能力上，相比于 P100 FP16 运算，有了 6 倍的提升。与前一代 Pascal GP100 GPU 类似，GV100 GPU 由多个图形处理集群（Graphics Processing Cluster，GPC）、纹理处理集群（Texture Processing Cluster，TPC）、流式多处理器（Streaming Multiprocessor，SM）以及内存控制器组成。一个完整的 GV100 GPU 由 6 个 GPC、84 个 Volta SM、42 个 TPC（每个 TPC 包含了 2 个 SM）和 8 个 512 位的内存控制器（共 4096 位）。 3.不同架构上的MPS实现 上图是基于Pascal架构的MPS服务对任务的处理情况。可以看到A、B、C三个进程分别提交各自的任务到MPS的服务端，并在服务端整合为一个统一的上下文，并将三个任务同时发射到GPU中执行，这就有效地提升了GPU的利用率。在Pascal架构下，MPS是最多可以支持16个进程或者说16个用户同时提交任务。 上图是Volta架构MPS的执行情况，Volta架构对MPS的实现做了改进，主要是基于硬件加速的方式来实现。此时不同的进程是可以直接穿过MPS服务器，提交任务到GPU的硬件，并且每个进程客户端有隔离的地址空间，这样可以进一步减少Launch（发射进程）时带来的延迟，也可以通过限制执行资源配置来提升服务质量。这里所说提升服务质量是指怎么样平衡多个process（进程）发射任务对计算和存储资源的占用情况。比如我们现在可以去设定每一个process上下文，最多可以使用多少个资源。Volta下的MPS服务最多可以允许同时48个Client（客户端）。 4.MPS基准测试 官方给出的一个benchmark（基准）测试。我们知道，对于单个任务占用GPU资源比较少的情形，MPS服务是非常有用的，比如在深度学习中做Inference（推理）应用。相比Training（训练），Inference对于计算和存储资源的要求比较小，这个时候会出现我们之前看到的情况，单一的Kernel任务是没法有效利用GPU的。从上面的benchmark可以看到图中最左侧灰色的柱状图，在不使用MPS的情况下，Inference的吞吐性能很小；而中间绿色的柱状图，使用MPS允许多个Client同时发射计算任务到GPU，此时GPU吞吐性能直接提升了七倍；最后一个柱状图表示，如果我们使用MPS，并结合Batching操作，吞吐性能还能继续再提升60%左右。由此可见，对于像Deep Learning的Inference这样的应用，MPS技术是可以有效地帮助我们优化GPU利用率以及程序的吞吐性能。 5.MPS的使用MPS组成MPS主要包括控制守护进程（MPS Control Daemo）、客户端运行时（Client Runtime）和服务进程（Server Process）。CUDA contexts可以通过MPS Server提交作业，这样就越过了硬件的时间切片调度的限制，实现多个进程在同一个GPU上并行执行。如果没有MPS，多个进程只是在同一个GPU上并发执行，即每个进程在一个时间分片里独享GPU。 默认情况下，GPU是没有开启MPS的，每个CUDA程序会创建自己的CUDA Context来管理GPU资源，并以时间分片的方式共享GPU。开启MPS后，在需要的时候，MPS control daemon会启动一个MPS Server，监听任务请求。 MPS执行过程当CUDA首次在程序中初始化时，CUDA驱动程序将尝试连接到MPS控制守护进程。 如果连接尝试失败，程序继续运行，正常情况下没有MPS。 但是，如果连接尝试成功，则MPS控制守护程序将继续执行，以确保在与客户端连接之前启动的MPS服务器与连接客户端的用户标识相同。 MPS客户端然后继续连接到服务器。 MPS客户端，MPS控制守护程序和MPS服务器之间的所有通信都使用命名pipe道完成。默认情况下，命名pipe道被放置在/tmp/nvidia-mps/下 开启与关闭MPS启动 mps-control 1234567export CUDA_VISIBLE_DEVICES=0export CUDA_MPS_PIPE_DIRECTORY=/tmp/nvidia-mpsexport CUDA_MPS_LOG_DIRECTORY=/tmp/nvidia-log nvidia-cuda-mps-control -d 关闭mps-control 1echo quit | nvidia-cuda-mps-control 注意以上两个命令需要管理员权限。 Volta MPS资源配置执行资源配置的方法如下： 123nvidia-cuda-mps-controlset_default_active_thread_percentage 10 命令为每个MPS Client限制10%的threads。不是为每个Client预留专用资源，而是限制它们可以最多使用多少threads。默认情况下，每个Client可以获取所有threads（即100%）。 公平性关闭MPS，多任务通过时间分片的调度方式共享GPU；开启MPS，多任务共享Server的CUDA Context。无论哪种情况，在所有任务所占显存总容量不超出GPU容量时，每个任务都能公平地获得GPU的threads。 6.MPS程序示例示例来自stackoverflow 编写主程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$ cat t1034.cu#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_DELAY 30#define cudaCheckErrors(msg) \ do &#123; \ cudaError_t __err = cudaGetLastError(); \ if (__err != cudaSuccess) &#123; \ fprintf(stderr, &quot;Fatal error: %s (%s at %s:%d)\n&quot;, \ msg, cudaGetErrorString(__err), \ __FILE__, __LINE__); \ fprintf(stderr, &quot;*** FAILED - ABORTING\n&quot;); \ exit(1); \ &#125; \ &#125; while (0)#include &lt;time.h&gt;#include &lt;sys/time.h&gt;#define USECPSEC 1000000ULLunsigned long long dtime_usec(unsigned long long start)&#123; timeval tv; gettimeofday(&amp;tv, 0); return ((tv.tv_sec*USECPSEC)+tv.tv_usec)-start;&#125;#define APPRX_CLKS_PER_SEC 1000000000ULL__global__ void delay_kernel(unsigned seconds)&#123; unsigned long long dt = clock64(); while (clock64() &lt; (dt + (seconds*APPRX_CLKS_PER_SEC)));&#125;int main(int argc, char *argv[])&#123; unsigned delay_t = 5; // seconds, approximately unsigned delay_t_r; if (argc &gt; 1) delay_t_r = atoi(argv[1]); if ((delay_t_r &gt; 0) &amp;&amp; (delay_t_r &lt; MAX_DELAY)) delay_t = delay_t_r; unsigned long long difft = dtime_usec(0); delay_kernel&lt;&lt;&lt;1,1&gt;&gt;&gt;(delay_t); cudaDeviceSynchronize(); cudaCheckErrors(&quot;kernel fail&quot;); difft = dtime_usec(difft); printf(&quot;kernel duration: %fs\n&quot;, difft/(float)USECPSEC); return 0;&#125;$ nvcc -arch=sm_35 -o t1034 t1034.cu$ ./t1034kernel duration: 6.528574s$ 编写开启MPS脚本 123456$ cat start_as_root.bash#!/bin/bash# the following must be performed with root privilegeexport CUDA_VISIBLE_DEVICES=&quot;0&quot;nvidia-smi -i 0 -c EXCLUSIVE_PROCESSnvidia-cuda-mps-control -d 编写执行程序 12345$ cat mps_run#!/bin/bash./t1034 &amp;./t1034$ 编写关闭MPS脚本 12345$ cat stop_as_root.bash#!/bin/bashecho quit | nvidia-cuda-mps-controlnvidia-smi -i 2 -c DEFAULT$ 运行MPS脚本 1234$ ./mps_runkernel duration: 6.409399skernel duration: 12.078304s$ 运行主程序 1234$ ./start_as_root.bash$ ./mps_runkernel duration: 6.167079skernel duration: 6.263062s 参考资料 https://cloud.tencent.com/developer/article/1081424 https://cloud.tencent.com/developer/article/1117712 https://blog.csdn.net/kkk584520/article/details/53814067 https://www.cnblogs.com/xingzifei/p/6136095.html https://blog.csdn.net/beckham999221/article/details/86644970 https://blog.csdn.net/beckham999221/article/details/85257137]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boostrap笔记]]></title>
    <url>%2F2019%2F04%2F09%2Ffront_04_BootStrap%2F</url>
    <content type="text"><![CDATA[Bootstrap：1. 概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 * 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 * 好处： 1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 2. 响应式布局。 * 同一套页面可以兼容不同分辨率的设备。 2. 快速入门 1. 下载Bootstrap 2. 在项目中将这三个文件夹复制 3. 创建html页面，引入必要的资源文件 1234567891011121314151617181920&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 响应式布局* 同一套页面可以兼容不同分辨率的设备。 * 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子 * 步骤： 1. 定义容器。相当于之前的table、 * 容器分类： 1. container：两边留白 2. container-fluid：每一种设备都是100%宽度 2. 定义行。相当于之前的tr 样式：row 3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目 * 设备代号： 1. xs：超小屏幕 手机 (&lt;768px)：col-xs-12 2. sm：小屏幕 平板 (≥768px) 3. md：中等屏幕 桌面显示器 (≥992px) 4. lg：大屏幕 大桌面显示器 (≥1200px) * 注意： 1. 一行中如果格子数目超过12，则超出部分自动换行。 2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 CSS样式和JS插件1. 全局CSS样式： * 按钮：class=&quot;btn btn-default&quot; * 图片： * class=&quot;img-responsive&quot;：图片在任意尺寸都占100% * 图片形状 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框 * 表格 * table * table-bordered * table-hover * 表单 * 给表单项添加：class=&quot;form-control&quot; 2. 组件： * 导航条 * 分页条 3. 插件： * 轮播图 案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!-- HTML头 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;​ &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;​ &lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;​ &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;​ &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;​ &lt;style&gt;​ .paddtop&#123;​ padding-top: 10px;​ &#125;​ .search-btn&#123;​ float: left;​ border:1px solid #ffc900;​ width: 90px;​ height: 35px;​ background-color:#ffc900 ;​ text-align: center;​ line-height: 35px;​ margin-top: 15px;​ &#125;​ .search-input&#123;​ float: left;​ border:2px solid #ffc900;​ width: 400px;​ height: 35px;​ padding-left: 5px;​ margin-top: 15px;​ &#125;​ .jx&#123;​ border-bottom: 2px solid #ffc900;​ padding: 5px;​ &#125;​ .company&#123;​ height: 40px;​ background-color: #ffc900;​ text-align: center;​ line-height:40px ;​ font-size: 8px;​ &#125;​ &lt;/style&gt;​ &lt;/head&gt;​ &lt;body&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 &lt;!-- 1.页眉部分--&gt; &lt;header class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;img src=&quot;img/top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;img src=&quot;img/logo.jpg&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-md-5&quot;&gt; &lt;input class=&quot;search-input&quot; placeholder=&quot;请输入线路名称&quot;&gt; &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;img src=&quot;img/hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--导航栏--&gt; &lt;div class=&quot;row&quot;&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;!-- 定义汉堡按钮 --&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;!--轮播图--&gt; &lt;div class=&quot;row&quot;&gt; &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;img/banner_1.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/banner_2.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/banner_3.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;​ &lt;/div&gt;​ &lt;/header&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111 &lt;!-- 2.主体部分--&gt;​ &lt;div class=&quot;container&quot;&gt;​ &lt;div class=&quot;row jx&quot;&gt;​ &lt;img src=&quot;img/icon_5.jpg&quot;&gt;​ &lt;span&gt;黑马精选&lt;/span&gt;​ &lt;/div&gt;​ ​ &lt;div class=&quot;row paddtop&quot;&gt;​ &lt;div class=&quot;col-md-3&quot;&gt;​ &lt;div class=&quot;thumbnail&quot;&gt;​ &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;​ &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;​ &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;​ &lt;/div&gt;​ &lt;/div&gt;​ &lt;div class=&quot;col-md-3&quot;&gt;​ &lt;div class=&quot;thumbnail&quot;&gt;​ &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;​ &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;​ &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;​ &lt;/div&gt;​ &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt;​ ​ &lt;/div&gt;​ &lt;div class=&quot;row jx&quot;&gt;​ &lt;img src=&quot;img/icon_6.jpg&quot;&gt;​ &lt;span&gt;国内游&lt;/span&gt;​ &lt;/div&gt;​ &lt;div class=&quot;row paddtop&quot;&gt;​ &lt;div class=&quot;col-md-4&quot;&gt;​ &lt;img src=&quot;img/guonei_1.jpg&quot;&gt;​ &lt;/div&gt;​ &lt;div class=&quot;col-md-8&quot;&gt;​ &lt;div class=&quot;row&quot;&gt;​ &lt;div class=&quot;col-md-4&quot;&gt;​ &lt;div class=&quot;thumbnail&quot;&gt;​ &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;​ &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;​ &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;​ &lt;/div&gt;​ &lt;/div&gt;​ &lt;div class=&quot;col-md-4&quot;&gt;​ &lt;div class=&quot;thumbnail&quot;&gt;​ &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;​ &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;​ &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;​ &lt;/div&gt;​ ​ &lt;/div&gt;​ &lt;div class=&quot;col-md-4&quot;&gt;​ ​ &lt;div class=&quot;thumbnail&quot;&gt;​ &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;​ &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;​ &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;​ &lt;/div&gt;​ &lt;/div&gt;​ &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt;​ ​ &lt;/div&gt;​ ​ &lt;/div&gt;​ ​ &lt;/div&gt;​ &lt;/div&gt; 123456789101112131415 &lt;!-- 3.页脚部分--&gt;​ &lt;footer class=&quot;container-fluid&quot;&gt;​ &lt;div class=&quot;row&quot;&gt;​ &lt;img src=&quot;img/footer_service.png&quot; class=&quot;img-responsive&quot;&gt;​ &lt;/div&gt;​ &lt;div class=&quot;row company&quot;&gt;​ 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882​ &lt;/div&gt;​ &lt;/footer&gt;​ ​ &lt;/body&gt;​ &lt;/html&gt;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Boostrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常总结]]></title>
    <url>%2F2019%2F04%2F08%2FJava_08_%20exception%2F</url>
    <content type="text"><![CDATA[知识点 能够辨别程序中异常和错误的区别 说出异常的分类 说出虚拟机处理异常的方式 列举出常见的三个运行期异常 能够使用try…catch关键字处理异常 能够使用throws关键字处理异常 能够自定义异常类 能够处理自定义异常类 说出进程的概念 说出线程的概念 能够理解并发与并行的区别 能够开启新线程 第一章 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println("num=" + num); System.out.println("over"); &#125;&#125; 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println("over"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException("哥们，角标越界了~~~"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 2.2 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read("a.txt"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read("a.txt"); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; if (!path.equals("b.txt")) &#123; throw new IOException(); &#125; &#125;&#125; 2.4 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read("b.txt"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println("over"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 2.4 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read("a.txt"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println("不管程序怎样，这里都将会被执行。"); &#125; System.out.println("over"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 第三章 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 12345678910111213141516// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;"bill","hill","jill"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername("nill"); System.out.println("注册成功");//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException("亲"+name+"已经被注册了！"); &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程总结]]></title>
    <url>%2F2019%2F04%2F07%2FJava_09_%20thread%2F</url>
    <content type="text"><![CDATA[多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 1.1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 1.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 1.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread("新的线程！"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println("main线程！"+i); &#125; &#125;&#125; 自定义线程类： 12345678910111213141516public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+"：正在执行！"+i); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程、同步]]></title>
    <url>%2F2019%2F04%2F06%2FJava_10_%20thread2%2F</url>
    <content type="text"><![CDATA[Java多线程、同步知识点 能够描述Java中多线程运行原理 能够使用继承类的方式创建多线程 能够使用实现接口的方式创建多线程 能够说出实现接口方式的好处 能够解释安全问题的出现的原因 能够使用同步代码块解决线程安全问题 能够使用同步方法解决线程安全问题 能够说出线程6个状态的名称 第一章 线程1.1 多线程原理先画个多线程执行时序图来体现一下多线程程序的执行流程。代码如下：自定义线程类： 12345678910111213141516171819public class MyThread extends Thread&#123;/** 利用继承中的特点* 将线程名称传递 进行设置*/public MyThread(String name)&#123; super(name);&#125;/** 重写run方法* 定义线程要执行的代码*/public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; //getName()方法 来自父亲 System.out.println(getName()+i); &#125; &#125;&#125; 测试类： 12345678910public class Demo &#123; public static void main(String[] args) &#123; System.out.println(&quot;这里是main线程&quot;); MyThread mt = new MyThread(&quot;小强&quot;); mt.start();//开启了一个新的线程 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;旺财:&quot;+i); &#125; &#125;&#125; 流程图： 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。 1.2 Thread类我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了java.lang.Thread 类，API中该类中定义了有关线程的一些方法，具体如下：构造方法： public Thread() :分配一个新的线程对象。 public Thread(String name) :分配一个指定名字的新的线程对象。 public Thread(Runnable target) :分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName() :获取当前线程名称。 public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run() :此线程要执行的任务在此处定义代码。 public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式。 1.3 创建线程方式二采用java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正 的线程对象。 调用线程对象的start()方法来启动线程。 代码如下： 12345678public class MyRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; &#125;&#125; 123456789101112public class Demo &#123; public static void main(String[] args) &#123; //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, &quot;小强&quot;); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;旺财 &quot; + i); &#125; &#125;&#125; 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 1.4 Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。总结：实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 1.5 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法： 12345678910111213141516171819202122public class NoNameInnerClassThread &#123; public static void main(String[] args) &#123; // new Runnable()&#123; // public void run()&#123; // for (int i = 0; i &lt; 20; i++) &#123; // System.out.println(&quot;张宇:&quot;+i); // &#125; // &#125; // &#125;; //‐‐‐这个整体 相当于new MyRunnable() Runnable r = new Runnable()&#123; public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;张宇:&quot;+i); &#125; &#125; &#125;; new Thread(r).start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;费玉清:&quot;+i); &#125; &#125; &#125; 第二章 线程安全2.1 线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。我们通过一个案例，演示线程的安全问题：电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个(本场电影只能卖100张票)。我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟模拟票： 1234567891011121314151617181920212223242526public class Ticket implements Runnable &#123; private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while (true) &#123; if (ticket &gt; 0) &#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto‐generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name + &quot;正在卖:&quot; + ticket‐‐); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrum团队角色]]></title>
    <url>%2F2019%2F04%2F04%2FProjectManagement_01_scrum%2F</url>
    <content type="text"><![CDATA[SCRUMScrum 是一个用于开发和维护复杂产品的框架 ，是一个增量的、迭代的开发过程。在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个Sprint，每个Sprint的建议长度是2到4周(互联网产品研发可以使用1周的Sprint)。在Scrum中，使用产品Backlog来管理产品的需求，产品backlog是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事。Scrum团队总是先开发对客户具有较高价值的需求。在Sprint中，Scrum团队从产品Backlog中挑选最高优先级的需求进行开发。挑选的需求在Sprint计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为Sprint backlog。在每个迭代结束时，Scrum团队将递交潜在可交付的产品增量。 Scrum起源于软件开发项目，但它适用于任何复杂的或是创新性的项目。 Scrum流程如下: SCRUM框架包括3个角色、3个工件、5个事件、5个价值 3个角色 产品负责人（Product Owner） Scrum Master 开发团队 3个工件 产品Backlog（Product Backlog） SprintBacklog 产品增量（Increment） 5个事件 Sprint（Sprint本身是一个事件，包括了如下4个事件） Sprint计划会议（Sprint Planning Meeting） 每日站会（Daily Scrum Meeting） Sprint评审会议（Sprint Review Meeting） Sprint回顾会议（Sprint Retrospective Meeting） 5个价值 承诺 – 愿意对目标做出承诺 专注– 把你的心思和能力都用到你承诺的工作上去 开放– Scrum 把项目中的一切开放给每个人看 尊重– 每个人都有他独特的背景和经验 勇气– 有勇气做出承诺，履行承诺，接受别人的尊重 Scrum角色Scrum团队中包括三个角色，他们分别是产品负责人、开发团队和 Scrum Master。 Scrum 团队是自组织、跨职能的完整团队。自组织团队决定如何最好地完成他们的工作,而不是由团队外的其他人来指挥他 们。 跨职能的团队拥有完成工作所需要的全部技能,不需要依赖团队外部的人。Scrum 团队模式的目的是最大限度地优化适应性、创造性和生产力。 Scrum 团队通过迭代和增量交付产品功能的方法最大化反馈的机会。增量交付潜在可交付的产品增量保证了 每个迭代都有潜在可发布的版本。 Scrum角色之：产品负责人产品负责人负责最大化产品以及开发团队工作的价值。实现这一点的方式会随着组 织、Scrum 团队以及单个团队成员的不同而不同。 产品负责人是管理产品待办事项列表的唯一责任人。产品待办事项列表的管理包括: 清晰地表达产品代办事项列表条目 对产品代办事项列表中的条目进行排序,最好地实现目标和使命 确保开发团队所执行工作的价值 确保产品代办事项列表对所有人可见、透明、清晰,并且显示 Scrum 团队的下一步工作 确保开发团队对产品代办事项列表中的条目达到一定程度的理解 产品负责人可以亲自完成上述工作,也可以让开发团队来完成。然而,产品负责人是 负责任者。 产品负责人是一个人,而不是一个委员会。产品负责人可能会在产品代办事项列表中 体现一个委员会的需求,但要想改变某条目的优先级必须先说服产品负责人。 为保证产品负责人的工作取得成功,组织中的所有人员都必须尊重他的决定。产品负 责人所作的决定在产品待办事项列表的内容和排序中要清晰可见。任何人都不得要求开发 团队按照另一套需求开展工作,开发团队也不允许听从任何其他人的指令。 Scrum角色之：开发团队开发团队包含了专业人员,负责在每个 Sprint 的结尾交付潜在可发布的“完成”产 品增量。只有开发团队的成员才能创造增量。 开发团队由组织构建并授权,来组织和管理他们的工作。所产生的协同工作能最大化 开发团队的整体效率和效力。开发团队有以下几个特点: 他们是自组织的,没有人(即使是 Scrum Master 都不可以)告诉开发团队如何把产品 代办事项列表变成潜在可发布的功能。 开发团队是跨职能的,团队作为一个整体拥有创造产品增量所需要的全部技能。 Scrum 不认可开发团队成员的头衔,无论承担哪种工作他们都是开发者。此规则无一例外。 开发团队中的每个成员可以有特长和专注领域,但是责任归属于整个开发团队 开发团队不包含如测试或业务分析等负责特定领域的子团队。 开发团队的规模开发团队最佳规模是小到足以保持敏捷性,大到足以完成重要工作。少于 3 人的开发 团队没有足够的交互,因而所获得的生产力增长也不会很大。小团队在 Sprint 中可能会 受到技能限制,从而导致无法交付可发布的产品增量。大于 9 人的团队需要过多的协调沟 通工作。大型团队会产生太多复杂性,不便于经验过程管理。产品负责人和 Scrum Master 的角色不包含在此数字中,除非他们也参与执行 Sprint 代表事项列表中的工作。 Scrum角色之：Scrum MasterScrum Master 负责确保 Scrum 被理解并实施。为了达到这个目的,Scrum Master要确保 Scrum 团队遵循 Scrum 的理论、实践和规则。Scrum Master是Scrum团队中的服务式领导。 Scrum Master 帮助 Scrum 团队外的人员了解他们如何与 Scrum 团队交互是有益的。 Scrum Master 通过改变这些交互来最大化 Scrum 团队所创造的价值。 Scrum Master 服务于产品负责人Scrum Master 以各种方式服务于产品负责人,包括: 找到有效管理产品代办事项列表的技巧 清晰地和开发团队沟通愿景、目标和产品代表事项列表条目 教导开发团队创建清晰简明的产品代表事项列表条目 在经验主义环境中理解长期的产品规划 理解并实践敏捷 按需推动Scrum活动 Scrum Master 服务于开发团队Scrum Master 以各种方式服务于开发团队,包括: 指导开发团队自组织和跨职能 教导并领导开发团队创造高价值的产品 移除开发团队进展过程中的障碍 按需推动Scrum活动 在 Scrum 还未完全被采纳和理解的组织环境下指导开发团队 Scrum Master 服务于组织Scrum Master 以各种方式服务于组织,包括: 领导并指导组织采用 Scrum 在组织范围内计划 Scrum 的实施 帮助员工及干系人理解并实施 Scrum 和经验性产品开发 发起能提升Scrum 团队生产力的变革 与其他 Scrum Master 一起工作,帮助组织更有效的应用Scrum]]></content>
      <categories>
        <category>Project Management</category>
      </categories>
      <tags>
        <tag>Project Management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java位操作-移位总结]]></title>
    <url>%2F2019%2F04%2F03%2FJava_07_%20shift%2F</url>
    <content type="text"><![CDATA[1.除2倒取余法根据二进制的计算方法，输入一个十进制数n，每次用n除以2，把余数记下来，再用商去除以2…依次循环，直到商为0结束。把余数倒着输出，就得到了转换后的二进制数。 可以用int来存储最后的二进制数，每次求余后把余数存储在int型数的低位，依次递增。 123456789101112 1 public void Decimal2binary(int n)&#123; 2 int t = 0; //用来记录位数 3 int bin = 0; //用来记录最后的二进制数 4 int r = 0; //用来存储余数 5 while(n != 0)&#123; 6 r = n % 2; 7 n = n / 2; 8 bin += r * Math().pow(10,t); 9 t++; 10 &#125;11 System.out.println(bin);12 &#125; 但是int只能表示2^31-1 的正数，存储的二进制数位数有限；所以可以使用字符串的拼接（+）来实现，代码如下: 123456781 public void Decimal2binary(int n)&#123;2 String str = &quot;&quot;;3 while(n!=0)&#123;4 str = n%2+str;5 n = n/2;6 &#125;7 System.out.println(str);8 &#125; 2. 移位实现利用移位操作对一个十进制数进行移位操作，将最高位的数移至最低位（移31位），使用按位 &amp; 操作，可以使用和1相与（&amp;），然后把这个数按十进制输出；再移次高位，做相同的操作，直到最后一位 ，代码如下。 12341 public void Decimal2binary(int n)&#123;2 for(int i = 31;i &gt;= 0; i--)3 System.out.print(n &gt;&gt;&gt; i &amp; 1);4 &#125; 说明：由于计算机中存储的都是数的补码，正数的原码、反码、补码都是相同的；而负数的原码、反码、补码是不一样的，补码=原码取反+1（符号位不变）。所以，负数是按照它的补码输出的。 >&gt;&gt;为逻辑移位符，向右移n位，高位补0>&gt; 算数移位符，也是向右移n位，不同的是：正数高位补0，负数高位补1 3.调用API函数通过Integer.toBinaryString()方法实现。 123456public void function1(int n)&#123;2 String result = Integer.toBinaryString(n);3 //int r = Integer.parseInt(result);4 //System.out.println(r);5 System.out.println(result);6 &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习中训练和推断的区别]]></title>
    <url>%2F2019%2F03%2F31%2Ftensor_08_inference%2F</url>
    <content type="text"><![CDATA[深度学习中涉及到训练（Training）和推断（Inference），训练也就是搜索和求解模型最优参数的阶段。当模型参数已经求解出来，使用和部署模型，则称为推断阶段。二者的特点不同。 深度学习训练我们可以把深度学习的训练看成学习过程。人工神经网络是分层的、是在层与层之间互相连接的、网络中数据的传播是有向的。训练神经网络的时候，训练数据被输入到网络的第一层。然后所有的神经元，都会根据任务执行的情况，根据其正确或者错误的程度如何，分配一个权重参数（权值）。 如图是一个深层神经网络，信息从下到上流动。我们给这个网络大量的输入数据，网络的低层就会提取出不同类别数据的特征信息，通过激活函数、损失函数以后而到了最高层，网络提取到整个数据特征。所以，神经网络从低到高刚好能够提取图片数据中从低到高（从局部到整体）的多层次信息，最终的输出由网络中所有的权值共同决定。对多尺度层级结构的提取才使得深度学习神经网络可以得到很好的效果。 训练需要分batch多次迭代，inference只需要分batch执行一次计算流图。训练是计算密集型的，以GPU资源为主，CPU主要用于通信，参数更新等低消耗的任务。单次训练任务计算量大，需要用分布式系统才能较快得到结果。训练过程主要关心分布式集群的资源利用率。 深度学习推断推断过程关注的指标为： 访问延迟 吞吐量 模型版本管理 DevOps 推断过程常用的工具：TensorFlow Serving 是一个用于机器学习模型 serving 的高性能开源库。它可以将训练好的机器学习模型部署到线上，使用 gRPC和Restful 作为接口接受外部调用。它支持模型热更新与自动模型版本管理。这意味着一旦部署 TensorFlow Serving 后，你再也不需要为线上服务操心，只需要关心你的线下模型训练。 推断的网络权值已经固定下来，无后向传播过程，模型固定，可以对计算图进行优化。还可以输入输出大小固定，做memory优化（fine-tuning只是在已有的训练好的模型上做小的改动和调优，本质上仍然是训练过程，TensorRT没有fine-tuning） 推断的batch size要小很多，如果batch size很大，吞吐可以很大。比如每秒可以处理1024个batch，500毫秒处理完，吞吐可以达到2048，可以很好地利用GPU；但是推断关心延迟latency，不能有500毫秒处理延迟。所以batch可以是8或者16，吞吐降低，没有办法很好地利用GPU。 训练的时候因为要保证前后向传播，每次梯度的更新很微小，需要相对较高的精度，一般来说需要float型，如FP32，32位的浮点型来处理数据。但是推断对精度的要求没有那么高，可以使用低精度的技术，很多研究表明可以用如半长（16）的float型，即FP16，或者8位的整型（INT8）来做推断，研究结果表明没有特别大的精度损失，尤其对CNN。对Binary（二进制）的使用也处在研究中，即权值只有0和1。低精度计算的好处是一方面可以减少计算量，原来计算32位的单元处理FP16的时候，理论上可以达到两倍的速度，处理INT8的时候理论上可以达到四倍的速度。另一方面是模型需要的空间减少，不管是权值的存储还是中间值的存储，应用更低的精度，模型大小会相应减小。用于inference的模型要进行简化、压缩、针对运行性能优化：查找神经网络中经过训练后并没有用到、尚未激活的清洗掉。把神经网络中的多个层融合为一个单独的计算步骤。（通过神经网络剪枝、训练量化和Huffman编码等压缩模型），但仍能达到几乎一样的预测、识别准确率]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glances系统监控工具]]></title>
    <url>%2F2019%2F03%2F28%2Ftensor_07_glances%2F</url>
    <content type="text"><![CDATA[Glances 实时系统监控工具Glances 是一款用于 Linux、BSD 的跨平台的、基于命令行的系统监视工具，由 Python 语言编写，使用 Python 的 psutil 库来抓取系统数据。可以监控 CPU、负载均衡、内存、网络设备、磁盘 I/O、进程和文件系统使用等。本文介绍 glances 的使用方法和技巧，帮助 Linux 使用者了解掌握服务器性能。 一、输出信息概览glances 可以为 Unix 和 Linux 运维人员提供监视和分析性能数据的功能，其中包括： CPU 使用率 内存使用情况 内核统计信息和运行队列信息 磁盘 I/O 速度、传输和读/写比率 文件系统中的可用空间 磁盘适配器 网络 I/O 速度、传输和读/写比率 页面空间和页面速度 消耗资源最多的进程 计算机信息和系统资源 glances 工具可以实时显示重要的系统信息，并动态地更新。glances 在屏幕上对数据进行显示，并且每隔两秒钟对其进行更新。可以将这个时间间隔更改为更长或更短的数值。glances 工具还可以将相同的数据捕获到一个文件，便于以后对报告进行分析和绘制图形。输出文件可以是电子表格 (.csv) 或者 html 格式。 二、软件安装安装所需要的依赖 python 2.7,&gt;=3.4 psutil&gt;=5.3.0 (better with latest version) Glances 一般已集成到大多数 Linux 发行版的官方软件源中。可以直接使用系统的包管理器（如 apt-get、yum）安装： 1`sudo apt-get install glances `也可以使用 Python 的包管理器（pip 命令）进行安装： 12apt-get install -y python-pip`pip install glances` Glances 有 4 种颜色标记，分别表示不同的紧急程度： 绿色：OK 蓝色：CAREFUL 紫色：WARNING 红色：CRITICAL 默认为 careful = 50、warning = 70、critical = 90 。 三、命令选项（热键）glances 包括如下命令选项： 123456789101112131415-b：显示网络连接速度 Byte/ 秒-B @IP|host ：绑定服务器端 IP 地址或者主机名称-c @IP|host：连接 glances 服务器端-C file：设置配置文件默认是 /etc/glances/glances.conf -d：关闭磁盘 I/O 模块-e：显示传感器温度-f file：设置输出文件（格式是 HTML 或者 CSV）-m：关闭挂载的磁盘模块-n：关闭网络模块-p PORT：设置运行端口默认是 61209 -P password：设置客户端 / 服务器密码-s：设置 glances 运行模式为服务器-t sec：设置屏幕刷新的时间间隔，单位为秒，默认值为 2 秒，数值许可范围：1~32767 -h : 显示帮助信息-v : 显示版本信息 默认情况下，监控信息的刷新时间为 1 秒钟。可以使用 -t 选项自定义间隔时间： 1glances -t 2 glances 可以使用交互式的方式运行该工具，可以使用如下快捷键： 123456789101112h ： 显示帮助信息q ： 离开程序退出c ：按照 CPU 实时负载对系统进程进行排序m ：按照内存使用状况对系统进程排序i：按照 I/O 使用状况对系统进程排序p： 按照进程名称排序d ： 显示磁盘读写状况 w ： 删除日志文件l ：显示日志s： 显示传感器信息f ： 显示系统信息1 ：轮流显示每个 CPU 内核的使用情况（次选项仅仅使用在多核 CPU 系统） 四、显示界面 显示界面基本上可以分为3块在图的上部是 CPU 、Load（负载）、Mem（内存使用）、 Swap（交换分区）的使用情况。在图的左下部是磁盘 I/O 的使用情况。在图的右下部是网络接口、Processes（进程）的使用情况。通常包括如下字段： 1234567891011VIRT: 虚拟内存大小 RES: 进程占用的物理内存值 %CPU：该进程占用的 CPU 使用率 %MEM：该进程占用的物理内存和总内存的百分比 PID: 进程 ID 号 USER: 进程所有者的用户名 TIME+: 该进程启动后占用的总的 CPU 时间 IO_R 和 IO_W: 进程的读写 I/O 速率 NAME: 进程名称 NI: 进程优先级 S: 进程状态，其中 S 表示休眠，R 表示正在运行，Z 表示僵死状态。 五、输出到文件安装依赖库 1pip install Jinja2 文件采用逗号分隔值（CSV）的格式 1glances --export-csv ./glances.csv]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工程师BAT应聘要求]]></title>
    <url>%2F2019%2F03%2F28%2Fwork_01_prepare%2F</url>
    <content type="text"><![CDATA[阿里 扎实的计算机专业基础，包括算法和数据结构，操作系统，计算机网络，计算机体系结构，数据库等 具有扎实的Java编程基础，理解IO、多线程等基础框架 熟练使用Linux系统的常用命令及shell有一定了解 精通多线程编程，熟悉分布式,缓存,消息队列等机制；熟悉JVM，包括内存模型、类加载机制以及性能优化 精通spring mvc、orm框架（ibatis或hibernate）、模板引擎（velocity）、关系型数据库设计及SQL 具备良好的面向对象编程经验，深入理解OO、AOP思想，具有很强的分析设计能力，熟悉常用设计模式 有大型分布式、高并发、高负载、高可用性系统设计和稳定性经验 熟悉面向对象设计开发，熟悉各种常用设计模式，并有在具体的应用场景落地经验 熟悉Spring、iBatis，等开源框架及消息，存储等常用中间件。 有通读过开源框架源码 熟悉基于Oracle或者Mysql的设计和开发、Linux操作系统 熟悉SOA，有平台化实施经验者，有大数据量、高并发系统和大型网站构建经验 分布式系统应用架构设计与研发经验，精通Java EE、SOA、OSGI等相关技术 对各种开源的框架如Spring、Hibernate等有深入的了解，对框架本身有过开发或重构者可优先考虑 具有大型电子商务网站、O2O行业、C端产品系统架构设计经验 腾讯 精通Web后台开发语言至少一种（PHP、Java、.Net、C++）,有一定的架构能力和良好代码规范 熟悉linux/unix系统与开发环境 熟悉TCP/IP协议，socket编程 熟悉mysql以及SQL语言 有高性能大容量服务系统设计开发经验 精通面向对象设计，精通J2EE开发，java web开发 全面并且扎实的软件知识结构（操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全）； 具备良好的分析解决问题能力，能独立承担任务和有系统进度把控能力 精通MySQL或Mongo DB，熟悉缓存技术memcached、redis 有大型分布式、高并发、高负载、高可用系统设计、开发和调优经验 B/S结构系统分析及设计经验，有构建可伸缩、可扩展、高可用系统经验 有良好的开发习惯，熟悉Maven, Jenkins, JUnit等工具 精通MVC/REST架构、模板引擎、中间件的原理与应用 熟悉MySQL数据库，了解MySQL索引优化、查询优化和存储优化 头条 熟悉常见设计模式，掌握java流行的开源框架SpringMVC/Spring Boot/Spring Cloud，熟练使用至少一种 ORM 框架 熟练掌握基本的数据结构和算法，有系统分析和设计的实践经验 熟悉Rest，HTTP，Socket、webservice、HTTP协议，具备并发、多线程的编程经验 对Mysql、Redis、MongoDB 等数据库有研究或者项目经验 具有大型互联网服务设计及开发经验 熟悉JVM，对JVM有一定理解，并能借助相关工具进行JVM性能调优 熟悉常见的开源分布式中间件、缓存、消息队列等，熟悉nginx，MySQL，Redis，mongodb 等常用的开源软件 熟悉 MySQL 数据库设计和优化，有 NoSQL 数据库使用经验 具有大数据存储或者高性能计算平台架构、设计及开发等方面经历 具有大型互联网服务设计及开发经验]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>Work prepare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记1]]></title>
    <url>%2F2019%2F03%2F28%2Ffront_03_JavaScript01%2F</url>
    <content type="text"><![CDATA[JavaScript笔记1. JavaScript基础 JavaScript：* 概念： 一门客户端脚本语言 * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 * 脚本语言：不需要编译，直接就可以被浏览器解析执行了 * 功能： * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 * JavaScript发展史： 1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C-- ，后来更名为：ScriptEase 2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 3. 1996年，微软抄袭JavaScript开发出JScript语言 4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM) * ECMAScript：客户端脚本语言的标准 1. 基本语法： 1. 与html结合方式 1. 内部JS： * 定义&lt;script&gt;，标签体内容就是js代码 2. 外部JS： * 定义&lt;script&gt;，通过src属性引入外部的js文件 * 注意： 1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 2. &lt;script&gt;可以定义多个。 2. 注释 1. 单行注释：//注释内容 2. 多行注释：/*注释内容*/ 3. 数据类型： 1. 原始数据类型(基本数据类型)： 1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型) 2. string：字符串。 字符串 &quot;abc&quot; &quot;a&quot; &apos;abc&apos; 3. boolean: true和false 4. null：一个对象为空的占位符 5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 2. 引用数据类型：对象 4. 变量 * 变量：一小块存储数据的内存空间 * Java语言是强类型语言，而JavaScript是弱类型语言。 * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 * 语法： * var 变量名 = 初始化值; * typeof运算符：获取变量的类型。 * 注：null运算后得到的是object 5. 运算符 1. 一元运算符：只有一个运算数的运算符 ++，-- ， +(正号) * ++ --: 自增(自减) * ++(--) 在前，先自增(自减)，再运算 * ++(--) 在后，先运算，再自增(自减) * +(-)：正负号 * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 * 其他类型转number： * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） * boolean转number：true转为1，false转为0 2. 算数运算符 + - * / % ... 3. 赋值运算符 = += -+.... 4. 比较运算符 &gt; &lt; &gt;= &lt;= == ===(全等于) * 比较方式 1. 类型相同：直接比较 * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 2. 类型不同：先进行类型转换，再比较 * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false 5. 逻辑运算符 &amp;&amp; || ! * 其他类型转boolean： 1. number：0或NaN为假，其他为真 2. string：除了空字符串(&quot;&quot;)，其他都是true 3. null&amp;undefined:都是false 4. 对象：所有对象都为true 6. 三元运算符 ? : 表达式 var a = 3; var b = 4; var c = a &gt; b ? 1:0; * 语法： * 表达式? 值1:值2; * 判断表达式的值，如果是true则取值1，如果是false则取值2； 6. 流程控制语句： 1. if...else... 2. switch: * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) * switch(变量): case 值: * 在JS中,switch语句可以接受任意的原始数据类型 3. while 4. do...while 5. for 7. JS特殊语法： 1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 2. 变量的定义使用var关键字，也可以不使用 * 用： 定义的变量是局部变量 * 不用：定义的变量是全局变量(不建议) 8. 练习：99乘法表 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td{ border: 1px solid; } &lt;/style&gt; &lt;script&gt; document.write(&quot;&lt;table align=&apos;center&apos;&gt;&quot;); ​ //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) { document.write(““); for (var j = 1; j &lt;=i ; j++) { document.write(““); //输出 1 * 1 = 1 document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;); document.write(&quot;&lt;/td&gt;&quot;); } /*//输出换行 document.write(&quot;&lt;br&gt;&quot;);*/ document.write(&quot;&lt;/tr&gt;&quot;); } //2.完成表格嵌套 document.write(&quot;&lt;/table&gt;&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2. 基本对象： 1. Function：函数(方法)对象 1. 创建： 1. var fun = new Function(形式参数列表,方法体); //忘掉吧 2. function 方法名称(形式参数列表){ 方法体 } 3. var 方法名 = function(形式参数列表){ 方法体 } 2. 方法： 3. 属性： length:代表形参的个数 4. 特点： 1. 方法定义是，形参的类型不用写,返回值类型也不写。 2. 方法是一个对象，如果定义名称相同的方法，会覆盖 3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关 4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 5. 调用： 方法名称(实际参数列表); 2. Array:数组对象 1. 创建： 1. var arr = new Array(元素列表); 2. var arr = new Array(默认长度); 3. var arr = [元素列表]; 2. 方法 join(参数):将数组中的元素按照指定的分隔符拼接为字符串 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 3. 属性 length:数组的长度 4. 特点： 1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。 3. Boolean 4. Date：日期对象 1. 创建： var date = new Date(); 2. 方法： toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 5. Math：数学对象 1. 创建： * 特点：Math对象不用创建，直接使用。 Math.方法名(); 2. 方法： random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入。 floor(x)：对数进行下舍入。 round(x)：把数四舍五入为最接近的整数。 3. 属性： PI 6. Number 7. String 8. RegExp：正则表达式对象 1. 正则表达式：定义字符串的组成规则。 1. 单个字符:[] 如： [a] [ab] [a-zA-Z0-9_] * 特殊符号代表特殊含义的单个字符: \d:单个数字字符 [0-9] \w:单个单词字符[a-zA-Z0-9_] 2. 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n * m如果缺省： {,n}:最多n次 * n如果缺省：{m,} 最少m次 3. 开始结束符号 * ^:开始 * $:结束 2. 正则对象： 1. 创建 1. var reg = new RegExp(&quot;正则表达式&quot;); 2. var reg = /正则表达式/; 2. 方法 1. test(参数):验证指定的字符串是否符合正则定义的规范 9. Global 1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名(); 2. 方法： encodeURI():url编码 decodeURI():url解码 encodeURIComponent():url编码,编码的字符更多 decodeURIComponent():url解码 parseInt():将字符串转为数字 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN():判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。 3. URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2 * BOM * DOM ​]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记2]]></title>
    <url>%2F2019%2F03%2F28%2Ffront_03_JavaScript02%2F</url>
    <content type="text"><![CDATA[JavaScript笔记21. JavaScript： 1. ECMAScript： 2. BOM： 3. DOM： 1. 事件 DOM简单学习：为了满足案例要求* 功能：控制html文档的内容 * 获取页面标签(元素)对象：Element * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象 * 操作Element对象： 1. 修改属性值： 1. 明确获取的对象是哪一个？ 2. 查看API文档，找其中有哪些属性可以设置 2. 修改标签体内容： * 属性：innerHTML 1. 获取元素对象 2. 使用innerHTML属性修改标签体内容 事件简单学习* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。 * 造句： xxx被xxx,我就xxx * 我方水晶被摧毁后，我就责备对友。 * 敌方水晶被摧毁后，我就夸奖自己。 * 如何绑定事件 1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 1. 事件：onclick--- 单击事件 2. 通过js获取元素对象，指定事件属性，设置一个函数 * 代码： &lt;body&gt; &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot; onclick=&quot;fun();&quot;&gt; &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt; &lt;script&gt; function fun(){ alert(&apos;我被点了&apos;); alert(&apos;我又被点了&apos;); } function fun2(){ alert(&apos;咋老点我？&apos;); } //1.获取light2对象 var light2 = document.getElementById(&quot;light2&quot;); //2.绑定事件 light2.onclick = fun2; ​​ ​ ​ * 案例1：电灯开关 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(&quot;light&quot;); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function(){ if(flag){//判断如果灯是开的，则灭掉 light.src = &quot;img/off.gif&quot;; flag = false; }else{ //如果灯是灭的，则打开 light.src = &quot;img/on.gif&quot;; flag = true; } ​​ }​ BOM:1. 概念：Browser Object Model 浏览器对象模型 * 将浏览器的各个组成部分封装成对象。 2. 组成： * Window：窗口对象 * Navigator：浏览器对象 * Screen：显示器屏幕对象 * History：历史记录对象 * Location：地址栏对象 3. Window：窗口对象 1. 创建 2. 方法 1. 与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 * 如果用户点击确定按钮，则方法返回true * 如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。 * 返回值：获取用户输入的值 2. 与打开关闭有关的方法： close() 关闭浏览器窗口。 * 谁调用我 ，我关谁 open() 打开一个新的浏览器窗口 * 返回新的Window对象 3. 与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 * 参数： 1. js代码或者方法对象 2. 毫秒值 * 返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 3. 属性： 1. 获取其他BOM对象： history location Navigator Screen: 2. 获取DOM对象 document 4. 特点 * Window对象不需要创建可以直接使用 window使用。 window.方法名(); * window引用可以省略。 方法名(); 4. Location：地址栏对象 1. 创建(获取)： 1. window.location 2. location 2. 方法： * reload() 重新加载当前文档。刷新 3. 属性 * href 设置或返回完整的 URL。 5. History：历史记录对象 1. 创建(获取)： 1. window.history 2. history 2. 方法： * back() 加载 history 列表中的前一个 URL。 * forward() 加载 history 列表中的下一个 URL。 * go(参数) 加载 history 列表中的某个具体页面。 * 参数： * 正数：前进几个历史记录 * 负数：后退几个历史记录 3. 属性： * length 返回当前窗口历史列表中的 URL 数量。 DOM： * 概念： Document Object Model 文档对象模型 * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 * W3C DOM 标准被分为 3 个不同的部分： * 核心 DOM - 针对任何结构化文档的标准模型 * Document：文档对象 * Element：元素对象 * Attribute：属性对象 * Text：文本对象 * Comment:注释对象 * Node：节点对象，其他5个的父对象 * XML DOM - 针对 XML 文档的标准模型 * HTML DOM - 针对 HTML 文档的标准模型 * 核心DOM模型： * Document：文档对象 1. 创建(获取)：在html dom模型中可以使用window对象来获取 1. window.document 2. document 2. 方法： 1. 获取Element对象： 1. getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 2. 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 3. 属性 * Element：元素对象 1. 获取/创建：通过document来获取和创建 2. 方法： 1. removeAttribute()：删除属性 2. setAttribute()：设置属性 * Node：节点对象，其他5个的父对象 * 特点：所有dom对象都可以被认为是一个节点 * 方法： * CRUD dom树： * appendChild()：向节点的子节点列表的结尾添加新的子节点。 * removeChild() ：删除（并返回）当前节点的指定子节点。 * replaceChild()：用新节点替换一个子节点。 * 属性： * parentNode 返回节点的父节点。 * HTML DOM 1. 标签体的设置和获取：innerHTML 2. 使用html元素对象的属性 3. 控制元素样式 1. 使用元素的style属性来设置 如： //修改样式方式1 div1.style.border = &quot;1px solid red&quot;; div1.style.width = &quot;200px&quot;; //font-size--&gt; fontSize div1.style.fontSize = &quot;20px&quot;; 2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。 事件监听机制：* 概念：某些组件被执行了某些操作后，触发某些代码的执行。 * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 * 事件源：组件。如： 按钮 文本输入框... * 监听器：代码。 * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 * 常见的事件： 1. 点击事件： 1. onclick：单击事件 2. ondblclick：双击事件 2. 焦点事件 1. onblur：失去焦点 2. onfocus:元素获得焦点。 3. 加载事件： 1. onload：一张页面或一幅图像完成加载。 4. 鼠标事件： 1. onmousedown 鼠标按钮被按下。 2. onmouseup 鼠标按键被松开。 3. onmousemove 鼠标被移动。 4. onmouseover 鼠标移到某元素之上。 5. onmouseout 鼠标从某元素移开。 ​​ 5. 键盘事件：​ 1. onkeydown 某个键盘按键被按下。​ 2. onkeyup 某个键盘按键被松开。​ 3. onkeypress 某个键盘按键被按下并松开。​ 6. 选择和改变 1. onchange 域的内容被改变。 2. onselect 文本被选中。 7. 表单事件： 1. onsubmit 确认按钮被点击。 2. onreset 重置按钮被点击。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow Profile分析神经网络性能]]></title>
    <url>%2F2019%2F03%2F26%2Ftensor_06_profile%2F</url>
    <content type="text"><![CDATA[profiler分析TensorFlow程序性能1.TensorFlow profiler 功能从r1.3版本开始， tensorflow 提供profiler模块，参见github上的官网文档 profiler打开tf执行的黑盒，以graph node（神经网络模型简称为graph，其中的节点称为node.）为细粒度，从多个维度、多个层面去统计神经网络运行的时间和内存消耗，为进一步优化神经网络模型的运行效率提供最直接的数据依据。功能如下： 分析 TensorFlow 模型架构。 参数量、tensor的shape、浮点运算数、运算设备等。 分析 multiple-steps 模型性能。 执行时间，内存消耗。 自动 分析及建议。 训练加速设备使用情况的检查 较耗时op的检查 op配置的检查 分布式runtime检查（非OSS） 2.profiler 主要步骤profiler分为数据搜集和数据显示两个主要步骤。 数据收集 graph node的每一次执行，记录单步统计数据，主要是执行时间和占用内存，格式参见step_stats.proto，作为原始的最小粒度统计数据源； 每一次session.Run()，所有执行到的graph node的统计数据，都集中汇总保存到 RunMetadata 数据结构中; 用户程序把每一次搜集到的 RunMetadata 添加到profiler实例，做数据累计和加工处理。 数据显示： 数据的过滤、视图组织和显示输出部分规则需要用户自己指定：- 数据的过滤： 比如graph node过滤条件、 显示的字段、排序方式等。 四种视图： 对应显示节点之前的不同组织方式。 scope：应该是 python 层代码中用 tf.name_scope() 包起来的视图 graph：TensorFlow 计算图的视图 op：把 TensorFlow 计算图再细化一层 code：Python 代码视图 视图输出方式： time line : 输出JSON events file, 再用chrome浏览器tracing功能进行查看，可视性很棒。 stdout ： 标准输出设备打印。 pprof file: 输出pprof的文件格式，再用pprof工具查看。 file: 输出到普通的文本文件。 视图和输出方式，可以自由组合，除了部分特例不能输出，比如op view 不支持time line输出，只有code view能够输出pprof格式的文件等，详细规则参见 Options 2.快速教程首先，确认下载安装了 r1.3 以上的tensorflow。网络模型使用mnist.py . import相关的包 12345import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datafrom tensorflow.python.profiler import model_analyzerfrom tensorflow.python.profiler import option_builder12341234 定义网络模型，创建session.、网络模型为 hidden1 + hidden2 + softmax 三层架构， hidden1和hidden2都是(Wx+b)-&gt;Relu的路径。 默认都运行在gpu:0 上。 12345678910111213141516171819# placeholderbatch_size = 100inputs = tf.placeholder(tf.float32, [batch_size,784])targets = tf.placeholder(tf.int32, [batch_size])# modelhidden1 = tf.layers.dense(inputs, 128, activation=tf.nn.relu, name='hidden1')hidden2 = tf.layers.dense(hidden1, 32, activation=tf.nn.relu, name='hidden2')logits = tf.layers.dense(hidden2, 10, activation=None, name='softmax_linear')# loss + train_oploss = tf.losses.sparse_softmax_cross_entropy(labels=targets, logits=logits)global_step = tf.Variable(0, name='global_step', trainable=False)train_op = tf.train.GradientDescentOptimizer(0.01).minimize(loss, global_step=global_step)init = tf.global_variables_initializer()sess = tf.Session()sess.run(init) 创建tfprofiler实例，作为记录、处理和显示数据的主体 12profiler = model_analyzer.Profiler(graph=sess.graph)11 定义trace level为FULL_TRACE，这样我们才能搜集到包括GPU硬件在内的最全统计数据 12run_options = tf.RunOptions(trace_level = tf.RunOptions.FULL_TRACE)11 创建RunMetadata， 用于在每次session.Run()时汇总统计数据 12run_metadata = tf.RunMetadata()11 循环执行session.Run()，搜集统计数据并添加到tfprofiler实例中 123456789101112131415mnist = input_data.read_data_sets(train_dir='./',fake_data=False)feed_dict = dict()for step in range(100): images_feed, labels_feed = mnist.train.next_batch(batch_size, fake_data=False) feed_dict = &#123;inputs: images_feed, targets: labels_feed&#125; #每 10 步，搜集一下统计数据： if step % 10 == 0: _, loss_value = sess.run(fetches=[train_op, loss],feed_dict=feed_dict, options=run_options, run_metadata=run_metadata) #将本步搜集的统计数据添加到tfprofiler实例中 profiler.add_step(step=step, run_meta=run_metadata) else: _, loss_value = sess.run(fetches=[train_op, loss], feed_dict=feed_dict) 接下来我们就可以显示统计视图了定义显示option 和 视图方式 定义显示option 和 视图方式option用于设置过滤条件、显示字段，完整option 参见Options，常用设置项目： account_type_regexes：采用Google RE2规则的正则表达式，过滤要显示的node的op type 和 device，比如 ‘.MatMul.‘, ‘.Conv2D’, ‘.gpu:0’等。 select：要显示的字段：[bytes|micros|accelerator_micros|cpu_micros|params|float_ops|occurrence|tensor_value|device|op_types|input_shapes] order_by: 显示结果排序方式：[name|depth|bytes|micros|accelerator_micros|cpu_micros|params|float_ops|occurrence] output: 输出方式：stdout, file 或者 timeline。 step: 显示在某个具体的Run() step的统计值. 缺省值-1，显示所有步骤的平均值。 一般来说， option和试图总是结合起来使用，这里举几个典型应用例子： 例子1：grpah view显示每个graph node运行时间，并输出到timeline 12345678910111213#统计内容为每个graph node的运行时间和占用内存profile_graph_opts_builder = option_builder.ProfileOptionBuilder( option_builder.ProfileOptionBuilder.time_and_memory())#输出方式为timeline# 输出文件夹必须存在profile_graph_opts_builder.with_timeline_output(timeline_file='/tmp/mnist_profiler.json')#定义显示sess.Run() 第70步的统计数据profile_graph_opts_builder.with_step(70)#显示视图为graph viewprofiler.profile_graph(profile_graph_opts_builder.build())123456789101112123456789101112 我们得到第70步的详细time line结果，打开chrome浏览器，输入about:tracing, 然后load “/tmp/mnist_profiler.json” 文件，这时候可以看见time line的显示结果。 横向是时间轴：各device对graph node的kernel调度时间轴、执行时间轴。 整个graph中所有执行到的node在devices上的运行分布。由于本例中node缺省使用gpu:0，所以cpu:0上没有执行node的分布。 一个kernel的执行包括调度和执行两个阶段，这两个阶段是异步操作，所以我们看到同一个时间点, 当 gpu:0/stream 上还在执行hidden1/Matmul, 而gpu：0已经开始调度下一个node: hidden1/add 的kernel, 这样实现了最大程度上不同node 间的并发。 你可以通过tf.device()将部分node分布到其他gpu上或者cpu上，看看做model parallel的结果。 例子2：scope view显示模型中的参数数量分布通过这种方式，查看各个layer中参数的总数，以控制模型的大小和参数分布。 1234567891011121314#统计内容为所有trainable Variable Opprofile_scope_opt_builder = option_builder.ProfileOptionBuilder( option_builder.ProfileOptionBuilder.trainable_variables_parameter())#显示的嵌套深度为4profile_scope_opt_builder.with_max_depth(4)#显示字段是params，即参数profile_scope_opt_builder.select(['params'])#根据params数量进行显示结果排序profile_scope_opt_builder.order_by('params')#显示视图为scope viewprofiler.profile_name_scope(profile_scope_opt_builder.build())1234567891011121312345678910111213 我们得到param数量从高到低的排序显示： 1234567891011121314==================Model Analysis Report======================node name | # parameters_TFProfRoot (--/104.94k params) hidden1 (--/100.48k params) hidden1/weights (784x128, 100.35k/100.35k params) hidden1/biases (128, 128/128 params) hidden2 (--/4.13k params) hidden2/weights (128x32, 4.10k/4.10k params) hidden2/biases (32, 32/32 params) softmax_linear (--/330 params) softmax_linear/weights (32x10, 320/320 params) softmax_linear/biases (10, 10/10 params)======================End of Report==========================]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>科研 - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java String和StringBuffer区别]]></title>
    <url>%2F2019%2F03%2F22%2FJava_06_%20String%2F</url>
    <content type="text"><![CDATA[String可变性 简单的来说：String 类中使用 final 关键字字符数组保存字符串，private final char value[]，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，可以参照源码。 123456789//AbstractStringBuilder.javaabstract class AbstractStringBuilder implements Appendable, CharSequence &#123; char[] value; int count; AbstractStringBuilder() &#123; &#125; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; String是不可变对象，即对象一旦生成，就不能被更改。对String对象的改变会引发新的String对象的生成。 121 String s = &quot;abcd&quot;;2 s = s+&quot;efgh&quot;; 执行以下代码实际上是生成了一个新的String对象。然后让引用指向新的String对象。所以内容经常改变的字符串不要使用String类型，由于这样会造成内存中大量的无引用对象，然后JVM的GC就会开始工作。 如下代码将会产生10000个无引用对象。 1234567891011String S1 = “abc”; For(int i = 0 ; i &lt; 10000 ; i ++) &#123; S1 + = “def”; S1 = “abc”; &#125; StringBufferStrinhBuffer:每次都对对象本身进行操作，而不是生成新的对象。所以在字符串内容不断改变的情况，建议使用StringBuffer。 String对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer慢。 如下代码，String的效率远比StringBuffer快。 121 String S1 = “This is only a” + “ simple” + “ test”; 2 StringBuffer Sb = new StringBuilder(“This is only a”).append(“simple”).append(“ test”); 这是因为，在JVM眼里：String S1 = “This is only a” + “ simple” + “ test”;就是String S1 = “This is only a simple test”; StringBuildStringBuild是JDK1.5新增加的一个类，与StringBuffer具有相同的操作。 区别在于：StringBuffer是线程安全的类。StringBuild不是线程安全的类，在单线程中性能要比StringBuffrer高。 例如：《Think in Java》中，描述HashTable和HashMap区别一样，就是因为HashTable支持线程同步、保证线程安全而导致的性能下降。 HashTable是线程安全的，很多方法都是synchronized方法。 HashMap不是线程安全的，但在单线程程序中的性能比HashTable要高。 使用总结 操作少量的数据 = String 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 多线程操作字符串缓冲区下操作大量数据 = StringBuffer]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-数据库基本概念]]></title>
    <url>%2F2019%2F03%2F19%2Fdatabase_01_MySQLbasic%2F</url>
    <content type="text"><![CDATA[数据库的基本概念 数据的存储方式 | 存储位置 | 优点 | 缺点 || ——– | ———————————————— | —————————- || 内存 | 速度快 | 不能永久保存，数据是临时状态 || 文件 | 数据可以永久保存 | 操作数据，查询某个数据不方便 || 数据库 | 1)数据可以永久保存2)查询速度快3)对数据的管理方便 | 占用资源，需要购买 | 什么是数据库：用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 所有的关系型数据库都可以使用通用的SQL语句进行管理 常见的数据库软件 MySQL：开源免费的数据库，小型的数据库，已经被Oracle收购了。MySQL6.x版本也开始收费。后来Sun公司收购了MySQL，而Sun公司又被Oracle收购 Oracle：收费的大型数据库，Oracle公司的产品。 DB2 ：IBM公司的数据库产品,收费的。常应用在银行系统中。 SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。 SQLite: 嵌入式的小型数据库，应用在手机端，如：Android。 MySQL数据库软件1. 安装安装过程分成两个部分：1)文件解压和复制过程，默认的安装目录2)安装好以后必须对MySQL服务器进行配置在mysql中管理员的名字：root 1.打开下载的mysql安装文件双击解压缩，运行“mysql-5.5.40-win32.msi”。 2.选择安装类型，有“Typical（默认）”、“Complete（完全）”、“Custom（用户自定义）”三个选项，选择“Custom”，按“next”键继续。 3.点选“Browse”，手动指定安装目录。 4.确认一下先前的设置，如果有误，按“Back”返回重做。按“Install”开始安装。 数据库安装好了还需要对数据库进行配置才能使用 MYSQL的配置 5.安装完成后，进入mysql配置向导。 6.选择配置方式，“Detailed Configuration（手动精确配置）”、“Standard Configuration（标准配置）” 7.选择服务器类型，“Developer Machine（开发测试类，mysql占用很少资源）”、“Server Machine（服务器类型，mysql占用较多资源）”、“Dedicated MySQL Server Machine（专门的数据库服务器，mysql占用所有可用资源）” 8.选择mysql数据库的大致用途，“Multifunctional Database（通用多功能型，好）”、“Transactional Database Only（服务器类型，专注于事务处理，一般）”、“Non-Transactional Database Only（非事务处理型，较简单，主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional），按“Next”继续。 9.选择网站并发连接数，同时连接的数目，“Decision Support(DSS)/OLAP（20个左右）”、“Online Transaction Processing(OLTP)（500个左右）”、“Manual Setting（手动设置）”。 10.是否启用TCP/IP连接，设定端口。如果不启用，就只能在自己的机器上访问mysql数据库了，在这个页面上，您还可以选择“启用标准模式”（Enable Strict Mode），这样MySQL就不会允许细小的语法错误。如果是新手，建议您取消标准模式以减少麻烦。但熟悉MySQL以后，尽量使用标准模式，因为它可以降低有害数据进入数据库的可能性。按“Next”继续 11.对mysql默认数据库语言编码进行设置（重要），一般选UTF-8，按 “Next”继续。 12.选择是否将mysql安装为windows服务，还可以指定Service Name（服务标识名称），是否将mysql的bin目录加入到Windows PATH（加入后，就可以直接使用bin下的文件，而不用指出目录名，比如连接，“mysql.exe -uusername -ppassword;”就可以了，不用指出mysql.exe的完整地址，很方便），这里全部打上勾，Service Name不变。按“Next”继续。 13.询问是否要修改默认root用户（超级管理）的密码。“Enable root access from remote machines（是否允许root用户在其它的机器上登陆，如果要安全，就不要勾上，如果要方便，就勾上它）”。最后“Create An Anonymous Account（新建一个匿名用户，匿名用户可以连接数据库，不能操作数据，包括查询）” 14.确认设置无误，按“Execute”使设置生效，即完成MYSQL的安装和配置。 2.卸载1.停止window的MySQL服务。 找到“控制面板”-&gt; “管理工具”-&gt; “服务”，停止MySQL后台服务。 2.卸载MySQL安装程序。找到“控制面板”-&gt; “程序和功能”，卸载MySQL程序。 3.删除MySQL安装目录下的所有文件。 4.删除c盘ProgramDate目录中关于MySQL的目录。路径为：C:\ProgramData\MySQL(是隐藏文件,需要显示出来) 3.配置MySQL服务启动。1)通过服务的方式自动启动，也可以cmd--&gt; services.msc 打开服务的窗口 2)命令启动的方式 123使用管理员打开cmd net start mysql : 启动mysql的服务 net stop mysql:关闭mysql服务 4.登录、退出MySQL是一个需要账户名密码登录的数据库，登陆后使用，它提供了一个默认的root账号，使用安装时设置的密码即可登录。 12345mysql -uroot -p密码mysql -hip -uroot -p连接目标的密码 //连接到其他ipmysql --host=ip --user=root --password=连接目标的密码 退出 121. exit2. quit 5.SQLyog图形化工具——客户端SQLyog是业界著名的Webyog公司出品的一款简洁高效、功能强大的图形化MySQL数据库管理工具。使用SQLyog可以快速直观地让您从世界的任何角落通过网络来维护远端的MySQL数据库。 MySQL目录结构 数据库管理系统数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中表内的数据。 1. 数据库管理系统、数据库和表的关系数据库管理程序(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体User的数据。数据库管理系统、数据库和表的关系如图所示： 1)一个数据库服务器包含多个库2)一个数据库包含多张表3)一张表包含多条记录]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库 - MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Space-Time Scheduling for GPU Inference论文总结]]></title>
    <url>%2F2019%2F03%2F18%2Fpaper_03_Dynamic%20Space-Time%20Scheduling%20for%20GPU%20Inference%2F</url>
    <content type="text"><![CDATA[Dynamic Space-Time Scheduling for GPU Inference论文总结摘要1.在线推断任务典型的小批量导致GPU利用率较低，GPU资源共享可以解决性能差距。 2.在本文中，探索了几种利用时间和空间复用来提高深度学习推理工作负载的GPU利用率的技术。 3.与传统的批量推理相比，评估每种方法在资源效率，延迟可预测性和隔离方面的性能。 4.实验分析表明，通过探索更先进的空间和时间复用策略，可以提高5倍的利用率。 5.动态空时调度器的初步原型比仅用空间复用的策略高3.23倍浮点吞吐量，在卷积上比仅用时间复用策略增加7.73倍，同时还提供了更好的隔离和延迟可预测性。 出发点11.GPU通过并行性，高内存带宽和张量加速，可以快速计算大批量输入数据，对于深度学习至关重要。 2.深度学习部署在视频监控，语言翻译和语音识别等应用中，对并行硬件加速的需求很大以支持推理。虽然有许多专用推理处理器，但GPU的广泛性，对通用深度学习模型的支持使GPU成为推理必不可少的。 3.DNN训练成本高，但不频繁。而在线推理需要每天数十亿次查询。亚马逊宣布大约90％的机器学习计算用于推理（而非训练）。关键的应用程序指标会因延迟增加而受到严重影响。 4.端到端延迟预算（&lt;100ms），高准确性的模型尺寸和复杂性不断增加。SENet-184模型具有4：1的CPU推断延迟。 CPU无法支持今天的交互模型服务工作负载 出发点21.训练负载大，很容易使GPU饱和。但推理具有不同的性能要求，导致GPU利用率较低。与面向吞吐量的模型训练相比，推断查询会随机到达，推理必须满足延迟目标（牺牲吞吐量）。 2.在线推理无法实现小批量迭代训练时的高并行性; 较低的并行性导致GPU利用率低。 3.推理小批量所引发的问题随着模型复杂性增加而加剧，GPU推理延迟不断接近交互式SLO。由于推理工作负载必须连续运行并响应高度可变的需求，必须为需求峰值配置容量，这进一步降低了GPU利用率。 4.小批量可能导致GPU低利用率低于15％，测试中谷歌的Tensor Processing Unit的吞吐量平均低于峰值的23％，某些模型的吞吐量低于4％。目前独占访问GPU的做法导致硬件的低利用率，且无法得到扩展。 系统中总会有少量响应的延迟高于均值，我们把这些响应称为尾延迟（TailLatency）。 图1表示DNN模型的复杂性随着时间在CPU和GPU上不断增加。 大多数型号都无法满足CPU上300ms的延迟SLO。 图2表示为了满足延迟SLO，必须使用小批量尺寸，这导致GPU利用率较低。 SLO中ResNet-50的最大批量为26，但仅达到峰值V100 FP32吞吐量的28％。 改进做法概述1.在随机请求负载下，提高利用率的常用方法是利用多用户。通过多个预测工作负载之间共享GPU，可以潜在地利用工作负载级并行性并实现统计复用。但在GPU上利用多用户是一个开放的研究问题。首先，它的运行时性能必须是可预测的，但它并不总是正确的。 第二，它必须是资源有效的，作者探索了几种在一组执行内核之间共享GPU的技术，每种技术都有其缺点。 第三，需要衡量性能隔离度，通过公平的资源分配来实现。 2.当前方法通过空间或时间复用GPU。作者认为只有跨空间或时间的多路复用才能满足上述条件。第3节评估了针对上述三个标准的现行方法。通过使用动态查询批处理将多个执行内核打包在不相交的DNN图上，显示多租户解决方案吞吐量增加3倍，同时提供隔离和可预测性。 应用程序模型：托管云推理服务 使用云托管服务部署在线推理ML模型，如AWS SageMaker或GoogleCloud ML Engine。用户将训练好的模型上传到在线服务器。在线服务将模型部署到一个或多个副本上，每个副本可以使用CPU和GPU。用户设定某些服务级别目标（SLO），例如模型推断的尾延迟。 简化了模型，隔离多租户执行而产生的干扰影响。首先，在单个GPU上运行的所有模型都有相同的架构（权重不同），将异构模型架构的影响与多租户分开。其次，请求队列总是饱和，从而将模型服务延迟与请求排队延迟隔离开来。解决模型异构性和排队延迟是未来工作的重点。 仅空间和仅时间多路复用的限制1.当前模型推理的三种主要方法：（1）独占。每个型号独占GPU，AWS SageMaker，GoogleCloud ML Engine，Clipper 和TensorFlow Serving都使用这种方法。推断是分批进行的，执行前向传播时，新查询必须在队列中等待，直到之前的前向传播完成。 （2）时间复用。设备上调度程序一次启用多个CUDA上下文环境交叉执行。当多个进程使用相同的GPU并发运行时，这种方法很常见。当不同的进程竞争相同的资源时，这种方法依赖于内核来时间复用进程和GPU来交换上下文。 （3）空间复用。 利用NVIDIA Hyper-Q，内核执行可以重叠。 CUDA Streams和NVIDIA Multi Process Service（MPS）利用多个硬件队列来实现GPU的空间共享。 CUDA Streams API由ModelBatch和NVIDIA TensorRT 使用。AMD的MxGPU（SR-IOV）是另一种空间复用方法，本文没有考虑。 在本文中，考虑两种空间复用： a.使用MPS的隐式空间复用：NVIDIA MPS通过为它们分配不同的cuda流，允许同时在设备上运行多个进程。 b.使用CUDA流进行显式空间复用：使用此方法，我们可以直接与单个进程内的多个CUDA流进行交互。 评测每种模型推理方法的延迟可预测性，资源效率和性能隔离。 实验设置在两个图像分类神经上评估这三种虚拟化方法：MobileNet V2和ResNet-50。 这两种模型分别是低计算和高精度分类的代表。 1.在GPU上执行单个模型批量查询测试独占访问。虽然我们不能在单个GPU上使用多个模型，但此测试表示了单用户延迟下限，以及性能的理想情况。 2.在单独的CUDA上下文中运行每个模型并利用调度器来交错执行，测试时间复用。 这提供了内存安全性和租户之间的基本隔离。 3.通过使用NVIDIA MPS对跨CUDA Streams pool的不同模型的查询进行分区来测试空间复用。 所有实验都在Amazon AWS上使用p3.2xlarge或p3.8xlarge实例。 这些实例可直接访问NVIDIA V100数据中心级GPU，具有高达14 TFLOP / s的单精度浮点运算量。 在实验中没有测试Tensor Core共享。 图3表示，时间和空间复用都不如独占访问的性能; 空间复用比时间复用推理延迟更低。我们比较了GPU多用户的三种方法。 独占访问（通过对单个模型进行批处理建模）以高成本提供快速且可预测的延迟。 随着共享的增加，时间复用显着增加了推理延迟。 通过NVIDIA MPS进行空间复用可以通过共享资源更好地控制延迟。 实验结果图3中基准测试的结果，对于MobileNet V2（计算优化模型）和ResNet-50（高精度模型），我们测试了批量独占访问，时间复用和空间复用。 批量独占访问将整个GPU用于单个模型。这代表了如果只有一个模型独占GPU，并且吞吐量是唯一目标时的理想性能。（改变批量大小以增加吞吐量）但是如果希望最小化延迟，则使用更小的批量。 与独占访问相比，时间复用延迟慢了4.6倍，空间复用延迟慢了2.2倍。单一解决方案无法满足在第1节中建立的三个标准。 图4表示，当不同数量的进程同时运行时，隐式空间复用（使用MPS）具有不可预测的延迟。当我们向运行10个多租户模型的GPU添加副本时，我们会发现不可预测性，我们怀疑这是由设备上的调度程序引起的。 图5表示，时间和隐式空间复用都受内存限制，而 显式空间复用不受。 实验中，大多数方法在18个副本上达到16 GB的内存上限，此时GPU内存耗尽。而显式空间复用（不同线程上的CUDA Streams）能够扩展到至少60个ResNet-50模型。 1.独占访问满足低延迟，隔离和可预测性，但是无法共享GPU导致成本非常昂贵。正如图2中所示，这种性能是在权衡在线推理工作负载的低GPU利用率以满足严格的延迟SLO。如果在推理期间具有足够高的请求率，并且批量请求能同时到达开始前向传播，那么这种方法能很好利用GPU。 2.时间复用（CUDA上下文切换）可以实现多租户良好隔离和延迟可预测性，但代价是吞吐量降低和延迟高。这种方法的主要缺点是它无法利用内核的并行执行，因为GPU一次只允许运行一个CUDA上下文。这种方法在交错过程会略微提高资源效率;然而它在每个调度量程中仍然受到利用率低的影响，随着副本数量的增加，呈现线性减速。较差的延迟使得时间复用不能成为交互式推理查询服务的方法。 3.空间复用（Hyper-Q）提高了利用率，并实现了更好的资源效率，但是可预测性和隔离性较差。空间多路复用对租户数量的选择极其敏感。模型运行时，每个租户都具有一致的行为。 但是，在多个模型租户中，GPU上最快的模型与最慢的模型存在高达25％的延迟差距，如图4所示，当奇数个进程启用MPS同时运行时，不同进程之间的延迟不可预测性和差异会加剧。 动态时空调度1.图3和图5展示了仅空间和仅时间复用策略的可扩展性限制。图4详细说明了将租户添加到GPU时无法预测的延迟。图5显示了在GPU上安排数百个模型的唯一方法是在单个进程中每个线程使用一个CUDA流;因为我们通过将内核分派到不同的流来微观地管理推理，所以有机会对流进行更细粒度的调度以优化延迟和吞吐量。 2.鉴于这些限制，我们提出了动态时空调度，以便有效地利用GPU，同时保持隔离和可预测性。通过监控每个内核的推理延迟来保持虚拟化时的可预测性和隔离性，允许在租户之间重新分配资源。注意到CUDA Stream调度异常只会产生一些落后者，我们可以简单地驱逐落后者而不会显着影响总体系统吞吐量。 3.该方法显着提高了GPU上的资源效率，与仅时间多路复用相比，吞吐量平均速度提高了7.71，与仅空间多路复用相比增加了3.23。如图7所示，时空调度合并了许多不相交的DNN图上的并发小内核，成为较大的超级内核一起填充GPU。 超级内核避免了仅空间复用方法相关联的调度惩罚。交互式推理查询随机到达，我们无法提前计算超级内核。时空调度程序必须在内核到达时动态调度内核，我们正在研究更通用的动态调度程序设计。我们注意到，如果缓存超级内核，随着工作负载随时间稳定，开销会逐渐减少。 我们的目标是动态优化一批不同的模型，与先前的DNN图优化器相比，如TVM，Tensor Comprehensions，Halide，GLOW和TensorRT。这些优化器通过内核融合和自动调整优于单租户优化。但是，我们的方法侧重于优化许多不相交图的性能。 我们的方法是对Guevara等人开发的方法的动态替代方案。他们通过手动组合流中的小内核以提高GPU利用率，在高斯消除算法上产生高达1.3倍的加速。Guevara等人的工作侧重于在CUDA块级手动合并内核，我们的方法侧重于批量处理大量动态执行类似的矩阵乘法例程的内核，以及交错的CUDA流。我们的方法在多个神经网络任务中具有高可扩展性，并与现有生态系统相辅相成。 动态时空调度基准通过单精度浮点通用矩阵乘法内核（SGEMM）按仅时间，仅空间和空时多路复用策略评估总吞吐量。除了傅立叶域，Winograd域和直接内核实现之外，矩阵乘法通常用于在神经网络中实现卷积运算。 图7表明，与GPU共享的时间分割方法相比，通过Hyper-Q / CUDA流实现的空间复用可以提高吞吐量。但是吞吐量远低于V100提供的单精度吞吐量（3.1节）。我们设计了一种调度程序，它可以跨模型对内核进行批处理，而不是维护设备可以精细调度的单独内核流。通过将内核跨多个模型批处理组成单个超级内核中，有可能使GPU上的所有时间片资源饱和。 为了模拟时空多路复用软件调度器的性能，我们测量了标称方法的吞吐量 - 从同一架构的几个模型收集SGEMM问题到单个批量矩阵乘法超级内核。在多租户设置中，这些模型具有不同的权重和输入。 批量超级内核比许多较小的内核调用更有效，并且还可以更好地对GPU进行空间多路复用。 这还允许更好地预测延迟，因为动态内核调度程序可以选择性地将内核组成批并确定何时基于每个模型的SLO执行工作负载。 我们的目标是动态优化一批不同的模型，与先前的DNN图优化器相比，如TVM，Tensor Comprehensions，Halide，GLOW和TensorRT。这些优化器通过内核融合和自动调整优于单租户优化。但是，我们的方法侧重于优化许多不相交图的性能。 我们的方法是对Guevara等人开发的方法的动态替代方案。他们通过手动组合流中的小内核以提高GPU利用率，在高斯消除算法上产生高达1.3倍的加速。Guevara等人的工作侧重于在CUDA块级手动合并内核，我们的方法侧重于批量处理大量动态执行的矩阵乘法内核，以及交错的CUDA流。我们的方法在多个神经网络任务中具有高可扩展性，并与现有生态系统相辅相成。 总结这项工作中，我们评估了空间和时间复用技术，以支持在单个GPU上多个模型进行推理。我们首先考虑了流行的DNN框架和GPU供应商（如NVIDIA）使用的标准方法。虽然这些技术提高了利用率，但它们增加了基准测试中的延迟和预测可变性。仅空间和仅时间的多路复用技术都不能实现高资源效率，可预测的延迟和隔离。我们观察到批量级并行和仅空间复用之间存在巨大的性能差距，这表明有很多提高利用率的机会。我们提出了一个动态的空时调度程序，它可以满足上述三个标准。跨多模型和输入的内核运算的软件级融合，提供了一种有效的在线推理调度方法。作为方法的早期评估，我们通过SGEMM融合所有排队问题来研究性能上限，这提供了GPU多租户或多模型扩展的吞吐量。与在线推理先前技术水平相比，有超过3倍的加速比。我们相信这项工作指向通过智能模型间融合内核调度实现深度神经网络高效多租户执行的新方法。]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>深度学习任务调度 - 论文阅读 - 科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML笔记]]></title>
    <url>%2F2019%2F03%2F17%2Ffront_01_HTML%2F</url>
    <content type="text"><![CDATA[HTML笔记1. web概述1.1 JavaWeb： 使用Java语言开发基于互联网的项目 1.2 软件架构：C/S: Client/Server 客户端/服务器端 * 在用户本地有一个客户端程序，在远程有一个服务器端程序 * 如：QQ，迅雷... * 优点： 1. 用户体验好 * 缺点： 1. 开发、安装，部署，维护 麻烦 B/S: Browser/Server 浏览器/服务器端 * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序 * 优点： 1. 开发、安装，部署，维护 简单 * 缺点： 1. 如果应用过大，用户的体验可能会受到影响 2. 对硬件要求过高 1.3 B/S架构详解资源分类： 静态资源： * 使用静态网页开发技术发布的资源。 * 特点： * 所有用户访问，得到的结果是一样的。 * 如：文本，图片，音频、视频, HTML,CSS,JavaScript * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源： * 使用动态网页及时发布的资源。 * 特点： * 所有用户访问，得到的结果可能不一样。 * 如：jsp/servlet,php,asp... * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 要学习动态资源，必须先学习静态资源！ 静态资源： HTML：用于搭建基础网页，展示页面的内容 CSS：用于美化页面，布局页面 JavaScript：控制页面的元素，让页面有一些动态的效果 2. HTML笔记 概念：是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本: 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. 标记语言: 由标签构成的语言。&lt;标签名称&gt; 如 html，xml 标记语言不是编程语言 使用： 语法： html文档后缀名 .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 自闭和标签：开始标签和结束标签在一起。如 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误： 正确： 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写 &lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color=&apos;red&apos;&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color=&apos;green&apos;&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 3. 标签笔记： 文件标签：构成html最基本的标签 html:html文档的根标签 head：头标签。用于指定html文档的一些属性。引入外部的资源 title：标题标签。 body：体标签 &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档 文本标签：和文本有关的标签 * 注释：&lt;!-- 注释内容 --&gt; * &lt;h1&gt; to &lt;h6&gt;：标题标签 * h1~h6:字体大小逐渐递减 * &lt;p&gt;：段落标签，分段 * &lt;br&gt;：换行标签 * &lt;hr&gt;：展示一条水平线 * 属性： * color：颜色 * width：宽度 * size：高度 * align：对其方式 * center：居中 * left：左对齐 * right：右对齐 * &lt;b&gt;：字体加粗 * &lt;i&gt;：字体斜体 * &lt;center&gt;:文本居中 * &lt;font&gt;:字体标签 * 属性： * color：颜色 * size：大小 * face：字体 * 属性定义： * color： 1. 英文单词：red,green,blue 2. rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) 3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF * width： 1. 数值：width=&apos;20&apos; ,数值的单位，默认是 px(像素) 2. 数值%：占比相对于父元素的比例 *特殊字符：空格是&amp;nbsp; 版权是&amp;copy 图片标签： img：展示图片 * 属性： * src：指定图片的位置 * alt: 加载失败显示替换信息 * 代码： &lt;!--展示一张图片 img--&gt; &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt; *相对路径： * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录 &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt; &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt; 列表标签： 有序列表： ol: 属性 type: 标识样式 start: 开始顺序 li: 无序列表： ul: 属性： type: 列表项样式 li: 链接标签： * a:定义一个超链接 * 属性： * href：指定访问资源的URL(统一资源定位符) * target：指定打开资源的方式 * _self:默认值，在当前页面打开 * _blank：在空白页面打开 * mailto：发送邮件 * 代码： &lt;!--超链接 a--&gt; &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;mailto:hello@hello.com&quot;&gt;联系我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;https://www.baidu.com&quot;&gt;&lt;img src=&quot;image/1.jpg&quot;&gt;&lt;/a&gt; div和span：用于css控制样式 * div:每一个div占满一整行。块级标签 * span：文本信息在一行展示，行内标签 内联标签 语义化标签：html5中为了提高程序的可读性，提供了一些标签。没有样式，结合css用 121. &lt;header&gt;：页眉2. &lt;footer&gt;：页脚 表格标签： * table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 &lt;td clospan=&quot;2&quot;&gt;&lt;/td&gt; * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 * &lt;thead&gt;：表示表格的头部分 * &lt;tbody&gt;：表示表格的体部分 * &lt;tfoot&gt;：表示表格的脚部分 使用注意：]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记]]></title>
    <url>%2F2019%2F03%2F17%2Ffront_02_CSS%2F</url>
    <content type="text"><![CDATA[CSS笔记1. HTML标签：表单标签 2. CSS： HTML标签：表单标签* 表单： * 概念：用于采集用户输入的数据的。用于和服务器进行交互。 * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 * 属性： * action：指定提交数据的URL * method:指定提交方式 * 分类：一共7种，2种比较常用 * get： 1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 2. 请求参数大小是有限制的。 3. 不太安全。 * post： 2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 2. 请求参数的大小没有限制。 3. 较为安全。 * 表单项中的数据要想被提交：必须指定其name属性 ​ * 表单项标签： ​ * input：可以通过type属性值，改变元素展示的样式 ​ * type属性： ​ * text：文本输入框，默认值 ​ * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 ​ * password：密码输入框 ​ * radio:单选框 ​ * 注意： ​ 1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 ​ 2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 ​ 3. checked属性，可以指定默认值 ​ * checkbox：复选框 ​ * 注意： ​ 1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 ​ 2. checked属性，可以指定默认值 ​ * file：文件选择框 * hidden：隐藏域，用于提交一些信息。 * 按钮： * submit：提交按钮。可以提交表单 * button：普通按钮 * image：图片提交按钮 * src属性指定图片的路径 * label：指定输入项的文字描述信息 * 注意： * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 * select: 下拉列表 * 子元素：option，指定列表项 * textarea：文本域 * cols：指定列数，每一行有多少个字符 * rows：默认多少行。 CSS：页面美化和布局控制1. 概念： Cascading Style Sheets 层叠样式表 * 层叠：多个样式可以作用在同一个html的元素上，同时生效 2. 好处： 1. 功能强大 2. 将内容展示和样式控制分离 * 降低耦合度。解耦 * 让分工协作更容易 * 提高开发效率 3. CSS的使用：CSS与html结合方式 1. 内联样式 * 在标签内使用style属性指定css代码 * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt; 2. 内部样式 * 在head标签内，定义style标签，style标签的标签体内容就是css代码 * 如： &lt;style&gt; div{ color:blue; } &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 3. 外部样式 1. 定义css资源文件。 2. 在head标签内，定义link标签，引入外部的资源文件 * 如： * a.css文件： div{ color:green; } &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; * 注意： * 1,2,3种方式 css作用范围越来越大 * 1方式不常用，后期常用2,3 * 3种格式可以写为： &lt;style&gt; @import &quot;css/a.css&quot;; &lt;/style&gt; 4. css语法： * 格式： 选择器 { 属性名1:属性值1; 属性名2:属性值2; ... } * 选择器:筛选具有相似特征的元素 * 注意： * 每一对属性需要使用；隔开，最后一对属性可以不加； 5. 选择器：筛选具有相似特征的元素 * 分类： 1. 基础选择器 1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 * 语法：#id属性值{} 2. 元素选择器：选择具有相同标签名称的元素 * 语法： 标签名称{} * 注意：id选择器优先级高于元素选择器 3. 类选择器：选择具有相同的class属性值的元素。 * 语法：.class属性值{} * 注意：类选择器选择器优先级高于元素选择器 2. 扩展选择器： 1. 选择所有元素： * 语法： *{} 2. 并集选择器： * 选择器1,选择器2{} 3. 子选择器：筛选选择器1元素下的选择器2元素 * 语法： 选择器1 选择器2{} 4. 父选择器：筛选选择器2的父元素选择器1 * 语法： 选择器1 &gt; 选择器2{} 5. 属性选择器：选择元素名称，属性名=属性值的元素 * 语法： 元素名称[属性名=&quot;属性值&quot;]{} 6. 伪类选择器：选择一些元素具有的状态 * 语法： 元素:状态{} * 如： &lt;a&gt; * 状态： * link：初始化的状态 * visited：被访问过的状态 * active：正在访问状态 * hover：鼠标悬浮状态 6. 属性 1. 字体、文本 * font-size：字体大小 * color：文本颜色 * text-align：对其方式 * line-height：行高 2. 背景 * background： 3. 边框 * border：设置边框，符合属性 4. 尺寸 * width：宽度 * height：高度 5. 盒子模型：控制布局 * margin：外边距 * padding：内边距 * 默认情况下内边距会影响整个盒子的大小 * box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 * float：浮动 * left * right 案例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;style&gt; *{ margin: 0px; padding: 0px; box-sizing: border-box; } body{ background: url(&quot;img/register_bg.png&quot;) no-repeat center; padding-top: 25px; } .rg_layout{ width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; /*让div水平居中*/ margin: auto; } .rg_left{ /*border: 1px solid red;*/ float: left; margin: 15px; } .rg_left &gt; p:first-child{ color:#FFD026; font-size: 20px; } .rg_left &gt; p:last-child{ color:#A6A6A6; font-size: 20px; } ​ .rg_center{ ​ float: left; ​ /* border: 1px solid red;*/ ​ } .rg_right{ /*border: 1px solid red;*/ float: right; margin: 15px; } .rg_right &gt; p:first-child{ font-size: 15px; } .rg_right p a { color:pink; } .td_left{ width: 100px; text-align: right; height: 45px; } .td_right{ padding-left: 50px ; } #username,#password,#email,#name,#tel,#birthday,#checkcode{ width: 251px; height: 32px; border: 1px solid #A6A6A6 ; /*设置边框圆角*/ border-radius: 5px; padding-left: 10px; } #checkcode{ width: 110px; } #img_check{ height: 32px; vertical-align: middle; } #btn_sub{ width: 150px; height: 40px; background-color: #FFD026; border: 1px solid #FFD026 ; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;rg_layout&quot;&gt; &lt;div class=&quot;rg_left&quot;&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;USER REGISTER&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;rg_center&quot;&gt; &lt;div class=&quot;rg_form&quot;&gt; &lt;!--定义表单 form--&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt; &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt; &lt;/td&gt; &lt;/tr&gt; ​ &lt;tr&gt; ​ &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; ​ &lt;/tr&gt; ​ &lt;/table&gt; ​ &lt;/form&gt; ​ &lt;/div&gt; ​ &lt;/div&gt; &lt;div class=&quot;rg_right&quot;&gt; &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; ​ &lt;/div&gt; ​ &lt;/body&gt; ​ &lt;/html&gt;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow打印tensor值]]></title>
    <url>%2F2019%2F03%2F10%2Ftensor_05_print_tensor%2F</url>
    <content type="text"><![CDATA[tensorflow打印tensor值在tensorflow中，打印一个tensor值必须在在一个会话Session中进行，并且可以使用Session.run()或Tensor.eval()进行打印x的值： 使用 print(sess.run(x)) 使用print(x.eval()) Session.run和Tensor.eval1.联系：如果t是一个tf.Tensor对象，则tf.Tensor.eval是tf.Session.run的缩写（其中 的tf.Sesstion是tf.get_default_session)也就是： 1tensor.eval()=tf.get_default_session().run(tensor) 2.区别：这两个中间最主要的区别就在于 使用sess.run()能在同一步获取多个tensor中的值。 123456789import tensorflow as tfx = tf.ones(shape=[2, 3], dtype=tf.int32,name=&apos;x&apos;)y= tf.zeros(shape=[2, 3], dtype=tf.float32,name=&apos;y&apos;)with tf.Session() as sess: print(sess.run([x，y])) #一次能打印两个 print(x.eval()) print(y.eval()) #一次只能打印一个]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>科研 - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 TensorFlow Serving 和 Docker 快速部署机器学习服务]]></title>
    <url>%2F2019%2F03%2F10%2Ftensor_04_docker_serving%2F</url>
    <content type="text"><![CDATA[从实验到生产，简单快速部署机器学习模型一直是一个挑战。这个过程要做的就是将训练好的模型对外提供预测服务。在生产中，这个过程需要可重现，隔离和安全。这里，我们使用基于Docker的TensorFlow Serving来简单地完成这个过程。TensorFlow 从1.8版本开始支持Docker部署，包括CPU和GPU，非常方便。 获得训练好的模型获取模型的第一步当然是训练一个模型，但是这不是本篇的重点，所以我们使用一个已经训练好的模型，比如ResNet。TensorFlow Serving 使用SavedModel这种格式来保存其模型，SavedModel是一种独立于语言的，可恢复，密集的序列化格式，支持使用更高级别的系统和工具来生成，使用和转换TensorFlow模型。这里我们直接下载一个预训练好的模型： 12$ mkdir /tmp/resnet$ curl -s https://storage.googleapis.com/download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC_jpg.tar.gz | tar --strip-components=2 -C /tmp/resnet -xvz 如果是使用其他框架比如Keras生成的模型，则需要将模型转换为SavedModel格式，比如： 12345678910111213141516171819from keras.models import Sequentialfrom keras import backend as Kimport tensorflow as tfmodel = Sequential()# 中间省略模型构建# 模型转换为SavedModelsignature = tf.saved_model.signature_def_utils.predict_signature_def( inputs=&#123;&apos;input_param&apos;: model.input&#125;, outputs=&#123;&apos;type&apos;: model.output&#125;)builder = tf.saved_model.builder.SavedModelBuilder(&apos;/tmp/output_model_path/1/&apos;)builder.add_meta_graph_and_variables( sess=K.get_session(), tags=[tf.saved_model.tag_constants.SERVING], signature_def_map=&#123; tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: signature &#125;)builder.save() 下载完成后，文件目录树为： 1234567$ tree /tmp/resnet/tmp/resnet└── 1538687457 ├── saved_model.pb └── variables ├── variables.data-00000-of-00001 └── variables.index 部署模型第一步是安装Docker CE。这将为您提供运行和管理Docker容器所需的所有工具。现在我们有了我们的模型，使用Docker服务就像拉动最新发布的TensorFlow服务服务环境镜像一样简单，并将其指向模型： 使用Docker部署模型服务： 12345678$ docker pull tensorflow/serving$ docker run -p 8501:8501 --name tfserving_resnet \--mount type=bind,source=/tmp/resnet,target=/models/resnet \-e MODEL_NAME=resnet -t tensorflow/serving &amp;…… main.cc:327] Running ModelServer at 0.0.0.0:8500…… main.cc:337] Exporting HTTP/REST API at:localhost:8501 … 分解命令行参数，分别是： -p 8501:8501 ：将容器的端口8501（TF服务响应REST API请求）发布到主机的端口8501 --name tfserving_resnet ：给容器我们创建名称“tfserving_resnet”，以便我们稍后可以参考它 --mount type=bind,source=/tmp/resnet,target=/models/resnet ：在主机（/ models / resnet）上安装主机的本地目录（/ tmp / resnet），以便TF服务可以从容器内部读取模型。 -e MODEL_NAME=resnet ：Telling TensorFlow服务加载名为“resnet”的模型 -t tensorflow/serving ：根据服务镜像“tensorflow / serving”运行Docker容器 其中，8500端口对于TensorFlow Serving提供的gRPC端口，8501为REST API服务端口。上述命令输出为 123456789101112131415161718192019-03-04 02:52:26.610387: I tensorflow_serving/model_servers/server.cc:82] Building single TensorFlow model file config: model_name: resnet model_base_path: /models/resnet2019-03-04 02:52:26.618200: I tensorflow_serving/model_servers/server_core.cc:461] Adding/updating models.2019-03-04 02:52:26.618628: I tensorflow_serving/model_servers/server_core.cc:558] (Re-)adding model: resnet2019-03-04 02:52:26.745813: I tensorflow_serving/core/basic_manager.cc:739] Successfully reserved resources to load servable &#123;name: resnet version: 1538687457&#125;2019-03-04 02:52:26.745901: I tensorflow_serving/core/loader_harness.cc:66] Approving load for servable version &#123;name: resnet version: 1538687457&#125;2019-03-04 02:52:26.745935: I tensorflow_serving/core/loader_harness.cc:74] Loading servable version &#123;name: resnet version: 1538687457&#125;2019-03-04 02:52:26.747590: I external/org_tensorflow/tensorflow/contrib/session_bundle/bundle_shim.cc:363] Attempting to load native SavedModelBundle in bundle-shim from: /models/resnet/15386874572019-03-04 02:52:26.747705: I external/org_tensorflow/tensorflow/cc/saved_model/reader.cc:31] Reading SavedModel from: /models/resnet/15386874572019-03-04 02:52:26.795363: I external/org_tensorflow/tensorflow/cc/saved_model/reader.cc:54] Reading meta graph with tags &#123; serve &#125;2019-03-04 02:52:26.828614: I external/org_tensorflow/tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA2019-03-04 02:52:26.923902: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:162] Restoring SavedModel bundle.2019-03-04 02:52:28.098479: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:138] Running MainOp with key saved_model_main_op on SavedModel bundle.2019-03-04 02:52:28.144510: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:259] SavedModel load for tags &#123; serve &#125;; Status: success. Took 1396689 microseconds.2019-03-04 02:52:28.146646: I tensorflow_serving/servables/tensorflow/saved_model_warmup.cc:83] No warmup data file found at /models/resnet/1538687457/assets.extra/tf_serving_warmup_requests2019-03-04 02:52:28.168063: I tensorflow_serving/core/loader_harness.cc:86] Successfully loaded servable version &#123;name: resnet version: 1538687457&#125;2019-03-04 02:52:28.174902: I tensorflow_serving/model_servers/server.cc:286] Running gRPC ModelServer at 0.0.0.0:8500 ...[warn] getaddrinfo: address family for nodename not supported2019-03-04 02:52:28.186724: I tensorflow_serving/model_servers/server.cc:302] Exporting HTTP/REST API at:localhost:8501 ...[evhttp_server.cc : 237] RAW: Entering the event loop ... 我们可以看到，TensorFlow Serving使用1538687457作为模型的版本号。我们使用curl命令来查看一下启动的服务状态，也可以看到提供服务的模型版本以及模型状态。 12345678910111213$ curl http://localhost:8501/v1/models/resnet&#123; &quot;model_version_status&quot;: [ &#123; &quot;version&quot;: &quot;1538687457&quot;, &quot;state&quot;: &quot;AVAILABLE&quot;, &quot;status&quot;: &#123; &quot;error_code&quot;: &quot;OK&quot;, &quot;error_message&quot;: &quot;&quot; &#125; &#125; ]&#125; 查看模型输入输出很多时候我们需要查看模型的输出和输出参数的具体形式，TensorFlow提供了一个saved_model_cli命令来查看模型的输入和输出参数： 12345678910111213141516171819202122232425262728293031323334353637$ saved_model_cli show --dir /tmp/resnet/1538687457/ --allMetaGraphDef with tag-set: &apos;serve&apos; contains the following SignatureDefs:signature_def[&apos;predict&apos;]: The given SavedModel SignatureDef contains the following input(s): inputs[&apos;image_bytes&apos;] tensor_info: dtype: DT_STRING shape: (-1) name: input_tensor:0 The given SavedModel SignatureDef contains the following output(s): outputs[&apos;classes&apos;] tensor_info: dtype: DT_INT64 shape: (-1) name: ArgMax:0 outputs[&apos;probabilities&apos;] tensor_info: dtype: DT_FLOAT shape: (-1, 1001) name: softmax_tensor:0 Method name is: tensorflow/serving/predictsignature_def[&apos;serving_default&apos;]: The given SavedModel SignatureDef contains the following input(s): inputs[&apos;image_bytes&apos;] tensor_info: dtype: DT_STRING shape: (-1) name: input_tensor:0 The given SavedModel SignatureDef contains the following output(s): outputs[&apos;classes&apos;] tensor_info: dtype: DT_INT64 shape: (-1) name: ArgMax:0 outputs[&apos;probabilities&apos;] tensor_info: dtype: DT_FLOAT shape: (-1, 1001) name: softmax_tensor:0 Method name is: tensorflow/serving/predict 注意到signature_def，inputs的名称，类型和输出，这些参数在接下来的模型预测请求中需要。 使用模型接口预测：REST和gRPCTensorFlow Serving提供REST API和gRPC两种请求方式，接下来将具体这两种方式。 REST我们下载一个客户端脚本，这个脚本会下载一张猫的图片，同时使用这张图片来计算服务请求时间。 1$ curl -o /tmp/resnet/resnet_client.py https://raw.githubusercontent.com/tensorflow/serving/master/tensorflow_serving/example/resnet_client.py 以下脚本使用requests库来请求接口，使用图片的base64编码字符串作为请求内容，返回图片分类，并计算了平均处理时间。 123456789101112131415161718192021222324252627282930313233343536373839404142from __future__ import print_functionimport base64import requests# The server URL specifies the endpoint of your server running the ResNet# model with the name &quot;resnet&quot; and using the predict interface.SERVER_URL = &apos;http://localhost:8501/v1/models/resnet:predict&apos;# The image URL is the location of the image we should send to the serverIMAGE_URL = &apos;https://tensorflow.org/images/blogs/serving/cat.jpg&apos;def main(): # Download the image dl_request = requests.get(IMAGE_URL, stream=True) dl_request.raise_for_status() # Compose a JSON Predict request (send JPEG image in base64). jpeg_bytes = base64.b64encode(dl_request.content).decode(&apos;utf-8&apos;) predict_request = &apos;&#123;&quot;instances&quot; : [&#123;&quot;b64&quot;: &quot;%s&quot;&#125;]&#125;&apos; % jpeg_bytes # Send few requests to warm-up the model. for _ in range(3): response = requests.post(SERVER_URL, data=predict_request) response.raise_for_status() # Send few actual requests and report average latency. total_time = 0 num_requests = 10 for _ in range(num_requests): response = requests.post(SERVER_URL, data=predict_request) response.raise_for_status() total_time += response.elapsed.total_seconds() prediction = response.json()[&apos;predictions&apos;][0] print(&apos;Prediction class: &#123;&#125;, avg latency: &#123;&#125; ms&apos;.format( prediction[&apos;classes&apos;], (total_time*1000)/num_requests))if __name__ == &apos;__main__&apos;: main() 输出结果为 12$ python resnet_client.pyPrediction class: 286, avg latency: 210.12310000000002 ms gRPC让我们下载另一个客户端脚本，这个脚本使用gRPC作为服务，传入图片并获取输出结果。这个脚本需要安装tensorflow-serving-api这个库。 12$ curl -o /tmp/resnet/resnet_client_grpc.py https://raw.githubusercontent.com/tensorflow/serving/master/tensorflow_serving/example/resnet_client_grpc.py$ pip install tensorflow-serving-api 脚本内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from __future__ import print_function# This is a placeholder for a Google-internal import.import grpcimport requestsimport tensorflow as tffrom tensorflow_serving.apis import predict_pb2from tensorflow_serving.apis import prediction_service_pb2_grpc# The image URL is the location of the image we should send to the serverIMAGE_URL = &apos;https://tensorflow.org/images/blogs/serving/cat.jpg&apos;tf.app.flags.DEFINE_string(&apos;server&apos;, &apos;localhost:8500&apos;, &apos;PredictionService host:port&apos;)tf.app.flags.DEFINE_string(&apos;image&apos;, &apos;&apos;, &apos;path to image in JPEG format&apos;)FLAGS = tf.app.flags.FLAGSdef main(_): if FLAGS.image: with open(FLAGS.image, &apos;rb&apos;) as f: data = f.read() else: # Download the image since we weren&apos;t given one dl_request = requests.get(IMAGE_URL, stream=True) dl_request.raise_for_status() data = dl_request.content channel = grpc.insecure_channel(FLAGS.server) stub = prediction_service_pb2_grpc.PredictionServiceStub(channel) # Send request # See prediction_service.proto for gRPC request/response details. request = predict_pb2.PredictRequest() request.model_spec.name = &apos;resnet&apos; request.model_spec.signature_name = &apos;serving_default&apos; request.inputs[&apos;image_bytes&apos;].CopyFrom( tf.contrib.util.make_tensor_proto(data, shape=[1])) result = stub.Predict(request, 10.0) # 10 secs timeout print(result)if __name__ == &apos;__main__&apos;: tf.app.run() 输出的结果可以看到图片的分类，概率和使用的模型信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243$ python resnet_client_grpc.pyoutputs &#123; key: &quot;classes&quot; value &#123; dtype: DT_INT64 tensor_shape &#123; dim &#123; size: 1 &#125; &#125; int64_val: 286 &#125;&#125;outputs &#123; key: &quot;probabilities&quot; value &#123; dtype: DT_FLOAT tensor_shape &#123; dim &#123; size: 1 &#125; dim &#123; size: 1001 &#125; &#125; float_val: 2.4162832232832443e-06 float_val: 1.9012182974620373e-06 float_val: 2.7247710022493266e-05 float_val: 4.426385658007348e-07 ...(中间省略) float_val: 1.4636580090154894e-05 float_val: 5.812107133351674e-07 float_val: 6.599806511076167e-05 float_val: 0.0012952701654285192 &#125;&#125;model_spec &#123; name: &quot;resnet&quot; version &#123; value: 1538687457 &#125; signature_name: &quot;serving_default&quot;&#125; 性能通过编译优化的TensorFlow Serving二进制来提高性能TensorFlows serving有时会有输出如下的日志： 1Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA TensorFlow Serving已发布Docker镜像旨在尽可能多地使用CPU架构，因此省略了一些优化以最大限度地提高兼容性。如果你没有看到此消息，则你的二进制文件可能已针对你的CPU进行了优化。根据你的模型执行的操作，这些优化可能会对你的服务性能产生重大影响。幸运的是，编译优化的TensorFlow Serving二进制非常简单。官方已经提供了自动化脚本，分以下两部进行： 1234567# 1. 编译开发版本：首先，我们要构建TensorFlow服务的优化版本。最简单的方法是构建官方的Tensorflow服务开发环境Docker镜像。这具有为图像构建的系统自动生成优化的TensorFlow服务二进制文件的良好特性。为了区分我们创建的图像和官方图像，我们将$ USER /添加到镜像名称之前。让我们称这个开发镜像为$ USER / tensorflow-serving-devel$ docker build -t $USER/tensorflow-serving-devel -f Dockerfile.devel https://github.com/tensorflow/serving.git#:tensorflow_serving/tools/docker# 2. 生产新的镜像：构建TensorFlow服务开发映像可能需要一段时间，具体取决于计算机的速度。完成后，让我们使用优化的二进制文件构建一个新的服务图像，并将其命名为$ USER / tensorflow-serving：$ docker build -t $USER/tensorflow-serving --build-arg TF_SERVING_BUILD_IMAGE=$USER/tensorflow-serving-devel https://github.com/tensorflow/serving.git#:tensorflow_serving/tools/docker 现在我们有了新的服务图像，让我们再次启动服务器：: 1234$ docker kill tfserving_resnet$ docker run -p 8501:8501 --name tfserving_resnet \ --mount type=bind,source=/tmp/resnet,target=/models/resnet \ -e MODEL_NAME=resnet -t $USER/tensorflow-serving &amp; 最后运行我们的客户端程序： 12$ python /tmp/resnet/resnet_client.pyPrediction class: 282, avg latency: 84.8849 ms 在我们的机器上，我们看到使用我们的原生优化二进制文件，每次预测平均加速超过100毫秒（119％）。根据您的机器（和型号），您可能会看到不同的结果。 最后，结束TensorFlow Serving容器： 1$ docker kill tfserving_resnet 参考 Serving ML Quickly with TensorFlow Serving and Docker Train and serve a TensorFlow model with TensorFlow Serving]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>科研 - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雅虎财经API]]></title>
    <url>%2F2019%2F03%2F09%2FJava_05_%20YahooAPI%2F</url>
    <content type="text"><![CDATA[Yahoo财经频道获取实时股票数据的API。 实时数据请求请求地址1http://finance.yahoo.com/d/quotes.csv?s=&lt;股票名称&gt;&amp;f=&lt;数据列选项&gt; 参数 s — 表示股票名称，多个股票之间使用英文加号分隔，如“XOM+BBDb.TO+JNJ+MSFT”，罗列了四个公司的股票：XOM, BBDb.TO, JNJ, MSFT。 f — 表示返回数据列，如“snd1l1yr”。更详细的参见附录。 示例1http://finance.yahoo.com/d/quotes.csv?s=XOM+BBDb.TO+JNJ+MSFT&amp;f=snd1l1yr 返回： 1234&quot;XOM&quot;,&quot;Exxon Mobil Corpo&quot;,&quot;10/7/2010&quot;,63.85,2.69,12.33&quot;BBD-B.TO&quot;,&quot;BOMBARDIER INC., &quot;,&quot;10/7/2010&quot;,5.27,1.90,N/A&quot;JNJ&quot;,&quot;Johnson &amp; Johnson&quot;,&quot;10/7/2010&quot;,63.22,3.26,13.06&quot;MSFT&quot;,&quot;Microsoft Corpora&quot;,&quot;10/7/2010&quot;,24.53,2.12,11.68 历史数据请求上述是获取当前最新的数据，若需要获得历史数据，请使用下面API。 请求地址1http://ichart.yahoo.com/table.csv?s=&lt;string&gt;&amp;a=&lt;int&gt;&amp;b=&lt;int&gt;&amp;c=&lt;int&gt;&amp;d=&lt;int&gt;&amp;e=&lt;int&gt;&amp;f=&lt;int&gt;&amp;g=d&amp;ignore=.csv 参数s — 股票名称a — 起始时间，月b — 起始时间，日c — 起始时间，年d — 结束时间，月e — 结束时间，日f — 结束时间，年g — 时间周期。Example: g=w, 表示周期是‘周’。d-&gt;‘日’(day), w-&gt;‘周’(week)，m-&gt;‘月’(mouth)，v-&gt;‘dividends only’一定注意月份参数，其值比真实数据-1。如需要9月数据，则写为08。 示例查询浦发银行2010.09.25 – 2010.10.8之间日线数据 1http://ichart.yahoo.com/table.csv?s=600000.SS&amp;a=08&amp;b=25&amp;c=2010&amp;d=09&amp;e=8&amp;f=2010&amp;g=d 返回12345Date,Open,High,Low,Close,Volume,Adj Close2010-09-30,12.37,12.99,12.32,12.95,76420500,12.952010-09-29,12.20,12.69,12.12,12.48,79916400,12.482010-09-28,12.92,12.92,12.57,12.58,63988100,12.582010-09-27,13.00,13.02,12.89,12.94,43203600,12.94 深沪股票代码yahoo的api是国际性的，是支持国内沪深股市的，但代码稍微变动一下，如浦发银行的代号是：600000.SS。规则是：上海市场末尾加.ss，深圳市场末尾加.sz。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股票api接口]]></title>
    <url>%2F2019%2F03%2F09%2FJava_04_%20stockAPI%2F</url>
    <content type="text"><![CDATA[股票数据接口使用最近的作业需要用到股票数据接口，在此记录一下。 1. Tushare股票数据Tushare是一个免费、开源的python财经数据接口包。主要实现对股票等金融数据从数据采集、清洗加工 到 数据存储的过程，能够为金融分析人员提供快速、整洁、和多样的便于分析的数据，为他们在数据获取方面极大地减轻工作量，使他们更加专注于策略和模型的研究与实现上。考虑到Python pandas包在金融量化分析中体现出的优势，Tushare返回的绝大部分的数据格式都是pandas DataFrame类型，非常便于用pandas/NumPy/Matplotlib进行数据分析和可视化。 获取实时行情数据get_today_all()返回值说明： code：代码 name:名称 changepercent:涨跌幅 trade:现价 open:开盘价 high:最高价 low:最低价 settlement:昨日收盘价 volume:成交量 turnoverratio:换手率 amount:成交量 per:市盈率 pb:市净率 mktcap:总市值 nmc:流通市值 12import tushare as tsts.get_today_all() 2. 新浪股票数据接口以大秦铁路（股票代码：601006）为例，如果要获取它的最新行情，只需访问新浪的股票数据接口：http://hq.sinajs.cn/list=sh601006这个url会返回一串文本，例如：var hq_str_sh601006=”大秦铁路, 27.55, 27.25, 26.91, 27.55, 26.20, 26.91, 26.92,22114263, 589824680, 4695, 26.91, 57590, 26.90, 14700, 26.89, 14300,26.88, 15100, 26.87, 3100, 26.92, 8900, 26.93, 14230, 26.94, 25150, 26.95, 15220, 26.96, 2008-01-11, 15:05:32”;这个字符串由许多数据拼接在一起，不同含义的数据用逗号隔开了，顺序号从0开始。 0：”大秦铁路”，股票名字； 1：”27.55″，今日开盘价； 2：”27.25″，昨日收盘价； 3：”26.91″，当前价格； 4：”27.55″，今日最高价； 5：”26.20″，今日最低价； 6：”26.91″，竞买价，即“买一”报价； 7：”26.92″，竞卖价，即“卖一”报价； 8：”22114263″，成交的股票数，由于股票交易以一百股为基本单位，所以在使用时，通常把该值除以一百； 9：”589824680″，成交金额，单位为“元”，为了一目了然，通常以“万元”为成交金额的单位，所以通常把该值除以一万； 10：”4695″，“买一”申请4695股，即47手； 11：”26.91″，“买一”报价； 12：”57590″，“买二” 13：”26.90″，“买二” 14：”14700″，“买三” 15：”26.89″，“买三” 16：”14300″，“买四” 17：”26.88″，“买四” 18：”15100″，“买五” 19：”26.87″，“买五” 20：”3100″，“卖一”申报3100股，即31手； 21：”26.92″，“卖一”报价 (22, 23), (24, 25), (26,27), (28, 29)分别为“卖二”至“卖四的情况” 30：”2008-01-11″，日期； 31：”15:05:32″，时间； JavaScript应用例子:123456script type=&quot;text/javascript&quot; src=&quot;http://hq.sinajs.cn/list=sh601006&quot; charset=&quot;gb2312&quot;&gt;/script&gt; /javascript&quot;&gt; var elements=hq_str_sh601006.split(&quot;,&quot;); document.write(&quot;current price:&quot;+elements[3]); 这段代码输出大秦铁路（股票代码：601006）的当前股价 current price:14.20 如果同时查询多个股票，那么在URL最后加上一个逗号，再加上股票代码就可以了；比如你要一次查询大秦铁路（601006）和大同煤业（601001）的行情，就这样使用URL： http://hq.sinajs.cn/list=sh601003,sh601001 查询大盘指数，比如查询上证综合指数（000001）： http://hq.sinajs.cn/list=s_sh000001 服务器返回的数据为： var hq_str_s_sh000001=”上证指数,3094.668,-128.073,-3.97,436653,5458126”; 数据含义分别为：指数名称，当前点数，当前价格，涨跌率，成交量（手），成交额（万元）； 查询深圳成指数： http://hq.sinajs.cn/list=s_sz399001 股票趋势对于股票的K线图，日线图等的获取可以通过请求http://image.sinajs.cn/…./…/*.gif此URL获取，其中x代表股票代码，详见如下：分时线的查询： http://image.sinajs.cn/newchart/min/n/sh000001.gif 日K线查询： http://image.sinajs.cn/newchart/daily/n/sh000001.gif 周K线查询： http://image.sinajs.cn/newchart/weekly/n/sh000001.gif 月K线查询： http://image.sinajs.cn/newchart/monthly/n/sh000001.gif]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow savedmodel使用]]></title>
    <url>%2F2019%2F03%2F05%2Ftensor_03_savedModel%2F</url>
    <content type="text"><![CDATA[一.Saved Model模块介绍saved_model模块主要用于TensorFlow Serving。TF Serving是一个将训练好的模型部署至生产环境的系统，主要的优点在于可以保持Server端与API不变的情况下，部署新的算法或进行试验，同时还有很高的性能。 仅用Saver来保存/载入变量。这个方法显然不行，仅保存变量就必须在inference的时候重新定义Graph(定义模型)，这样不同的模型代码肯定要修改。即使同一种模型，参数变化了，也需要在代码中有所体现，至少需要一个配置文件来同步，这样就很繁琐了。 使用tf.train.import_meta_graph导入graph信息并创建Saver， 再使用Saver restore变量。相比第一种，不需要重新定义模型，但是为了从graph中找到输入输出的tensor，还是得用graph.get_tensor_by_name()来获取，也就是还需要知道在定义模型阶段所赋予这些tensor的名字。如果创建各模型的代码都是同一个人完成的，还相对好控制，强制这些输入输出的命名都一致即可。如果是不同的开发者，要在创建模型阶段就强制tensor的命名一致就比较困难了。这样就不得不再维护一个配置文件，将需要获取的tensor名称写入，然后从配置文件中读取该参数。 1.利用tf.train.Saver()保存和加载模型123456789&quot;&quot;&quot;保存模型和变量&quot;&quot;&quot;v1 = tf.Variable([0], name=&apos;v1&apos;)v2 = tf.Variable([0], name=&apos;v2&apos;)saver = tf.train.Saver() # 1. 初始化saverwith tf.Session() as sess: sess.run(tf.global_variables_initializer()) saver.save(sess, &apos;ckp&apos;) # 2. 保存模型和变量 1234&quot;&quot;&quot;恢复模型和变量&quot;&quot;&quot;with tf.Session() as sess: saver = tf.import_meta_graph(&apos;ckp.meta&apos;) # 3. 加载模型 saver.restore(sess, &apos;ckp&apos;) # 4. 加载变量 2.saved_model 保存/载入模型保存 123builder = tf.saved_model.builder.SavedModelBuilder(saved_model_dir)builder.add_meta_graph_and_variables(sess, [&apos;tag_string&apos;])builder.save() 首先构造SavedModelBuilder对象，初始化方法只需要传入用于保存模型的目录名，目录不用预先创建。 add_meta_graph_and_variables方法导入graph的信息以及变量，这个方法假设变量都已经初始化好了，对于每个SavedModelBuilder这个方法一定要执行一次用于导入第一个meta graph。 第一个参数传入当前的session，包含了graph的结构与所有变量。 第二个参数是给当前需要保存的meta graph一个标签，标签名可以自定义，在之后载入模型的时候，需要根据这个标签名去查找对应的MetaGraphDef，找不到就会报如RuntimeError: MetaGraphDef associated with tags &#39;foo&#39; could not be found in SavedModel这样的错。标签也可以选用系统定义好的参数，如tf.saved_model.tag_constants.SERVING与tf.saved_model.tag_constants.TRAINING。 save方法就是将模型序列化到指定目录底下。 保存好以后到saved_model_dir目录下，会有一个saved_model.pb文件以及variables文件夹。顾名思义，variables保存所有变量，saved_model.pb用于保存模型结构等信息。 载入 123# 使用`tf.saved_model.loader.load`方法就可以载入模型。如meta_graph_def = tf.saved_model.loader.load(sess, [&apos;tag_string&apos;], saved_model_dir) 第一个参数就是当前的session，第二个参数是在保存的时候定义的meta graph的标签，标签一致才能找到对应的meta graph。第三个参数就是模型保存的目录。 load完以后，也是从sess对应的graph中获取需要的tensor来inference。如 123456x = sess.graph.get_tensor_by_name(&apos;input_x:0&apos;)y = sess.graph.get_tensor_by_name(&apos;predict_y:0&apos;) # 实际的待inference的样本_x = ... sess.run(y, feed_dict=&#123;x: _x&#125;) 3.使用SignatureDef保存 SignatureDef定义了一些协议，对我们所需的信息进行封装，我们根据这套协议来获取信息，从而实现创建与使用模型的解耦。SignatureDef，将输入输出tensor的信息都进行了封装，并且给他们一个自定义的别名，所以在构建模型的阶段，可以随便给tensor命名，只要在保存训练好的模型的时候，在SignatureDef中给出统一的别名即可。 TensorFlow的关于这部分的例子中用到了不少signature_constants，这些constants的用处主要是提供了一个方便统一的命名。假设定义模型输入的别名为“input_x”，输出的别名为“output” ，使用SignatureDef的代码如下 123456789101112builder = tf.saved_model.builder.SavedModelBuilder(saved_model_dir)# x 为输入tensor, keep_prob为dropout的prob tensor inputs = &#123;&apos;input_x&apos;: tf.saved_model.utils.build_tensor_info(x), &apos;keep_prob&apos;: tf.saved_model.utils.build_tensor_info(keep_prob)&#125; # y 为最终需要的输出结果tensor outputs = &#123;&apos;output&apos; : tf.saved_model.utils.build_tensor_info(y)&#125; signature = tf.saved_model.signature_def_utils.build_signature_def(inputs, outputs, &apos;test_sig_name&apos;) builder.add_meta_graph_and_variables(sess, [&apos;test_saved_model&apos;], &#123;&apos;test_signature&apos;:signature&#125;)builder.save() 上述inputs增加一个keep_prob是为了说明inputs可以有多个， build_tensor_info方法将tensor相关的信息序列化为TensorInfo protocol buffer。 inputs，outputs都是dict，key是我们约定的输入输出别名，value就是对具体tensor包装得到的TensorInfo。 然后使用build_signature_def方法构建SignatureDef，第三个参数method_name暂时先随便给一个。 创建好的SignatureDef是用在add_meta_graph_and_variables的第三个参数signature_def_map中，但不是直接传入SignatureDef对象。事实上signature_def_map接收的是一个dict，key是我们自己命名的signature名称，value是SignatureDef对象。 载入 1234567891011121314151617181920## 略去构建sess的代码 signature_key = &apos;test_signature&apos;input_key = &apos;input_x&apos;output_key = &apos;output&apos; meta_graph_def = tf.saved_model.loader.load(sess, [&apos;test_saved_model&apos;], saved_model_dir)# 从meta_graph_def中取出SignatureDef对象signature = meta_graph_def.signature_def # 从signature中找出具体输入输出的tensor name x_tensor_name = signature[signature_key].inputs[input_key].namey_tensor_name = signature[signature_key].outputs[output_key].name # 获取tensor 并inferencex = sess.graph.get_tensor_by_name(x_tensor_name)y = sess.graph.get_tensor_by_name(y_tensor_name) # _x 实际输入待inference的datasess.run(y, feed_dict=&#123;x:_x&#125;) 我们只需要约定好输入输出的别名，在保存模型的时候使用这些别名创建signature，输入输出tensor的具体名称已经完全隐藏，这就实现创建模型与使用模型的解耦。]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>科研 - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static静态关键字和代码块]]></title>
    <url>%2F2019%2F02%2F20%2FJava_02_%20static%2F</url>
    <content type="text"><![CDATA[static静态关键字关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 1.静态特点A: 被static修饰的成员变量属于类，不属于这个类的某个对象。（即多个对象共享同一个static成员变量） B: 被static修饰的成员可以通过类名直接访问 访问静态成员的格式: 123类名.静态成员变量名类名.静态成员方法名(参数) C: 静态的加载优先于对象,随着类的加载而加载 2.静态注意事项A:静态成员只能直接访问静态成员 B:非静态成员既可以访问非静态成员也可以访问静态成员 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * static的注意事项： * 静态方法： * 可以调用静态的成员变量 * 可以调用静态的成员方法 * 不可以调用非静态成员变量 * 不可以调用非静态成员方法 * 静态方法只能调用静态的成员 * 非静态方法： * 可以调用静态的成员变量 * 可以调用静态的成员方法 * 可以调用非静态的成员变量 * 可以调用非静态的成员方法 * * 静态的方法中是否有this这个对象？没有 */public class StaticDemo2 &#123; public static void main(String[] args) &#123; Student.graduateFrom = "hello"; Student.study(); &#125;&#125;class Student &#123; String name; int age; static String graduateFrom;//毕业院校 public static void study() &#123; System.out.println(graduateFrom); sleep(); //System.out.println(name); //eat(); &#125; public static void sleep() &#123; System.out.println("sleep"); &#125; public void eat() &#123; System.out.println("eat"); System.out.println(graduateFrom); sleep(); &#125; &#125; 3. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 1234567891011121314151617181920212223242526272829303132333435/* * static:是一个关键字，用于修饰成员变量和成员方法 * static的特点： * 被所有的对象所共享 * 可以使用类名调用 * 静态的加载优先于对象 * 随着类的加载而加载 * */public class StaticDemo &#123; public static void main(String[] args) &#123; Person.graduateFrom = "传智学院"; Person p = new Person(); p.name = "小苍同学"; p.age = 18; //p.graduateFrom = "传智学院"; p.speak(); Person p2 = new Person(); p2.name = "小波同学"; p2.age = 20; //p2.graduateFrom = "传智学院"; p2.speak(); &#125;&#125;class Person &#123; String name; int age; static String graduateFrom;//毕业院校 public void speak() &#123; System.out.println(name + "---" + graduateFrom); &#125;&#125; 4. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // 静态方法不能是抽象方法&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // 没有创建对象，无法使用成员变量 // int b = this.y; // 静态变量不能使用this &#125;&#125; 5. 静态代码块静态代码块：定义在成员位置，使用static修饰的代码块{ }。位置：类中方法外。执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。 12345678910public class A &#123; static &#123; System.out.println("123"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; // 输出123 6. 静态内部类非静态内部类依赖于外部类的实例，而静态内部类不需要。 1234567891011121314151617public class OuterClass &#123; class InnerClass &#123; //依赖外部类的实例 &#125; static class StaticInnerClass &#123; //不依赖外部类的实例 &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 7. 静态导包在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 8.静态的优缺点A:静态优点: 对对象的共享数据提供单独空间的存储，节省空间，没有必要每一个对象都存储一份 可以直接被类名调用,不用在堆内存创建对象 静态成员可以通过类名直接访问,相对创建对象访问成员方便 B:静态弊端: 访问出现局限性。（静态虽好，但只能访问静态） 9.初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 1public static String staticField = "静态变量"; 123static &#123; System.out.println("静态语句块");&#125; 1public String field = "实例变量"; 123&#123; System.out.println("普通语句块");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 10. 静态原理图解static 修饰的内容： 是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static静态关键字和代码块]]></title>
    <url>%2F2019%2F02%2F20%2FJava_02_%20static%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[static静态关键字1.静态特点A: 被static修饰的成员变量属于类，不属于这个类的某个对象。（即多个对象共享同一个static成员变量） B: 被static修饰的成员可以通过类名直接访问 访问静态成员的格式: 123类名.静态成员变量名类名.静态成员方法名(参数) C: 静态的加载优先于对象,随着类的加载而加载 2.静态注意事项A:静态成员只能直接访问静态成员 B:非静态成员既可以访问非静态成员也可以访问静态成员 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * static的注意事项： * 静态方法： * 可以调用静态的成员变量 * 可以调用静态的成员方法 * 不可以调用非静态成员变量 * 不可以调用非静态成员方法 * 静态方法只能调用静态的成员 * 非静态方法： * 可以调用静态的成员变量 * 可以调用静态的成员方法 * 可以调用非静态的成员变量 * 可以调用非静态的成员方法 * * 静态的方法中是否有this这个对象？没有 */public class StaticDemo2 &#123; public static void main(String[] args) &#123; Student.graduateFrom = "传智学院"; Student.study(); &#125;&#125;class Student &#123; String name; int age; static String graduateFrom;//毕业院校 public static void study() &#123; ///System.out.println(graduateFrom); //sleep(); //System.out.println(name); //eat(); &#125; public static void sleep() &#123; System.out.println("sleep"); &#125; public void eat() &#123; System.out.println("eat"); System.out.println(graduateFrom); sleep(); &#125; &#125; 3. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 1234567891011121314151617181920212223242526272829303132333435/* * static:是一个关键字，用于修饰成员变量和成员方法 * static的特点： * 被所有的对象所共享 * 可以使用类名调用 * 静态的加载优先于对象 * 随着类的加载而加载 * */public class StaticDemo &#123; public static void main(String[] args) &#123; Person.graduateFrom = "传智学院"; Person p = new Person(); p.name = "小苍同学"; p.age = 18; //p.graduateFrom = "传智学院"; p.speak(); Person p2 = new Person(); p2.name = "小波同学"; p2.age = 20; //p2.graduateFrom = "传智学院"; p2.speak(); &#125;&#125;class Person &#123; String name; int age; static String graduateFrom;//毕业院校 public void speak() &#123; System.out.println(name + "---" + graduateFrom); &#125;&#125; 4. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // 静态方法不能是抽象方法&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // 没有创建对象，无法使用成员变量 // int b = this.y; // 静态变量不能使用this &#125;&#125; 5. 静态代码块静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println("123"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; // 输出123 6. 静态内部类非静态内部类依赖于外部类的实例，而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 7. 静态导包在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 8.静态的优缺点A:静态优点: 对对象的共享数据提供单独空间的存储，节省空间，没有必要每一个对象都存储一份 可以直接被类名调用,不用在堆内存创建对象 静态成员可以通过类名直接访问,相对创建对象访问成员方便 B:静态弊端: 访问出现局限性。（静态虽好，但只能访问静态） 9.初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 1public static String staticField = "静态变量"; 123static &#123; System.out.println("静态语句块");&#125; 1public String field = "实例变量"; 123&#123; System.out.println("普通语句块");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static静态关键字和代码块]]></title>
    <url>%2F2019%2F02%2F20%2FJava_03_%20%E4%BB%A3%E7%A0%81%E5%9D%97%20%2F</url>
    <content type="text"><![CDATA[static静态关键字1.静态特点A: 被static修饰的成员变量属于类，不属于这个类的某个对象。（即多个对象共享同一个static成员变量） B: 被static修饰的成员可以通过类名直接访问 访问静态成员的格式: 123类名.静态成员变量名类名.静态成员方法名(参数) C: 静态的加载优先于对象,随着类的加载而加载 2.静态注意事项A:静态成员只能直接访问静态成员 B:非静态成员既可以访问非静态成员也可以访问静态成员 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * static的注意事项： * 静态方法： * 可以调用静态的成员变量 * 可以调用静态的成员方法 * 不可以调用非静态成员变量 * 不可以调用非静态成员方法 * 静态方法只能调用静态的成员 * 非静态方法： * 可以调用静态的成员变量 * 可以调用静态的成员方法 * 可以调用非静态的成员变量 * 可以调用非静态的成员方法 * * 静态的方法中是否有this这个对象？没有 */public class StaticDemo2 &#123; public static void main(String[] args) &#123; Student.graduateFrom = "传智学院"; Student.study(); &#125;&#125;class Student &#123; String name; int age; static String graduateFrom;//毕业院校 public static void study() &#123; ///System.out.println(graduateFrom); //sleep(); //System.out.println(name); //eat(); &#125; public static void sleep() &#123; System.out.println("sleep"); &#125; public void eat() &#123; System.out.println("eat"); System.out.println(graduateFrom); sleep(); &#125; &#125; 3. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 1234567891011121314151617181920212223242526272829303132333435/* * static:是一个关键字，用于修饰成员变量和成员方法 * static的特点： * 被所有的对象所共享 * 可以使用类名调用 * 静态的加载优先于对象 * 随着类的加载而加载 * */public class StaticDemo &#123; public static void main(String[] args) &#123; Person.graduateFrom = "传智学院"; Person p = new Person(); p.name = "小苍同学"; p.age = 18; //p.graduateFrom = "传智学院"; p.speak(); Person p2 = new Person(); p2.name = "小波同学"; p2.age = 20; //p2.graduateFrom = "传智学院"; p2.speak(); &#125;&#125;class Person &#123; String name; int age; static String graduateFrom;//毕业院校 public void speak() &#123; System.out.println(name + "---" + graduateFrom); &#125;&#125; 4. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // 静态方法不能是抽象方法&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // 没有创建对象，无法使用成员变量 // int b = this.y; // 静态变量不能使用this &#125;&#125; 5. 静态代码块静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println("123"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; // 输出123 6. 静态内部类非静态内部类依赖于外部类的实例，而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 7. 静态导包在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 8.静态的优缺点A:静态优点: 对对象的共享数据提供单独空间的存储，节省空间，没有必要每一个对象都存储一份 可以直接被类名调用,不用在堆内存创建对象 静态成员可以通过类名直接访问,相对创建对象访问成员方便 B:静态弊端: 访问出现局限性。（静态虽好，但只能访问静态） 9.初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 1public static String staticField = "静态变量"; 123static &#123; System.out.println("静态语句块");&#125; 1public String field = "实例变量"; 123&#123; System.out.println("普通语句块");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员代码面试指南]]></title>
    <url>%2F2019%2F02%2F18%2FReviewGuide_01_getMin%2F</url>
    <content type="text"><![CDATA[《程序员代码面试指南 IT名企算法与数据结构题目最优解》题解1.题目01 2.题解思路 方法一： 如原书思路，设置两个栈stackData和stackMin，当前数据为data，先压入stackData，然后判断stackMin是否为空。 如果为空，data压入stackMin中，如果不空，则比较data和stackMin栈顶元素。如果data小则入栈，否则stackMin的栈顶元素重复入栈。如图： 方法二： 只用一个栈实现，在栈的类中添加返回最小值的方法。使用ArrayList来存储栈内元素，然后便利ArrayList返回栈中最小值。 3.代码实现方法一： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ITexercise;import java.util.ArrayList;public class MyStack &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); MyStack stack =new MyStack(); stack.push(array,1); stack.push(array, 2); stack.push(array, 5); stack.push(array, 6); printStack(array); System.out.println(&quot;--------------&quot;); stack.pop(array); printStack(array); System.out.println(&quot;--------------&quot;); System.out.println(stack.getMin(array)); &#125; public static void printStack(ArrayList&lt;Integer&gt; array) &#123; for (int i = 0; i &lt; array.size(); i++) &#123; System.out.print(array.get(i)+&quot;\t&quot;); &#125; &#125; public static boolean pop(ArrayList&lt;Integer&gt; array) &#123; if (array.size() == 0) &#123; return false; &#125; else &#123; array.remove(array.size() - 1); return true; &#125; &#125; public static boolean push(ArrayList&lt;Integer&gt; array, int data) &#123; array.add(data); return true; &#125; public static int getMin(ArrayList&lt;Integer&gt; array) &#123; int min = array.get(0); for (int i = 0; i &lt; array.size(); i++) &#123; if (array.get(i) &lt; min) &#123; min = array.get(i); &#125; &#125; return min; &#125;&#125; 方法二： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ITexercise;import java.util.Stack;import javax.management.RuntimeErrorException;public class MyStack2 &#123; private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; public MyStack2() &#123; this.stackData =new Stack&lt;Integer&gt;(); this.stackMin = new Stack&lt;Integer&gt;(); &#125; public void push(int data) &#123; if(this.stackMin.isEmpty()) &#123; this.stackMin.push(data); &#125; else if (data &lt; this.stackMin.pop()) &#123; this.stackMin.push(data); &#125; else &#123; this.stackMin.push(this.stackMin.pop()); &#125; stackData.push(data); &#125; public int pop() &#123; if(this.stackData.isEmpty()) &#123; throw new RuntimeException(&quot;stack is empty&quot;); &#125; else &#123; this.stackMin.pop(); return this.stackData.pop(); &#125; &#125; public int getMin() &#123; if(this.stackData.isEmpty()) &#123; throw new RuntimeException(&quot;stack is empty&quot;); &#125; return this.stackMin.peek(); &#125; &#125; 4.分析方法一时间复杂度为O（1），空间复杂度为O（n） 方法二getMin（）时间复杂度为O（n），空间复杂度为O（n）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java - 面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse常用操作]]></title>
    <url>%2F2019%2F02%2F17%2Fjava_01_Eclipse%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Eclipse常用操作1.Eclipse基本操作选择工作空间 工作空间 其实就是我们写的源代码所在的目录 用Eclipse来完成一个HelloWorld案例 A:创建Java项目：点击File或者在最左侧空白处，选择Java项目，在界面中写一个项目名称，然后Finish即可。 B:创建包：展开项目，在源包src下建立一个包com.itheima C:创建类：在com.ithiema包下建立一个类HelloWorld在界面中写一个类名：HelloWorld，然后finish即可。 D:编写代码：在HelloWorld类写main方法，在main方法中写一条输出语句。 E:编译：自动编译，在保存的那一刻帮你做好了 F:运行 选择要运行的文件或者在要运行的文件内容中，右键 – Run as - Java Application即可 2.Eclipse工作空间的基本配置A:行号的显示和隐藏 ​ 显示：在代码区域的最左边的空白区域，右键 – Show Line Numbers即可。 ​ 隐藏：把上面的动作再做一次。 B:字体大小及颜色 ​ a:Java代码区域的字体大小和颜色： window – Preferences – General – Appearance – Colors And Fonts – Java – Java Edit Text Font ​ b:控制台 window – Preferences – General – Appearance – Colors And Fonts – Debug – Console font ​ c:其他文件 window – Preferences – General – Appearance – Colors And Fonts – Basic – Text Font C:窗体给弄乱了，怎么办? ​ window – Perspective – Reset Perspective D:控制台找不到了，怎么办? ​ Window–Show View—Console 3.常用辅助键和快捷键内容辅助键 alt+/ main 然后alt+/ syso 然后alt+/ 快捷键 注释 单行 选中内容，ctrl+/, 再来一次取消 多行 选中内容，ctrl+shift+/, ctrl+shift+\ 格式化 ctrl+shift+f 4.项目删除、导入A:删除项目 ​ 选中项目 – 右键 – 删除 ​ 从项目区域中删除 ​ 从硬盘上删除 B:导入项目 ​ 在项目区域右键找到import ​ 找到General，展开，并找到 ​ Existing Projects into Workspace ​ 点击next,然后选择你要导入的项目 ​ 注意：这里选择的是项目名称]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow内核学习]]></title>
    <url>%2F2019%2F01%2F16%2Ftensor_02_serving%2F</url>
    <content type="text"><![CDATA[一.TF serving实现 TF serving托管模型流程包括4个步骤：训练模型，导出模型，发布模型，更新线上模型服务。 TF serving官方文档 1.ServablesServables 是 TensorFlow Serving 中最核心的抽象，是服务器端提供计算和查询服务的的实例对象。Servables 的大小和力度是灵活的，单个 Servable 可能包含从一个查找表的单个分片，到一个单独的模型，或是推理模型的元组。一套TF serving支持同时运行多个服务。 Servables 并不管理自身的生命周期。 典型的 Servables 包括： 一个 TensorFlow 的 SavedModelBundle (tensorflow::Session) 一个用于 Embedding 的查找表或词汇表 Servables Streams 一个 Servables Stream 是多个版本的 Servable 的序列，其按照版本号的递增排序。 2.ModelsTensorFlow Serving 将一个 模型 (model) 表示为一个或多个 Servables。一个机器学习模型可能包括一个或多个算法 (包括学习到的权重) 和查找表。 可以将一个 复合模型 (composite model) 表示成如下形式： 多个独立的 Servables 一个组合的 Servables 一个 Servable 也可能是一个模型的一部分，例如，一个大的查找表可能被分割到多个不同的 TensorFlow Serving 实例中。 3.LoadersLoaders 管理一个 Servable 的生命周期。Loaders 将一个 Servable 的加载和卸载的 API 进行了标准化，并且提供评估系统资源是否足够加载Servable的接口。 4.SourcesSources 是数据处理器抽象，负责监控和处理Servable加载的数据，比如文件系统指定路径下的查找表文件或模型文件。TensorFlow Serving 中 Sources 的接口可以从任意的存储系统中发现 Servables，TesorFlow Serving 包含了 Source 实现的通用引用。例如：Sources 可以利用 RPC 等机制，并可以轮训文件系统。Sources 可以维护多个 Servables 或 不同版本分片中的状态，这将有助于 Servables 在不同版本之间进行 Delta (diff) 更新。 5.ManagersManagers 维护 Servables 的整个生命周期，包括： 加载 Servables 为 Servables 提供服务 卸载 Servables Managers 从 Sources 获取信息并跟踪所有的 Versions。Manager 尽可能的满足 Sources 的请求，但当所需的资源不存在时，会拒绝载入一个 Aspired Versions。Manager 也可能延迟触发一个卸载 (unload)，例如：基于要确保任意时点都要至少有一个 Version 被加载的策略，Manager 需要等待一个新的 Version 完成加载后再卸载之前的 Version。 6.SavedModel是TF模型持久化存储的通用序列化格式，是打通从模型训练到服务发布流程的关键。在训练阶段，我们可能使用输入流水线和超参数优化操作。当模型发布为服务时，需要删除或替换这些操作，否则会出现推理准确率低，输入队列阻塞的情况。 为了提升服务发布后的准确率或其他评价指标，我们需要保存多分不同的数据流图进行测试。SavedModel支持用一份saved_model.pb文件来保存多幅不同的数据流图，这些数据流图可以共享模型参数和资源。 7.ServableHandle是响应gPRC客户端访问请求的服务句柄，ServableHandle与已加载的Servable一一对应。客户端请求TF serving服务时，服务端ServableHandle会调用相应的Servable服务接口，并将相应返回给客户端。如果服务尚未加载，则向客户端返回错误信息。 8.Batchbatch文档 将多个请求批处理为单个请求可以显著降低推理的成本，特别是在有 GPU 等加速器的情况下。TensorFlow Serving 包含了一个用于批处理请求的小工具，它允许客户端可以轻松的将请求中特定类型的推断合成一个批处理请求，以便系统能够更有效的处理。 在提供TensorFlow模型时，将单个模型推理请求一起批处理对于性能非常重要。特别是，批处理对于解锁GPU等硬件加速器所承诺的高吞吐量是必要的。这是一个用于批处理请求和调度批处理的库。该库本身并不依赖于GPU，并且可以用于串联处理小任务组的任何情况。 它提供了特定的TensorFlow会话API，以及可用于在其他粒度批处理的低级API。 该库目前分为:（1）core / kernels / batching_util（核心API和实现）（2）tensorflow_serving / batching（更高级别和实验代码）。 BatchingSessionBatchingSession将批处理添加到标准tensorflow :: Session，并允许您使用单个（非批处理）张量调用Session :: Run（），同时获得批量处理“隐藏”的好处。请求线程使得在等待其他组调用阻塞的Session :: Run（），调用进入同一个批处理。要使用此同步API实现良好的吞吐量，建议将客户端线程数设置为最大批量大小的两倍。 使用BatchingSession的最简单方法是通过CreateRetryingBasicBatchingSession（），它使用下面的BasicBatchSchedule提供了一个tensorflow :: Session对象，并且还处理溢出调度程序队列的重试请求。 Batch大小可以设置为1-1024。 BasicBatchSchedulerBasicBatchScheduler是一个比BatchingSession更低级的抽象，它与张量/ TensorFlow本身无关。它适用于处理同类请求的服务器。BasicBatchScheduler提供了一个异步API，称为BatchScheduler，该API由BatchTask类进行模板化，该类封装了要批处理的工作单元。 非阻塞Schedule（）方法用于将任务排入队列以进行处理。 准备好处理一批任务后，将在单独的线程上调用回调来处理批处理 Mixed CPU/GPU/IO Workloads除了主要的GPU工作之外，一些模型还执行非常重要的CPU工作。虽然核心矩阵操作可以在GPU上良好运行，但是外围操作可以在CPU上进行，例如，嵌入查找，词汇查找，量化/反量化。根据GPU的管理方式，将整个CPU和GPU步骤序列作为一个单元进行批处理可能无法充分利用GPU。 可以在请求线程中执行非GPU预处理和后处理，批处理调度程序仅用于工作的GPU部分。 或者，非GPU工作可以在批处理线程中完成，在批处理调度程序调用的回调中。要允许回调在完全形成批处理之前对任务执行非批处理工作，可以使用StreamingBatchScheduler。它专为非常精确控制延迟的服务器而设计，需要对流水线的每个阶段进行精细控制。 如果调度程序当前没有处理能力，StreamingBatchScheduler将拒绝任务。如果要自动重试因此原因而被拒绝的任务，可以在批处理调度程序之上对BatchSchedulerRetrier进行分层。有一个便利功能，用于创建与调度程序相结合的流调度程序：CreateRetryingStreamingBatchScheduler（）。 将模型推理逻辑拆分为多个不同阶段以优化延迟或利用率时，请记住，对于给定请求，每个阶段都应使用相同版本的模型。确保此属性的一个好方法是协调跨线程在每个阶段使用哪个ServableHandle对象。 最后，I / O密集的推理阶段，例如查找磁盘或远程服务器可能会受益于批处理以隐藏其延迟。您可以使用两个批处理调度程序实例：一个用于批处理这些查找，另一个用于批处理GPU工作。 二. TF serving流程1.训练和导出模型TF服务器端组件只负责模型服务的发布和更新，模型导出由TF原生的tensorflow.saved_model.builder.SavedModelBuilder模块实现。SavedModelBuilder定期向文件系统中的目标路径导出模型快照，模型快照的格式为SavedModel序列化格式。对于 SavedModel 格式的详细信息，参见 SavedModel REAMDE.md 文档，如下代码片段说明了将模型保存至硬盘的一般流程。 12345678910111213141516export_path_base = sys.argv[-1]export_path = os.path.join( compat.as_bytes(export_path_base), compat.as_bytes(str(FLAGS.model_version)))print &apos;Exporting trained model to&apos;, export_pathbuilder = tf.saved_model.builder.SavedModelBuilder(export_path)builder.add_meta_graph_and_variables( sess, [tag_constants.SERVING], signature_def_map=&#123; &apos;predict_images&apos;: prediction_signature, signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: classification_signature, &#125;, main_op=main_op)builder.save() 每个版本子目录中包含如下文件： saved_model.pb 是序列化的 tensorflow::SavedModel 文件。其包含一个或多个计算图的定义，同时也包含模型的一些元信息，例如 Signatures。 variables 为一系列包含了计算图中的变量的序列化文件。 谷歌推荐的保存模型的方式是保存模型为 PB 文件，它具有语言独立性，可独立运行，封闭的序列化格式，任何语言都可以解析它，它允许其他语言和深度学习框架读取、继续训练和迁移 TensorFlow 的模型。它的主要使用场景是实现创建模型与使用模型的解耦， 使得前向推导 inference的代码统一。另外的好处是保存为 PB 文件时候，模型的变量都会变成固定的，导致模型的大小会大大减小，适合在手机端运行。 2.定义模型服务的参数和配置使用SavedModelBuilder导出模型分为以下3步： 构造SavedModelBuilder实例，并设置模型的导出路径 定义模型服务的SignatureDef 使用SavedModelBuilder实例导出模型 创建SavedModelBuilder实例后，调用它的add_meta_graph_and_variables成员方法，添加期望导出的数据流图和模型参数。add_meta_graph_and_variables发放的主要输入参数包括： sess 为包含需要导出的训练好的模型的 TensorFlow 会话。 tags 数据流图的类型标签，可以选的取值包括SERVING，TRAINING和GPU。分别表示该数据流图用于提供服务，训练模型，以及使用GPU设备。 signature_def_map 指定了用于添加到 Meta Graph 中的从用户提供的键到 tensorflow::SignatureDef 之间的映射。Signature 指定了导出模型的类型，以及在进行推理阶段所绑定的输入和输出张量。 predict_signature签名配置（包括回归，分类，推理）作为一个 predict_signature 定义的示例，工具函数接受如下参数： inputs={&#39;images&#39;: tensor_info_x} 指定输入张量的信息。 outputs={&#39;scores&#39;: tensor_info_y} 指定输出评分张量的信息。 method_name 表示用于推理的方法。对于预测请求，其应被设置为 tensorflow/serving/predict，对于其他方法名称，参见 TensorFlow API 文档。 3.Serving with Docker using GPU（1）Install nvidia-docker (下载)Before serving with a GPU, in addition to installing Docker, you will need: Up-to-date NVIDIA drivers for your system nvidia-docker: You can follow the installation instructions here （2）Running a GPU serving imageRunning a GPU serving image is identical to running a CPU image. For more details, see running a serving image. （3）Serving GPU docker image1docker pull tensorflow/serving:latest-gpu （4）指定GPU Docker加载模型12345docker run --runtime=nvidia -p 8501:8501 \ --mount type=bind,\ source=/home/asphel/Desktop/models/official/resnet/savedmodel,\ target=/models/resnet \ -e MODEL_NAME=resnet -t tensorflow/serving:latest-gpu &amp; （5）服务运行在指定端口，通过网络请求调用服务122019-01-11 00:07:20.773693: I tensorflow_serving/model_servers/main.cc:333]Exporting HTTP/REST API at:localhost:8501 ... 发送请求，调用服务 12$ curl -d '&#123;"instances": [1.0, 2.0, 5.0]&#125;' \ -X POST http://localhost:8501/v1/models/resnet 三.实验实验环境core i3 4核心 3.1GHZ GTX 1050 4G显存 内存 4GB 测量参数1.CPU利用率，CPU负载 2.内存占用 3.GPU显存占用，GPU利用率 1. 多用户依次请求10000个用户请求陆续到达，服务器依次响应每个用户请求。 用户请求相同每次用户请求的模型和输入数据都相同 用户请求不同每次用户请求的模型和输入数据都相同 2. 多用户按批次请求10000个用户请求按批次加载到服务器，服务器按批次执行用户请求。 Batching can be turned on by providing proper SessionBundleConfig when creating the SavedModelBundleSourceAdapter. In this case we set the BatchingParameters with pretty much default values. Batching can be fine-tuned by setting custom timeout, batch_size, etc. values. For details, please refer to BatchingParameters. 12345678910SessionBundleConfig session_bundle_config;// Batching configif (enable_batching) &#123; BatchingParameters* batching_parameters = session_bundle_config.mutable_batching_parameters(); batching_parameters-&gt;mutable_thread_pool_name()-&gt;set_value( &quot;model_server_batch_threads&quot;);&#125;*saved_model_bundle_source_adapter_config.mutable_legacy_config() = session_bundle_config; 在到达完整批处理时，推理请求在内部合并为单个大请求（张量），并调用tensorflow :: Session :: Run（）（这是GPU上实际效率增益的来源） 3.模型训练（对比）10000个epochs训练过程 四.模型分析模型分析方法 1. 神经网络显存占用神经网络模型占用的显存包括： 模型自身的参数 模型的输出 举例来说，对于如下图所示的一个全连接网络(不考虑偏置项b) 模型的显存占用包括： 参数：二维数组 W模型的输出： 二维数组 Y输入X可以看成是上一层的输出，因此把它的显存占用归于上一层。 1.2 参数的显存占用只有有参数的层，才会有显存占用。这部份的显存占用和输入无关，模型加载完成之后就会占用。 有参数的层主要包括： 卷积 全连接 BatchNorm Embedding层 … … 无参数的层： 多数的激活层(Sigmoid/ReLU) 池化层 Dropout … … 更具体的来说，模型的参数数目(这里均不考虑偏置项b)为： Linear(M-&gt;N): 参数数目：M×N Conv2d(Cin, Cout, K): 参数数目：Cin × Cout × K × K BatchNorm(N): 参数数目： 2N Embedding(N,W): 参数数目： N × W 参数占用显存 = 参数数目×n n = 4 ：float32 n = 2 : float16 n = 8 : double64 在PyTorch中，当你执行完model=MyGreatModel().cuda()之后就会占用相应的显存，占用的显存大小基本与上述分析的显存差不多（会稍大一些，因为其它开销）。 1.3 梯度与动量的显存占用举例来说， 优化器如果是SGD： 可以看出来，除了保存W之外还要保存对应的梯度 ，因此显存占用等于参数占用的显存x2, 如果是带Momentum-SGD 这时候还需要保存动量， 因此显存x3 如果是Adam优化器，动量占用的显存更多，显存x4 总结一下，模型中与输入无关的显存占用包括： 参数 W 梯度 dW（一般与参数一样） 优化器的动量（普通SGD没有动量，momentum-SGD动量与梯度一样，Adam优化器动量的数量是梯度的两倍） 1.4 输入输出的显存占用这部份的显存主要看输出的feature map 的形状。 feature map 比如卷积的输入输出满足以下关系： 据此可以计算出每一层输出的Tensor的形状，然后就能计算出相应的显存占用。 模型输出的显存占用，总结如下： 需要计算每一层的feature map的形状（多维数组的形状） 需要保存输出对应的梯度用以反向传播（链式法则） 显存占用与 batch size 成正比 模型输出不需要存储相应的动量信息。 深度学习中神经网络的显存占用，我们可以得到如下公式： 1显存占用 = 模型显存占用 + batch_size × 每个样本的显存占用 可以看出显存不是和batch-size简单的成正比，尤其是模型自身比较复杂的情况下：比如全连接很大，Embedding层很大 另外需要注意： 输入（数据，图片）一般不需要计算梯度 神经网络的每一层输入输出都需要保存下来，用来反向传播，但是在某些特殊的情况下，我们可以不要保存输入。比如ReLU，在PyTorch中，使用nn.ReLU(inplace = True) 能将激活函数ReLU的输出直接覆盖保存于模型的输入之中，节省不少显存。]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>科研 - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux性能监测工具（深度学习资源监控）]]></title>
    <url>%2F2019%2F01%2F12%2FLinux_07_%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[Linux性能监测工具相关链接：Linux 如何查看 CPU 利用率？ 1.toptop 命令会显示 Linux 的进程。它提供了一个运行中系统的实时动态视图，即实际的进程活动。默认情况下，它显示在服务器上运行的 CPU 占用率最高的任务，并且每五秒更新一次。 top 的常用快捷键常用快捷键列表： （2）htop - 交互式的进程查看器htop 命令详解 htop 是一款免费并开源的基于 ncurses 的 Linux 进程查看器。它比 top 命令更简单易用。您无需使用 PID、无需离开 htop 界面，便可以杀掉进程或调整其调度优先级。 1$ htop 输出示例： htop输出到文件先安装 aha 和 html2text 。 1echo q | htop -C | aha --line-fix | html2text -width 999 | grep -v &quot;F1Help&quot; | grep -v &quot;xml version=&quot; &gt; file.txt 2.mpstat - 监控多处理器的使用情况mpstat 命令显示每个可用处理器的使用情况，编号从 0 开始。命令 mpstat -P ALL 显示了每个处理器的平均使用率： 1# mpstat -P ALL 输出示例： 12345678Linux 2.6.18-128.1.14.el5 (www03.nixcraft.in) 06/26/201806:48:11 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s06:48:11 PM all 3.50 0.09 0.34 0.03 0.01 0.17 0.00 95.86 1218.0406:48:11 PM 0 3.44 0.08 0.31 0.02 0.00 0.12 0.00 96.04 1000.3106:48:11 PM 1 3.10 0.08 0.32 0.09 0.02 0.11 0.00 96.28 34.9306:48:11 PM 2 4.16 0.11 0.36 0.02 0.00 0.11 0.00 95.25 0.0006:48:11 PM 3 3.77 0.11 0.38 0.03 0.01 0.24 0.00 95.46 44.80 3. Sysstat Package相关链接：利用Ksar分析系统瓶颈 中文教程 sar 命令用用收集、报告、或者保存 UNIX / Linux 系统的活动信息： CPU 使用率 内存页面和使用率 网络 I/O 和传输统计 进程创建活动 所有的块设备活动 每秒中断数等等 sar 命令的输出能够用于识别服务器瓶颈。但是，分析 sar 命令提供的信息可能比较困难，所以要使用 kSar 工具。kSar 工具可以将 sar 命令的输出绘制成基于时间周期的、易于理解的图表。 sar、sa1、和 sa2 命令都是 sysstat 包的一部分。它是 Linux 包含的性能监视工具集合。 sar：显示数据 sa1 和 sa2：收集和保存数据用于以后分析。sa2 shell 脚本在 /var/log/sa 目录中每日写入一个报告。sa1 shell 脚本将每日的系统活动信息以二进制数据的形式写入到文件中。 sadc —— 系统活动数据收集器。可以通过修改sa1和sa2脚本去配置各种选项。它们位于以下的目录： /usr/lib64/sa/sa1 （64 位）或者 /usr/lib/sa/sa1 （32 位） —— 它调用 sadc 去记录报告到 /var/log/sa/sadX 格式。 /usr/lib64/sa/sa2 （64 位）或者 /usr/lib/sa/sa2 （32 位） —— 它调用 sar 去记录报告到 /var/log/sa/sarX 格式。 4.KDE 系统监控器 - 实时系统报告和图形化显示 KSysguard 手册 KSysguard 是 KDE 桌面的网络化系统监控程序。这个工具可以通过 ssh 会话运行。它提供了许多功能，比如可以监控本地和远程主机的客户端-服务器模式。前端图形界面使用传感器来检索信息。传感器可以返回简单的值或更复杂的信息，如表格。每种类型的信息都有一个或多个显示界面，并被组织成工作表的形式，这些工作表可以分别保存和加载。所以，KSysguard 不仅是一个简单的任务管理器，还是一个控制大型服务器平台的强大工具。 5. Holy LanceHoly Lance 是一个简单易用的 基于 PHP]的 Linux 图形化性能监视器。 基于PHP，单文件，易于部署。Web界面，动态更新，实时简便，即开即用。目前可以动态监控CPU占用率、内存、磁盘、网络、进程，还带有环境探针以及性能测试功能。 6. GPU监控nvidia-smi文档 nvidia-smi是Nvidia显卡命令行管理套件，基于NVML库，旨在管理和监控Nvidia GPU设备。 这是nvidia-smi命令的输出，其中最重要的两个指标： 显存占用 GPU利用率 显存占用和GPU利用率是两个不一样的东西，显卡是由GPU计算单元和显存等组成的，显存和GPU的关系有点类似于内存和CPU的关系。 （1）编写脚本 monitor.sh12watch -n2.0 nvidia-smi \--query-gpu=index,timestamp,name,temperature.gpu,utilization.gpu,utilization.memory,memory.total,memory.free,memory.used --format=csv watch命令是为命令行输出设计的工具，其结果包含很多不可打印的字符，所以可以的解决方法有两个 把输出结果的语句写到command里面比如监控GPU的显存变化并写入日志 1watch -n 3 &apos;nvidia-smi -q -d MEMORY|tee -a gpu.log&apos; 写脚本 12345while &lt;some condition&gt;do &lt;mycommand&gt; 2&gt;&amp;1 | tee -a /path/to/logfile sleep 60done （2）gpustatgpustat文档 pip install gpustat即可安装，gpustat基于nvidia-smi，可以提供更美观简洁的展示，结合watch命令，可以动态实时监控GPU的使用情况。 1watch --color -n1 gpustat -cpu （3）Glances官方文档 glances 工具可以在用户的终端上实时显示重要的系统信息，并动态地对其进行更新。这个高效的工具可以工作于任何终端屏幕。glances 工具还可以将相同的数据捕获到一个文件，便于以后对报告进行分析和绘制图形。 1glances --export csv --export-csv-file ./glances.csv]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Deep Learning - 学习 - 科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习GPU监控]]></title>
    <url>%2F2019%2F01%2F12%2FLinux_08_GPU%E7%9B%91%E6%8E%A7%20%2F</url>
    <content type="text"><![CDATA[GPU监测工具在进行深度学习实验时，GPU 的实时状态监测很重要。nvidia-smi 是最常用的命令。 上图是服务器上 GeForce GTX 1080 Ti 的信息，下面一一解读参数。上面的表格中的红框中的信息与下面的四个框的信息是一一对应的： GPU：GPU 编号；Name：GPU 型号；Persistence-M：持续模式的状态。持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态；Fan：风扇转速，从0到100%之间变动；Temp：温度，单位是摄氏度；Perf：性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能（即 GPU 未工作时为P0，达到最大工作限度时为P12）。Pwr:Usage/Cap：能耗；Memory Usage：显存使用率；Bus-Id：涉及GPU总线的东西，domain bus:device.function；Disp.A：Display Active，表示GPU的显示是否初始化；Volatile GPU-Util：浮动的GPU利用率；Uncorr. ECC：Error Correcting Code，错误检查与纠正；Compute M：compute mode，计算模式。下方的 Processes 表示每个进程对 GPU 的显存使用率。 第二个命令：nvidia-smi -L该命令用于列出所有可用的 NVIDIA 设备信息。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Deep Learning - 学习 - 科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux远程管理]]></title>
    <url>%2F2019%2F01%2F10%2FLinux_06_%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[远程管理常用命令目录 关机/重启 shutdown 查看或配置网卡信息 ifconfig ping 远程登录和复制文件 ssh scp 01. 关机/重启 序号 命令 含义 作用 01 shutdown 选项 时间 shutdown 关机／重新启动 1.1 shutdown shutdown 命令可以 安全 关闭 或者 重新启动系统| 选项 | 含义 || – | —— || -r | 重新启动 | 提示： 不指定选项和参数，默认表示 1 分钟之后 关闭电脑 远程维护服务器时，最好不要关闭系统，而应该重新启动系统 常用命令示例 1234567891011121314# 重新启动操作系统，其中 now 表示现在$ shutdown -r now# 立刻关机，其中 now 表示现在$ shutdown now# 系统在今天的 20:25 会关机$ shutdown 20:25# 系统再过十分钟后自动关机$ shutdown +10# 取消之前指定的关机计划$ shutdown -c 2.1 网卡 和 IP 地址网卡 网卡是一个专门负责网络通讯的硬件设备 IP 地址是设置在网卡上的地址信息 我们可以把 电脑 比作 电话，网卡 相当于 SIM 卡，IP 地址 相当于 电话号码 IP 地址 每台联网的电脑上都有 IP 地址，是保证电脑之间正常通讯的重要设置 注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯 2.2 ifconfig ifconfig 可以查看／配置计算机当前的网卡配置信息 12345# 查看网卡配置信息$ ifconfig# 查看网卡对应的 IP 地址$ ifconfig | grep inet 提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示 127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常 2.3 ping12345# 检测到目标主机是否连接正常$ ping IP地址# 检测本地网卡工作正常$ ping 127.0.0.1 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅，数值越大，速度越慢 ping 的工作原理与潜水艇的声纳相似，ping 这个命令就是取自 声纳的声音 网络管理员之间也常将 ping 用作动词 —— ping 一下计算机X，看他是否开着 原理：网络上的机器都有 唯一确定的 IP 地址，我们给目标 IP 地址发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在 提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 CTRL + C 03. 远程登录和复制文件 序号 命令 对应英文 作用 01 ssh 用户名@ip secure shell 关机／重新启动 02 scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径 secure copy 远程复制文件 3.1 ssh 基础（重点）在 Linux 中 SSH 是 非常常用 的工具，通过 SSH 客户端 我们可以连接到运行了 SSH 服务器 的远程机器上 SSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序 1SSH 是目前较可靠， 专为远程登录会话和其他网络服务 提供安全性的协议 利用 SSH 协议 可以有效防止远程管理过程中的信息泄露 通过 SSH 协议 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗 SSH 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度 1) 域名 和 端口号域名 由一串 用点分隔 的名字组成，例如：www.itcast.cn 是 IP 地址 的别名，方便用户记忆 端口号 IP 地址：通过 IP 地址 找到网络上的 计算机 端口号：通过 端口号 可以找到 计算机上运行的应用程序 SSH 服务器 的默认端口号是 22，如果是默认端口号，在连接的时候，可以省略 常见服务端口号列表： 序号 服务 端口号 01 SSH 服务器 22 02 Web 服务器 80 03 HTTPS 443 04 FTP 服务器 21 提示：有关 端口号的详细内容，在就业班会详细讲解！ 2) SSH 客户端的简单使用1ssh [-p port] user@remote user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名 port 是 SSH Server 监听的端口，如果不指定，就为默认值 22 提示： 使用 exit 退出当前用户的登录 注意： ssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY 或者 XShell 客户端软件即可 提示： 在工作中，SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器 3) Windows 下 SSH 客户端的安装 Putty http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html XShell http://xshellcn.com 建议从官方网站下载正式的安装程序 3.2 scp（掌握） scp 就是 secure copy，是一个在 Linux 下用来进行 远程拷贝文件 的命令 它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的 12345678910111213# 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo 选项 含义 -r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口 注意： scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY，使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输 FileZilla 官方网站：https://www.filezilla.cn/download/client FileZilla 在传输文件时，使用的是 FTP 服务 而不是 SSH 服务，因此端口号应该设置为 21 3.3 SSH 高级（知道） 免密码登录 配置别名 提示：有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下 1）免密码登录步骤 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥 非对称加密算法 使用 公钥 加密的数据，需要使用 私钥 解密 使用 私钥 加密的数据，需要使用 公钥 解密 2) 配置别名每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆 而 配置别名 可以让我们进一步偷懒，譬如用：ssh mac 来替代上面这么一长串，那么就在 ~/.ssh/config 里面追加以下内容： 1234Host mac HostName ip地址 User itheima Port 22 保存之后，即可用 ssh mac 实现远程登录了，scp 同样可以使用]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Taskonomy Disentangling Task Transfer Learning]]></title>
    <url>%2F2019%2F01%2F01%2Fpaper_02_Tasknomy%2F</url>
    <content type="text"><![CDATA[Taskonomy: Disentangling Task Transfer Learning摘要这篇论文是计算机视觉顶会 CVPR 2018 最佳论文奖的文章：Taskonomy: Disentangling Task Transfer Learning。文章作者团队来自斯坦福大学和加州大学伯克利分校。文章的主题是探索任务迁移学习，通过做大量的实验，来揭示任务迁移学习中的一些现象。 人类的视觉具备多种多样的能力，计算机视觉届基于此定义了许多不同的视觉任务。长远来看，计算机视觉着眼于解决大多数甚至所有视觉任务，但现有方法大多尝试将视觉任务逐一击破。这种方法造成了两个问题：第一， 逐一击破需要为每一项任务收集大量数据，随着任务数量的增多，这将会是不可行的；第二，逐一击破会带来不同任务之间的冗余计算和重复学习。总的来说，逐一击破的策略忽略了视觉任务之间的关联性，比如法线 (Surface Normals) 是由深度 (Depth) 求导得来，语义分割 (Semantic Segmentation) 又似乎和遮挡边缘测试 (Occlusion edge detection) 有着千丝万缕的关联。基于上述两个问题，我们希望能有效测量并利用视觉任务之间的关联来避免重复学习，从而用更少的数据学习我们感兴趣的一组任务。 Taskonomy是一项量化不同视觉任务之间关联、并利用这些关联来最优化学习策略的研究。如果两个视觉任务A、B具有关联性，那么在任务A中习得的representations理应可为解决任务B提供有效的统计信息 。由此我们通过迁移学习计算了26个不同视觉任务之间的一阶以及高阶关联。如图一，如果有预测法线的网络和预测遮挡边缘测试的网络，我们可以通过结合两个网络的representations来快速通过少量数据解决Reshading和点匹配 (Point matching)。基于这些关联，我们利用0-1整数规划 (Binary Integer Programming) 求得一组我们感兴趣的任务，如何去最优分配训练数据量。 比如，如果想最高效地解决10个问题，利用Taskonomy提供的学习策略可以减少2/3的训练数据量。 正文文章的方法概括起来就叫做 Taskonomy (Task taxonomy)，这是一个计算图，它定义了任务之间的可迁移性。图中的节点表示任务，节点之间的边就表示迁移性，边的权重表示从一个任务迁移到另一个任务的可能表现。这个方法是文章的核心。它一共由下图所示的 4 个步骤构成。这 4 个步骤从逻辑上非常好理解。首先我们要对不同任务进行建模，然后让它们两两之间进行迁移并获取迁移的表现。接着为了构建一个统一的字典，我们对这些迁移结果进行归一化。最后，我们构建可迁移图。在迁移实验开始前，最重要的是，需要一个可用的超大型数据集，要包含不同的任务。然而目前没有。怎么办？很简单，作者构建了一个！这个数据集有从 600 个建筑物内拍摄的 400 万张图片。每张图片都针对不同的任务做了标注，也就是说都适用于每个任务。 1.问题定义首先，定义要解决的问题。我们想在有限的监督预算 下最大化在一组目标任务 上的表现。同时，我们有一组起始任务 ，其定义为我们可从零学习的任务。监督预算 的定义为多少起始任务我们愿意从零开始学习（从零开始学习需要收集大量数据，监督预算表达了我们所面对的金钱、计算力和时间上的限制）。那么， 代表了我们感兴趣但不能从零学习的任务，比如一个只能有少量数据的任务。 代表了我们不感兴趣但可以从零学习（来帮助我们更好的学习 ）的任务，如jigsaw、colorization等自我监督的视觉任务。 代表了我们感兴趣也能从零学习的任务，但因为从零学习会消耗监督预算，我们希望从中选择出符合预算的一组从零学习，余下的通过少量数据的迁移学习来实现。我们称 为我们的任务词典 (task dictionary)。最后，我们对视觉任务 的定义为一个基于图片的方程 。 如下图所示，收集了一个有四百万张图片的数据，每张图片均有26个不同视觉任务的标注(ground truth)。这26个任务涵盖了2D的、3D的和语义的任务，构成了本项research的任务词典。因为这26个任务均有标答， 也为这26个任务。 下面，进入第一大阶段，量化视觉任务的关联。 2.第一步：从零学习对于每个起始任务, 我们为其从零开始学习一个神经网络。为了能更好地控制变量从而比较任务关联，每个任务的神经网络具有相似的encoder decoder结构。所有的encoder都是相同的类ResNet 50结构。因为每个任务的output维度各不相同，decoder的结构对不同的任务各不相同，但都只有几层，远小于encoder的大小。 3.第二步：迁移学习如上图所示，对于一个起始任务 和一个目标任务 ，我们将以 的representation作为输入来学习 。我们将freeze任务 的encoder 参数，并基于encoder的输出 (representations) 学习一个浅层神经网络read out function。严谨来讲，如果我们用 表示 的encoder， 表示 的标注， 表示 的loss函数， 来表示图片和迁移训练集， 表示要迁移学习的浅层神经网络，学习目标为： 对于所有 和 组合，我们均训练了一个 。如下图所示，对于 ，不同的 会对 的表现造成不同的影响。更具关联的 会为 提供更有效的统计信息，从而仅用1/60的训练数据（相较于从零学习）就能取得不错的结果；相反不具备关联的 则并不能有此表现。因此，我们认为 在 任务中的表现可以很好地代表了 之于 的关联性。 上述迁移代表了任务之间一对一的关联，我们称其为一阶关联。如下图，几个任务之间可能具有互补性，结合几个起始任务的representations会对解决目标任务起到帮助。因此，我们也研究了任务之间多对一的关联，我们称其问高阶关联。在这种情况下，我们将几个起始任务的representation结合起来当作目标任务的输入，其余细节跟上段类似。 因为高阶的任务组合数量太大，我们基于一阶表现选择了一部分的组合进行迁移学习。对于小于五阶的高阶，我们根据一阶的表现，将前五的所有组合作为输入。对于n&gt;5阶，我们选择结合一阶表现前n的起始任务作为输入。 4.第三步：任务相似性标准化这一步的目标很明确，就是构建一个迁移学习的相似度矩阵，从中我们可以很清楚地知道哪两个任务迁移效果最好。如何构建？我们本能地想到，可以把上一步中训练的损失函数拿来用。然而，不同任务下的损失函数不具有可比性，因此不能用。自然地，我们又想到了归一化，把所有的结果归一化到 [0,1] 之间。这也是通常用的办法。但是问题又来了，通常来说，神经网络的损失函数具有很大的震荡幅度，直接拿来用是不可行的。 作者提出了一种基于序列的方法，使得训练的表现和损失函数的值呈正相关。对于目标任务 t，用矩阵 Wt来表示可迁移到 t 的源域任务的表现。矩阵中的元素 wij 就表示：在同一个分出来的测试集上，源域 si 迁移到 t，比 sj 迁移到 t 的表现好的百分比。比如 s1 到 t 要比 s2 到 t 好 15%。这个矩阵表示的是两两之间的比较，因此作者形象地把它叫做 tournament matrix（锦标赛矩阵）。 最后作者对得到的新矩阵进行了特征分解，则 si 到 t 的迁移表现就是第 i 个特征向量。把所有目标域 t 的特征向量组合起来就得到了一个相似度矩阵。这个矩阵是归一化过的。 这个方法不是作者发明的，是之前有人发明的，叫做 Analytic Hierarchy Process。 5.第四步：计算可迁移图最后一步，我们要基于affinity matrix求得如何最有效地学习一组我们感兴趣的任务。我们可以这个问题想象成一个subgraph selection的问题：选择一些任务从零学习，剩下的任务用少量数据进行迁移学习，具体迁移学习的策略由subgraph中的edge来决定（对一条directed edge，起始点代表我们从零学习的一个任务，终点代表要进行迁移的目标任务）。基于此，我们可以通过解如下BIP最优化问题来得到最优解： 这个最优问题有三个限制条件： 如果我们选择了一个迁移，那么迁移的起始任务（可能为高阶起始集）和目标任务均要出现在subgraph中； 每个目标任务有且仅有一个迁移（我们将从零学习在途中定义为从自己到自己的迁移，即一条自己到自己的edge）； 不超过监督预算。 结论实验部分是本文的重点。作者收集的数据集共包含 26 个计算机视觉的通用任务。在这些任务上，作者进行源领域训练、单一迁移、高阶迁移，一共构建了大约 3000 个学习任务，一共需要47886 个 GPU 小时来进行计算。 实验所用的所有编码器都是相同的，都基于 ResNet-50，去掉了 pooling 层。所有的迁移网络用的都是包含 2 个卷积的网络。损失函数和解码器就相应地根据不同任务进行调整。调整方式可见文章。 作者在一部分数据上进行实验，把这部分数据进行了如下的划分：训练集 120k，验证集 16k，测试集 17k。主要进行了以下方面的实验： 目标网络的性能 作者首先比较了不迁移情况下，目标网络的性能，也就是方法部分中的第 1 步。对比两个最近的方法可以看出，文章的网络性能不错。 领域相似度情况 作者验证了根据构建出的相似度矩阵进行相似度挖掘的实验，对不同的任务都画出了迁移性能图。从图中就可以清楚地知道哪些任务是对目标任务的迁移效果好坏。 作者又进一步对这些结果进行了更好的图示。 新任务上的泛化能力 将一个任务作为目标任务，其他 25 个任务作为源领域任务，考察模型在新任务上的泛化能力。实现效果显示这种迁移会比当前一些最好的非迁移深度方法还要好。从中我们得出的结论是，如果能够选择好源域任务，那么通常来说迁移学习的表现都要比直接从目标领域训练要好。 模型的扩展性 另外，作者还在 MIT Place 和 ImageNet 两个大型图像数据集上测试了方法的可扩展性。并且根据迁移效果，构建了迁移树用于进一步分析迁移表现。 局限性作者还在文章花费很多篇幅讨论了自己方法的局限性。主要有以下几点： 方法可能依赖于特定的数据和模型：尽管作者在不同的大型数据集上做了大量实验，作者依然担心，方法可能会依赖于特定的数据和网络。这么实诚的人不多了。 任务的通用性：作者只是在一些认为定义的任务上进行了实验。但有没有可能有更复杂更高级的任务？ 任务空间限制：可能还需要更多的实验。迁移到非视觉和机器人任务。这是一个值得考虑的问题。 终身学习：此方法目前还是离线的。如何实现在线终身学习？ 总结本文最大的亮点是，构建了非常多的迁移学习任务，详尽地探索了不同任务之间进行迁移的效果，为以后的研究提供了宝贵的基础。方法比较朴素，但是实现完备，很值得我们学习。作者在探索之外，还专门提供了一个数据集，这种精神值得钦佩！我们在今后的研究中，也要学习这种实验精神，多做，少说，慢慢积累。 迁移到非视觉和机器人任务。这是一个值得考虑的问题。 终身学习。此方法目前还是离线的。如何实现在线终身学习？ 参考文献 Zamir A R, Sax A, Shen W, et al. Taskonomy: Disentangling Task Transfer Learning[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018: 3712-3722.]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>深度学习任务调度 - 论文阅读 - 科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件目录常用命令]]></title>
    <url>%2F2018%2F12%2F25%2FLinux_05_%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文件和目录常用命令 目标 查看目录内容ls切换目录cd创建和删除操作touchrmmkdir拷贝和移动文件cpmv查看文件内容catmoregrep其他echo重定向 &gt; 和 &gt;&gt;管道 | 01. 查看目录内容 1.1 终端实用技巧 1&gt; 自动补全 在敲出 文件／目录／命令 的前几个字母之后，按下 tab 键如果输入的没有歧义，系统会自动补全如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 2&gt; 曾经使用过的命令 按 上／下 光标键可以在曾经使用过的命令之间来回切换如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c 1.2 ls 命令说明 ls 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 DOS 下的 dir 命令 Linux 下文件和目录的特点 Linux 文件 或者 目录 名称最长可以有 256 个字符以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示. 代表当前目录.. 代表上一级目录 1.3 ls 常用选项 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 计算机中文件大小的表示方式（科普） 单位 英文 含义 字节 B（Byte） 在计算机中作为一个数字单元，一般为 8 位二进制数 千 K（Kibibyte） 1 KB = 1024 B，千字节 （1024 = 2 ** 10） 兆 M（Mebibyte） 1 MB = 1024 KB，百万字节 千兆 G（Gigabyte） 1 GB = 1024 MB，十亿字节，千兆字节 太 T（Terabyte） 1 TB = 1024 GB，万亿字节，太字节 拍 P（Petabyte） 1 PB = 1024 TB，千万亿字节，拍字节 艾 E（Exabyte） 1 EB = 1024 PB，百亿亿字节，艾字节 泽 Z（Zettabyte） 1 ZB = 1024 EB，十万亿亿字节，泽字节 尧 Y（Yottabyte） 1 YB = 1024 ZB，一亿亿亿字节，尧字节 1.4 ls 通配符的使用 通配符 含义 * 代表任意个数个字符 ? 代表任意一个字符，至少 1 个 [] 表示可以匹配字符组中的任一一个 [abc] 匹配 a、b、c 中的任意一个 [a-f] 匹配从 a 到 f 范围内的的任意一个字符 02. 切换目录 2.1 cd cd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一 注意：Linux 所有的 目录 和 文件名 都是大小写敏感的 命令 含义 cd 切换到当前用户的主目录(/home/用户目录) cd ~ 切换到当前用户的主目录(/home/用户目录) cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 2.2 相对路径和绝对路径 相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录 所在的目录位置绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 根目录/家目录 开始的具体目录位置 03. 创建和删除操作 3.1 touch 创建文件或修改文件时间如果文件 不存在，可以创建一个空白文件如果文件 已经存在，可以修改文件的末次修改日期 3.2 mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 3.3 rm 删除文件或目录 使用 rm 命令要小心，因为文件删除后不能恢复 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹 时必须加此参数 04. 拷贝和移动文件 序号 命令 对应英文 作用 01 tree [目录名] tree 以树状图列出文件目录结构 02 cp 源文件 目标文件 copy 复制文件或者目录 03 mv 源文件 目标文件 move 移动文件或者目录／文件或者目录重命名 4.1 tree tree 命令可以以树状图列出文件目录结构 选项 含义 -d 只显示目录 4.2 cp cp 命令的功能是将给出的 文件 或 目录 复制到另一个 文件 或 目录 中，相当于 DOS 下的 copy 命令 选项 含义 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 4.3 mv mv 命令可以用来 移动 文件 或 目录，也可以给 文件或目录重命名 选项 含义 -i 覆盖文件前提示 05. 查看文件内容 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 02 more 文件名 more 分屏显示文件内容 03 grep 搜索文本 文件名 grep 搜索文本文件内容 5.1 cat cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能cat 会一次显示所有的内容，适合 查看内容较少 的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 Linux 中还有一个 nl 的命令和 cat -b 的效果等价 5.2 more more 命令可以用于分屏显示文件内容，每次只显示一页内容适合于 查看内容较多的文本文件 使用 more 的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 5.3 grep Linux 系统中 grep 命令是一种强大的文本搜索工具grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解 选项 含义 -n 显示匹配行及行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 常用的两种模式查找 参数 含义 ^a 行首，搜寻以 a 开头的行 ke$ 行尾，搜寻以 ke 结束的行 06. 其他 6.1 echo 文字内容 echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用 6.2 重定向 &gt; 和 &gt;&gt; Linux 允许将命令执行结果 重定向到一个 文件将本应显示在终端上的内容 输出／追加 到指定文件中 其中 &gt; 表示输出，会覆盖文件原有的内容&gt;&gt; 表示追加，会将内容追加到已有文件的末尾 6.3 管道 | Linux 允许将 一个命令的输出 可以通过管道 做为 另一个命令的输入可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读） 常用的管道命令有： more：分屏显示内容grep：在命令执行结果的基础上查询指定的文本]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令格式]]></title>
    <url>%2F2018%2F12%2F24%2FLinux_04_linux%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[@media print{ .hljs{overflow: visible; word-wrap: break-word !important;} } Linux命令格式 01. 终端命令格式 command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单词的缩写[-options]：选项，可用来对命令进行控制，也可以省略parameter：传给命令的参数，可以是 零个、一个 或者 多个 [] 代表可选 02. 查阅命令帮助信息提示现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助 网络搜索2.1 –helpcommand –help说明：显示 command 命令的帮助信息2.2 manman command说明：查阅 command 命令的使用手册man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明 使用 man 时的操作键： 操作键功能空格键显示手册页的下一屏Enter 键一次滚动手册页的一行b回滚一屏f前滚一屏q退出/word搜索 word 字符串]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask生成 secret key]]></title>
    <url>%2F2018%2F12%2F24%2Fpython_05_flaskerror%2F</url>
    <content type="text"><![CDATA[Flask SECRET_KEY报错在flask项目中，Session, Cookies以及一些第三方扩展都会用到SECRET_KEY值，这是一个比较重要的配置值。 在使用flask时，产生了这个错误： 1RuntimeError: The session is unavailable because no secret key was set. Set the secret_key on the application to something unique and secret. 解决方法是在flask项目文件_inti__.py加入设置SECRET_KEY。 123456app = Flask(__name__) app.config[&apos;SECRET_KEY&apos;] = &apos;123456&apos; # or app.secret_key = &apos;123456&apos; # or app.config.update(SECRET_KEY=&apos;123456&apos;) 如果需要设置一个随机的SECRET_KEY值。我们可以使用os模块的urandom函数来获得随机值: 123&gt;&gt;&gt; import os &gt;&gt;&gt; os.urandom(24) &apos;\xeew\xe4\xc0\xee\xb1]\x9b\xa0\x9e)\x15Qhem\xe5\xf17\xd6\xceB\xb7\xb4&apos;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数进阶]]></title>
    <url>%2F2018%2F12%2F24%2Fpython_04_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[函数进阶目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数 01. 函数参数和返回值的作用函数根据 有没有参数 以及 有没有返回值，可以 相互组合，一共有 4 种 组合形式 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！ 如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 1.1 无参数，无返回值此类函数，不接收参数，也没有返回值，应用场景如下： 只是单纯地做一件事情，例如 显示菜单 在函数内部 针对全局变量进行操作，例如：新建名片，最终结果 记录在全局变量 中 注意： 如果全局变量的数据类型是一个 可变类型，在函数内部可以使用 方法 修改全局变量的内容 —— 变量的引用不会改变 在函数内部，使用赋值语句 才会 修改变量的引用 1.2 无参数，有返回值此类函数，不接收参数，但是有返回值，应用场景如下： 采集数据，例如 温度计，返回结果就是当前的温度，而不需要传递任何的参数 1.3 有参数，无返回值此类函数，接收参数，没有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据 例如 名片管理系统 针对 找到的名片 做 修改、删除 操作 1.4 有参数，有返回值此类函数，接收参数，同时有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据，并且 返回期望的处理结果 例如 名片管理系统 使用 字典默认值 和 提示信息 提示用户输入内容 如果输入，返回输入内容 如果没有输入，返回字典默认值 02. 函数的返回值 进阶 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 问题：一个函数执行后能否返回多个结果？ 示例 —— 温度和湿度测量 假设要开发一个函数能够同时返回当前的温度和湿度 先完成返回温度的功能如下： 1234567891011def measure(): """返回当前的温度""" print("开始测量...") temp = 39 print("测量结束...") return tempresult = measure()print(result) 在利用 元组 在返回温度的同时，也能够返回 湿度 改造如下： 123456789def measure(): """返回当前的温度""" print("开始测量...") temp = 39 wetness = 10 print("测量结束...") return (temp, wetness) 提示：如果一个函数返回的是元组，括号可以省略 技巧 在 Python 中，可以 将一个元组 使用 赋值语句 同时赋值给 多个变量 注意：变量的数量需要和元组中的元素数量保持一致 1result = temp, wetness = measure() 面试题 —— 交换两个数字题目要求 有两个整数变量 a = 6, b = 100 不使用其他变量，交换两个变量的值 解法 1 —— 使用其他变量1234# 解法 1 - 使用临时变量c = bb = aa = c 解法 2 —— 不使用临时变量1234# 解法 2 - 不使用临时变量a = a + bb = a - ba = a - b 解法 3 —— Python 专有，利用元组1a, b = b, a 03. 函数的参数 进阶3.1. 不可变和可变的参数 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！ 无论传递的参数是 可变 还是 不可变 只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用 12345678910111213141516171819def demo(num, num_list): print("函数内部") # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print("函数代码完成")gl_num = 99gl_list = [4, 5, 6]demo(gl_num, gl_list)print(gl_num)print(gl_list) 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据 12345678910def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list)gl_list = [6, 7, 8]mutable(gl_list)print(gl_list) 面试题 —— += 在 python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 1234567891011121314151617181920def demo(num, num_list): print("函数内部代码") # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print("函数代码完成")gl_num = 9gl_list = [1, 2, 3]demo(gl_num, gl_list)print(gl_num)print(gl_list) 3.2 缺省参数 定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 例如：对列表排序的方法 123456789gl_num_list = [6, 3, 9]# 默认就是升序排序，因为这种应用需求更多gl_num_list.sort()print(gl_num_list)# 只有当需要降序排序时，才需要传递 `reverse` 参数gl_num_list.sort(reverse=True)print(gl_num_list) 指定函数的缺省参数 在参数后使用赋值语句，可以指定参数的缺省值 1234567def print_info(name, gender=True): gender_text = "男生" if not gender: gender_text = "女生" print("%s 是 %s" % (name, gender_text)) 提示 缺省参数，需要使用 最常见的值 作为默认值！ 如果一个参数的值 不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ 缺省参数的注意事项1) 缺省参数的定义位置 必须保证 带有默认值的缺省参数 在参数列表末尾 所以，以下定义是错误的！ 1def print_info(name, gender=True, title): 2) 调用带有多个缺省参数的函数 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ 1234567891011121314151617181920def print_info(name, title="", gender=True): """ :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 """ gender_text = "男生" if not gender: gender_text = "女生" print("%s%s 是 %s" % (title, name, gender_text))# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！print_info("小明")print_info("老王", title="班长")print_info("小美", gender=False) 3.3 多值参数（知道）定义支持多值参数的函数 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组 参数名前增加 两个 * 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * args 是 arguments 的缩写，有变量的含义 kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数 12345678def demo(num, *args, **kwargs): print(num) print(args) print(kwargs)demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True) 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码 多值参数案例 —— 计算任意多个数字的和需求 定义一个函数 sum_numbers，可以接收的 任意多个整数 功能要求：将传递的 所有数字累加 并且返回累加结果 12345678910def sum_numbers(*args): num = 0 # 遍历 args 元组顺序求和 for n in args: num += n return numprint(sum_numbers(1, 2, 3)) 元组和字典的拆包（知道） 在调用带有多值参数的函数时，如果希望： 将一个 元组变量，直接传递给 args 将一个 字典变量，直接传递给 kwargs 就可以使用 拆包，简化参数的传递，拆包 的方式是： 在 元组变量前，增加 一个 * 在 字典变量前，增加 两个 * 12345678910111213def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;"name": "小明", "age": 18&#125;# 会把 num_tuple 和 xiaoming 作为元组传递个 args# demo(gl_nums, gl_xiaoming)demo(*gl_nums, **gl_xiaoming) 04. 函数的递归 函数调用自身的 编程技巧 称为递归 4.1 递归函数的特点特点 一个函数 内部 调用自己 函数内部可以调用其他函数，当然在函数内部也可以调用自己 代码特点 函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同 当 参数满足一个条件 时，函数不再执行 这个非常重要，通常被称为递归的出口，否则 会出现死循环！ 示例代码 1234567891011def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return sum_numbers(num - 1) sum_numbers(3) 4.2 递归案例 —— 计算数字累加需求 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + … num 的结果 123456789101112def sum_numbers(num): if num == 1: return 1 # 假设 sum_numbers 能够完成 num - 1 的累加 temp = sum_numbers(num - 1) # 函数内部的核心算法就是 两个数字的相加 return num + tempprint(sum_numbers(2)) 递归在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python金融量化]]></title>
    <url>%2F2018%2F12%2F21%2Fpython_03_%E9%87%91%E8%9E%8D%E9%87%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[量化策略1.量化策略通过一套固定的逻辑来分析，判断和决策，自动化地进行股票交易。 2.核心内容 选股 择时 仓位管理 止盈止损 3.策略的周期 产生想法/学习知识 实现策略：Python 检验策略：回测/模拟交易 实盘交易 优化策略 123456789101112131415161718graph TB 行情数据--&gt;选股 止盈止损--&gt;买入信号 subgraph 输出 买入信号---卖出信号 卖出信号---交易费用 交易费用---收益 end subgraph 策略 选股--&gt;择时 择时--&gt;仓位管理 仓位管理--&gt;止盈止损 end subgraph 输入 行情数据---财务数据 财务数据---自定义数据 自定义数据---投资经验 end 量化投资与Python 常用分析工具 Excel，SAS/SPSS，R语言 量化投资第三方模块 NumPy：数值计算 Pandas：数据分析 Matplotlib：图表绘制 使用Python进行量化投资 自己编写 在线平台：聚宽，优矿，米筐，Quantopian 开源框架：RQAlpha，QUANTAXIS NumPyNumPy是Python中科学计算的基础软件包。它是一个提供多了维数组对象，多种派生对象（如：掩码数组、矩阵）以及用于快速操作数组的函数及API，它包括数学、逻辑、数组形状变换、排序、选择、I/O 、离散傅立叶变换、基本线性代数、基本统计运算、随机模拟等等。 NumPy包的核心是ndarray对象。 NumPy数组 和 标准Python Array（数组） 之间有几个重要的区别： NumPy数组在创建时具有固定的大小，与Python的原生数组对象（可以动态增长）不同。 更改ndarray的大小将创建一个新数组并删除原来的数组。 NumPy数组中的元素都需要具有相同的数据类型，因此在内存中的大小相同。 例外情况：Python的原生数组里包含了NumPy的对象的时候，这种情况下就允许不同大小元素的数组。 NumPy数组有助于对大量数据进行高级数学和其他类型的操作。 通常，这些操作的执行效率更高，比使用Python原生数组的代码更少。 越来越多的基于Python的科学和数学软件包使用NumPy数组; 虽然这些工具通常都支持Python的原生数组作为参数，但它们在处理之前会还是会将输入的数组转换为NumPy的数组，而且也通常输出为NumPy数组。 换句话说，为了高效地使用当今科学/数学基于Python的工具（大部分的科学计算工具），你只知道如何使用Python的原生数组类型是不够的 - 还需要知道如何使用NumPy数组。 NumPy 中的数组NumPy提供的最重要的数据结构是一个称为NumPy数组的强大对象。 123456import numpy as npimport sysmy_array = np.array(range(100))my_list = list(range(100))print (sys.getsizeof(my_array))print (sys.getsizeof(my_list)) 切片操作1234my_array = np.array([[4, 5], [6, 1]])print my_array[0][1]my_array_column_2 = my_array[:, 1] #取第二列print my_array_column_2]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux Shebang符号]]></title>
    <url>%2F2018%2F12%2F19%2FLinux_03_shebang%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[LINUX Shebang 符号(#!) #!这个符号叫做 Shebang 或者 Sha-bang Shebang 通常在 Unix 系统脚本的中 第一行开头 使用 指明 执行这个脚本文件 的 解释程序 使用 Shebang 的步骤 使用 which 查询 python3 解释器所在路径 1$ which python3 修改要运行的 主 python 文件，在第一行增加以下内容 1#! /usr/bin/python3 修改 主 python 文件 的文件权限，增加执行权限 1$ chmod +x cards_main.py 在需要时执行程序即可 1./cards_main.py]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统目录]]></title>
    <url>%2F2018%2F12%2F19%2Flinux_02_%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Linux系统目录1. 单用户操作系统和多用户操作系统 单用户操作系统：指一台计算机在同一时间 只能由一个用户 使用，一个用户独自享用系统的全部硬件和软件资源 Windows XP 之前的版本都是单用户操作系统 多用户操作系统：指一台计算机在同一时间可以由 多个用户 使用，多个用户共同享用系统的全部硬件和软件资源 Unix 和 Linux 的设计初衷就是多用户操作系统 2. Windows和 Linux文件系统区别2.1 Windows下的文件系统 在 Windows 下，打开 “计算机”，我们看到的是一个个的驱动器盘符： 每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形： 2.2 Linux 下的文件系统 在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）： Ubuntu 没有盘符这个概念，只有一个根目录 /，所有文件都在它下面 2.3 用户目录位于 /home/user，称之为用户工作目录或家目录，表示方式： 12/home/user~ 2.4 Linux 主要目录速查表 /：根目录，一般根目录下只存放目录，在 linux 下有且只有一个根目录，所有的东西都是从这里开始 当在终端里输入 /home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 home 目录 /bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等 /boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab /etc/fstab /etc/init.d /etc/X11 /etc/sysconfig /etc/xinetd.d /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 ~ 表示当前用户的家目录 ~edu 表示用户 edu 的家目录 /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载 /opt：给主机额外安装软件所摆放的目录 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等 /root：系统管理员root的家目录 /sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能”查看”而不能设置和使用 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内 /usr：应用程序存放目录 /usr/bin：存放应用程序 /usr/share：存放共享数据 /usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local：存放软件升级包 /usr/share/doc：系统说明文件存放目录 /usr/share/man：程序说明文件存放目录 /var：放置系统执行过程中经常变化的文件 /var/log：随时更改的日志文件 /var/spool/mail：邮件存放的目录 /var/run：程序或服务启动后，其 PID 存放在该目录下]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题美化]]></title>
    <url>%2F2018%2F12%2F19%2Fhexo%2F</url>
    <content type="text"><![CDATA[Hexo Next主题美化Hexo支持很多自定义主题和插件，本人使用的是Next主题，也涉及很多美化，为此记录一下。 添加页脚访客人数和总访问量使用的是不蒜子来进行统计,不蒜子是一款记录访客和访问量的插件. 1.安装脚本要使用不蒜子必须在页面中引入busuanzi.js，在themes/next/layout/_partial/footer.swig中添加脚本，代码如下 1&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2.安装标签要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 3.安装步骤一般显示站点访问量在页脚，所以在footer.swig中添加标签，在themes/next/_config.yml中加入以下配置： 12# visitors count counter: true 在themes/next/layout/_partial/footer.swig中添加以下代码： 123456&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;&#123;% endif %&#125; 这样便可以在底部显示访问量了。之后使用hexo clean清空缓存，使用hexo generate重新生成站点文件，使用hexo deploy部署，就能看到效果了。 设置Menu菜单栏会显示可以跳转的页面。 如果还要添加，编辑themes/next/_config.yml： 12345678menu: home: / || home //首页 about: /about/ || user //关于 tags: /tags/ || tags //标签 categories: /categories/ || th //分类 archives: /archives/ || archive //归档 schedule: /schedule/ || calendar //日程表 sitemap: /sitemap.xml || sitemap //站点地图 将需要的Menu前面#号去掉。 设置动态背景主题配置文件中找到canvas_nest，设置成ture 12# Canvas-nestcanvas_nest: ture 修改底部标签样式 修改Blog\themes\next\layout\_macro\post.swig中文件，搜索rel=&quot;tag&quot;&gt;#，将#替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。 侧边栏社交图标设置 打开主题配置文件_config.yml，搜索Social，社交账号前面的#号去掉。 12345678910111213#social: GitHub: https://github.com/yourname || github 简书: https://www.jianshu.com/u/63445e24e8bf || heartbeat 掘金: https://juejin.im/user/5a371ae551882512d0607108 || spinner #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 添加网页顶部进度加载条 编辑主题配置文件，搜索pace，将其值改为ture就可以了，选择一款你喜欢的样式。 12345678910111213141516171819# Progress bar in the top during page loading.pace: ture# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 添加点击爱心效果 在/themes/next/source/js/src下新建文件 clicklove.js ，接着把代码拷贝粘贴到 clicklove.js 文件中。 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\next\layout\_layout.swig文件末尾添加： 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 背景图片设置打开theme/next/source/css/_custom/custom.styl，添加以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Custom styles.//背景图片相关@media screen and (min-width:1200px) &#123; body &#123; background-image:url(/images/bg1.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover &#125; #footer a &#123; color:#eee; &#125; //改变背景色和透明度 .main-inner &#123; background: #fff; opacity: 0.9; &#125; // 文章标题动态效果 .posts-expand .post-title-link::before &#123; background-image: linear-gradient(90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%); &#125; code &#123; color: #ff7600; background: #fbf7f8; margin: 2px; &#125; // 大代码块的自定义样式 .highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px; &#125; .highlight, code, pre &#123; border: 1px solid #d6d6d6; &#125;&#125; .site-title &#123; font-size: 24px; font-weight: 400; font-family: &apos;Damion&apos;,&quot;PingFang SC&quot;,&quot;Microsoft YaHei&quot;,sans-serif; &#125; // 自定义页脚跳动的心样式@keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 168);&#125; 文章添加阴影、透明效果123456789// 主页文章添加阴影效果.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; background:rgba(255,255,255,0.9) none repeat scroll !important; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 文章末尾添加版权声明查找主题配置文件themes/next/_config.yml中的creative_commons 12345creative_commons: license: by-nc-sa sidebar: false post: true # 将false改为true即可显示版权信息 language: 文字背景以及半透明的设置打开theme/next/source/css/_custom/custom.styl，添加以下代码： 12345.content &#123; border-radius: 20px; //文章背景设置圆角 padding: 30px 60px 30px 60px; background:rgba(255, 255, 255, 0.8) none repeat scroll !important;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串常用方法]]></title>
    <url>%2F2018%2F12%2F19%2Fpython_02_%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.字符串的常用操作1) 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字，（常用） string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 2) 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 3) 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 4) 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 5) 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 6) 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格 string.splitlines() 按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 2.字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 1字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) =&gt; 开始索引 &gt;= 范围 &lt; 结束索引 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 演练需求 截取从 2 ~ 5 位置 的字符串 截取从 2 ~ 末尾 的字符串 截取从 开始 ~ 5 位置 的字符串 截取完整的字符串 从开始位置，每隔一个字符截取字符串 从索引 1 开始，每隔一个取一个 截取从 2 ~ 末尾 - 1 的字符串 截取字符串末尾两个字符 字符串的逆序（面试题） 答案 1234567891011121314151617181920212223242526272829303132num_str = &quot;0123456789&quot;# 1. 截取从 2 ~ 5 位置 的字符串print(num_str[2:6])# 2. 截取从 2 ~ `末尾` 的字符串print(num_str[2:])# 3. 截取从 `开始` ~ 5 位置 的字符串print(num_str[:6])# 4. 截取完整的字符串print(num_str[:])# 5. 从开始位置，每隔一个字符截取字符串print(num_str[::2])# 6. 从索引 1 开始，每隔一个取一个print(num_str[1::2])# 倒序切片# -1 表示倒数第一个字符print(num_str[-1])# 7. 截取从 2 ~ `末尾 - 1` 的字符串print(num_str[2:-1])# 8. 截取字符串末尾两个字符print(num_str[-2:])# 9. 字符串的逆序（面试题）print(num_str[::-1]) 公共方法1.Python 内置函数Python 包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 cmp(item1, item2) 比较两个值，-1 小于/0 相等/1 大于 Python 3.x 取消了 cmp 函数 注意 字符串 比较符合以下规则： “0” &lt; “A” &lt; “a” 2.切片 描述 Python 表达式 结果 支持的数据类型 切片 “0123456789”[::-2] “97531” 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 3.运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [“Hi!”] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 &gt; &gt;= == &lt; &lt;= (1, 2, 3) &lt; (2, 2, 3) True 元素比较 字符串、列表、元组 注意 in 在对 字典 操作时，判断的是 字典的键 in 和 not in 被称为 成员运算符 成员运算符成员运算符用于 测试 序列中是否包含指定的 成员 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对 字典 操作时，判断的是 字典的键 4.完整的 for 循环语法 在 Python 中完整的 for 循环 的语法如下： 12345for 变量 in 集合: 循环体代码else: 没有通过 break 退出循环，循环结束后，会执行的代码 应用场景 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含了多个字典 需求：要判断 某一个字典中 是否存在 指定的 值 如果 存在，提示并且退出循环 如果 不存在，在 循环整体结束 后，希望 得到一个统一的提示 123456789101112131415161718192021222324252627282930students = [ &#123;"name": "阿土", "age": 20, "gender": True, "height": 1.7, "weight": 75.0&#125;, &#123;"name": "小美", "age": 19, "gender": False, "height": 1.6, "weight": 45.0&#125;,]find_name = "阿土"for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict["name"] == find_name: print("找到了") # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 breakelse: print("没有找到")print("循环结束")]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gandiva Introspective Cluster Scheduling for Deep Learning]]></title>
    <url>%2F2018%2F12%2F07%2Fpaper_01_Gandiva%2F</url>
    <content type="text"><![CDATA[Gandiva: Introspective Cluster Scheduling for Deep Learning论文发表在OSDI’18会议上，是系统设计/实现方面的顶级会议。作者是微软的研究员们。 Abstract 深度学习的一个关键特征是反馈驱动探索，其中用户经常运行一组作业（或多作业）以搜索特定任务的最佳结果，并使用准确率等早期反馈来动态地优先化或结束一部分作业; 同时的早期反馈对整个多工作任务的进行至关重要。 第二个特征是深度学习工作在资源使用方面的异构性，难以实现最佳拟合。 Gandiva利用深度学习的第三个关键特征来解决这两个挑战：作业内可预测性，因为深度学习任务执行需要大量小批量重复迭代。 Gandiva利用作业内可预测性在多个作业中有效地对GPU进行时间分片，提供低延迟性。此可预测性还用于评估作业性能和动态迁移作业以更好地适应GPU，从而提高集群效率。 通过原型实现和微基准测试表明，Gandiva可以在深度学习期间将超参数搜索加速一个数量级，并通过透明迁移和时间切片从而实现更好的作业-资源匹配。实验表明，在180个GPU的集群中运行的实际工作负载中，Gandiva将聚合集群利用率提高了26％，表明这是一种管理大型GPU集群以进行深度学习的新方法。 1 Introduction深度学习是计算密集型的，严重依赖功能强大但价格昂贵的GPU;云中的GPU VM价格是普通VM的10倍。 云运营商和大公司依靠集群调度器来确保GPU的有效利用。 尽管高效调度深度学习训练（DLT）工作非常重要，但今天的常见做法是使用传统的集群调度程序，如Kubernetes或YARN这些用于处理大数据 MapReduce的工具; DLT作业被简单地视为大数据作业，在启动时分配一组GPU，并保持对其GPU的独占访问，直到完成为止。 DLT工作的一个关键特征是反馈驱动的探索（第2节）。由于深度学习实验固有的反复试验方法，用户通常会尝试几种任务的配置（多任务），并使用这些任务的早期反馈来决定是否优先考虑或结束它们的某些子集。这种称为超参数搜索的条件探索可以是手动的也可以是自动的。传统的调度程序在排队时运行一部分作业子集;这种模式不适合多任务，需要同时对多任务中的所有工作进行早期反馈。此外，与多任务一起，其他DLT作业已经确定了正确的超参数并运行了几个小时到几天，导致线头阻塞（长时间运行的作业可以独立访问GPU直到完成），而依赖在早期反馈的多任务仍排队等待。长队列时间迫使用户使用保留的GPU，或者要求群集过度配置，从而降低群集效率。 与任何其他群集工作负载一样，DLT作业是异构的，因为它们所针对的应用程序域不同。作业在内存使用，GPU核心利用率，带宽敏感度和其他作业的干扰性方面存在很大差异。例如，某些多GPU DLT作业可能对关联的GPU执行得更好，而其他作业可能对关联性不敏感（第3节）。将作业视为黑盒的传统调度程序因此将实现次优的集群效率。 为了解决高延迟和低效率这两个问题，Gandiva利用了DLT作业的强大属性：作业内可预测性（第3节）。一项任务由数百万个类似的，分开的小批量迭代组成。Gandiva利用这种循环可预测性来实现有效的应用感知时间切片; 它重新定义了从作业到自动划分的微任务的调度原子。这使集群能够超额预订DLT任务，并通过时间切片为所有DLT任务提供早期反馈（包括作为多任务一部分的所有作业）。 Gandiva还使用可预测性来执行简介驱动的内省。它使用小批量不断反省其决策，以提高集群效率（第4节）。例如，它只在内存和GPU利用率较低时才在同一GPU上打包多个作业; 它动态地将通信密集型作业迁移到更加接近的GPU上; 它还机会性地“增长”工作的并行度以利用备用资源，并在备用资源消失时缩减工作量。我们目前实施的内省策略是一种有状态的反复试验策略，由于我们考虑的可预测性和有限的选择状态空间，这是可行的。 除了本文评估的特定内省和调度策略之外，Gandiva框架还提供以下API，任何DLT调度策略都可以利用这些API：（a）有效的暂停 - 恢复或时间切片，（b）低延迟迁移，（c）细粒度分析，（d）动态的工作内弹性，以及（e）动态优先级。使这些原语高效和实用的关键是Gandiva的协同设计方法，跨越调度程序层和DLT工具包层，如Tensorflow或PyTorch。传统的调度程序，有充分的理由将工作视为一个黑盒子。 然而，通过利用GPU集群的专用特性，Gandiva将调度程序定制为深度学习的特定工作负载，从而为调度程序提供更多的可见性和对作业的控制，同时实现对任意DLT作业的通用性。 通过修改两个流行的框架PyTorch和Tensorflow来实现Gandiva，为调度程序提供必要的新原语，并在Kubernetes和Docker容器之上实现初始调度策略管理器（第5节）。 2 Background 反馈驱动的探索。实现高精度的一个先决条件是模型选择，像ResNet或Inception这样的模型通常是反复实验处理的过程，尽管自动化的方法是一个活跃的研究领域。除了模型结构之外，还有许多超参数需要指定为DLT作业的一部分。超参数包括模型中的层数/权重，批量大小，学习速率等。这些通常由用户根据领域知识和反复试验选择，有时甚至可能导致早期训练失败。 因此，DLT工作的早期反馈至关重要，特别是在训练的初始阶段。 多作业。 一旦用户识别出要进一步探索的特定模型，用户通常执行超参数搜索以提高任务准确性。这可以在超参数的空间上使用各种搜索技术来完成; 也就是说，用户生成多个DLT作业或多个作业，每个作业使用一组超参数或配置执行训练。由于用户通常会探索数百种此类配置，因此此过程的计算成本非常高。超参数搜索方法，如Hyper-Opt和Hyperband。Hyperband可能最初产生128个DLT作业，并且在每一轮（例如，100个小批量迭代）中，以最低精度结束一半的作业。对于这些算法，对工作的早期反馈至关重要，因为否则他们将无法做出有效的训练决策。 3 DLT Job Characteristics3.1 Sensitivity to locality多GPU DLT作业的性能取决于分配的GPU的亲和性。不同的DLT作业对GPU间亲和力表现出不同的灵敏度。即使对于同一台机器上的GPU，由于非对称架构，我们观察到不同级别的GPU间亲和性：两个GPU可能位于不同的CPU插槽中（表示为DiffSocket），位于同一CPU插槽中，但位于不同的PCIe交换机上（表示如同SameSocket），或在同一个PCIe交换机上（表示为SamePCIeSw）。 图1显示了VGG16和ResNet-50对服务器内局部性的不同敏感性。当使用Tensorflow对两个P100 GPU进行训练时，VGG16受到严重影响。当两个GPU位于不同的CPU插槽中时，VGG16仅实现最佳位置配置的60％，其中两个GPU放置在同一PCIe交换机下。另一方面，ResNet-50在此设置中不受GPU位置的影响。这是因为VGG16是一个比ResNet-50更大的神经模型，因此每个小批量的模型同步会在底层PCIe总线上产生更高的通信负载。 我们在分布式设置中观察到类似的趋势。显示了不同服务器间位置，训练ResNet-50和InceptionV3模型的4-GPU Tensorflow作业的性能。即使与40G InfiniBand网络互连，当作业分配到4个GPU时，也可以清楚地看到性能差异，它们均匀分散在4个服务器（表示为4 1-GPU），2个服务器（表示为2 2） -GPU），以及所有在一个服务器（表示为本地4-GPU），尽管两个模型的局部性的敏感性是不同的。因此，DLT调度程序在分配GPU时必须考虑作业对位置的敏感性。 3.2 Sensitivity to interference在共享执行环境中运行时，由于资源争用，DLT作业可能会相互干扰。我们再次观察到不同的DLT作业表现出不同程度的干扰。 对于单GPU作业也存在干扰。 将语言模型作业（标记为LM）与另一个作业放在同一PCI-e交换机下时，显示了由于服务器内干扰导致的性能下降。当两个LM一起运行时，两个工作都会减速19％。 但是，ResNet-50不会受到与LM共存的GPU的影响。 神经机器翻译（GNMT）表现出对LM的适度干扰。 显示了与40G InfiniBand网络连接的两台4 GPU服务器之间的服务器间干扰。 当运行多个2-GPU作业时，每个GPU放置在不同的服务器上，ResNet-50显示减速高达47％，InceptionV3显示减速30％，而DeepSpeech仅显示5％减速。 3.3 Intra-job predictabilityDLT作业包含许多小批量迭代。图5（a）中显示了在四个K80 GPU上使用ResNet-50模型时，在20秒的ImageNet数据训练期间使用的总GPU内存。所使用的GPU存储器明显遵循循环模式。这些循环中的每一个对应于单个小批量（约1.5s）的处理，其中存储器在正向传播期间增加并且在反向传播期间减小。使用的最大和最小GPU内存分别为23GB和0.3GB，为77倍。该比例与小批量大小成比例（通常在16到256之间;在这种情况下为128）。 在图5（b）中显示了在一个K80 GPU上使用GNMT模型时，在WMT’14 English German language数据集训练期间使用的总GPU内存。虽然小批量迭代在ImageNet示例中彼此不相同（由于不同的句子长度和PyTorch中动态图形的使用），图形具有类似的循环性质。最大值和最小值之间的差异较小（3x）主要是由于较大型号（0.4GB）和较小的小批量（本例中为16）。 除了此处显示的图像和语言模型之外，其他训练领域，如语音，GAN和变分自动编码器都遵循类似的循环模式（由于空间限制而未显示），因为训练的核心都是梯度下降算法执行许多小批量迭代。 利用可预测性。这种特征在Gandiva中以多种方式被利用。 首先，DLT作业可以自动拆分为小批量迭代，并且超过60秒的这些迭代的集合（微任务），形成调度间隔。其次，通过在存储器周期的最小值处执行挂起操作，可以显着减少要从GPU复制以保存在CPU中的存储量，从而使挂起/恢复和迁移能够比天真的实施更高效一个数量级。第三，可以对小批量进步率进行分析并将其用作代理，以评估应用包装或迁移等机制的有效性。 4 Design 由于DLT作业被分配了一组固定的GPU（图6），因此集群出现高延迟和低利用率。 对GPU的独占访问会导致行头阻塞；阻止早期反馈；导致传入作业的高排队时间。 当作业无法完全利用其分配的GPU时，对固定GPU的独占访问也会导致GPU利用率降低。 4.1 Mechanisms在Gandiva中，我们通过三种方式消除GPU对DLT作业的排他性和固定分配来解决这些低效问题（图6） Suspend-Resume and Packing。暂停 - 恢复是Gandiva用于删除一组GPU对DLT作业排他性的一种机制。现代操作系统支持CPU进程的高效挂起 - 恢复的时间切片。Gandiva利用这种机制并为GPU时间切片添加了自定义支持。如图5（a）所示，DLT作业对GPU内存的使用具有循环模式，最小和最大内存使用之间的差异高达77倍。 Gandiva的关键思想是利用这种循环行为，并在GPU内存使用率最低时采取暂停-恢复DLT作业。因此，当发出挂起调用时，DLT工具包会等待内存使用周期的最小值，将存储在GPU中的对象复制到CPU，释放所有GPU内存分配（包括缓存），然后调用经典CPU暂停机制。稍后，当CPU恢复作业时，DLT框架首先分配适当的GPU内存，将存储的对象复制回GPU，然后恢复作业。暂停 - 恢复还可以在同一服务器内改变GPU（例如，在六个1-GPU作业分时4-GPU的情况下）。 虽然更换GPU很昂贵，但我们会将这种延迟隐藏在关键路径之外。正如我们在评估（第6.1节）中所示，对于典型的图像分类工作，可以在100ms内完成暂停 - 恢复，而对于大型语言翻译工作，暂停 - 恢复可能需要1s。 给定1分钟的时间片间隔，这相当于2％或更少的开销。请注意，Gandiva中的暂停可能会延迟最多一个DLT作业的小批量间隔（通常为几秒或更短），但我们认为这是值得的权衡，因为它可以显着减少开销。 降低了GPU-CPU复制成本，减少了CPU中使用的内存。 此外，在此延迟期间完成了有用的工作。调度程序跟踪此延迟并相应地调整时间切片间隔以确保公平性。暂停 - 恢复时间切片的替代方法是同时在GPU上运行多个DLT作业，让GPU共享作业。我们称之为包装。 只有当打包作业不超过GPU资源（核心，内存）并且不会相互产生负面影响时，GPU中的打包才有效。 如果工作干扰，包装可能比暂停 - 恢复更糟糕（第6.1节）。 我们使用分析来监视DLT作业具有独占访问权限时的资源和进度。 如果两个工作被确定为包装的候选人，我们将它们打包在一起并继续监控它们。 如果给定的包装对工作效率产生不利影响，我们会拆开这些工作并返回暂停 - 恢复。 Migration。 迁移是Gandiva用于更改分配给DLT作业的GPU集合的机制。 迁移在以下几种情况下非常有用：i）将时间切片的作业移动到群集中腾出的任何位置的GPU;ii）将干扰工作相互迁移开;iii）群集的碎片化，以便传入的作业获得具有良好局部性的GPU。我们评估了两种解决DLT流程状态迁移的方法。（1）在第一种方法中，我们利用通用的流程迁移机制，如CRIU。因为CRIU本身不支持使用GPU设备的进程迁移，所以我们首先对GPU对象创建检查点并在调用CRIU之前从进程中删除所有GPU状态。 由于CRIU检查点并恢复整个进程内存，因此使用PyTorch检查点的大小为GB数量级。因此，对于单GPU作业，所产生的迁移开销约为8-10s，对于多GPU作业，则更高。（2）的第二种方法是使用支持检查点的DLT作业。诸如Tensorflow之类的DLT框架已经支持创建自动检查点和模型恢复的API（例如，tensorflow.train.saver）。此API现在用于确保不必因服务器故障而重新运行长时间运行的作业。我们扩展框架以支持此类工作的迁移。通过在迁移之前”预热“目的地并且仅迁移必要的训练状态，我们可以将迁移率减少到一秒或两秒（第6.1节）。无论采用哪种方法，我们都发现服务器间迁移的开销与其提供的更高整体GPU利用率相比是值得的。 Grow-Shrink。 Gandiva用于消除GPU对DLT作业的排他性的第三种机制是成长-缩减。该机制主要针对群集可能无法充分利用的情况，例如深夜时。基本思想是在空闲时机会性地增加可用于工作的GPU的数量，并且相应地减少负载增加时可用的GPU的数量。许多DLT作业（尤其是图像域中的作业）随着GPU数量的增加而看到线性性能缩放。Gandiva仅将这种机制应用于那些明确表明其足够自适应以利用这些增长机会的DLT工作。当多个DLT作业符合此标准时，Gandiva使用下面讨论的分析信息来估计每个作业的进度，然后相应地分配GPU。 Profiling。与任何调度程序一样，Gandiva监视资源使用情况，例如CPU和GPU利用率，CPU / GPU内存等。然而，Gandiva的独特之处在于它还以应用程序感知的方式内省DLT作业估计其进度。 这种内省利用了DLT作业（第3节）展示的规则模式，并使用周期性来估计其进度。Gandiva估计DLT作业的小批处理时间，即对一批输入数据进行一次前向/后向传递的时间，作为GPU内存使用周期的两个最小值之间所花费的时间（图5（a））。 由于DLT作业通常在其生命周期中执行数百万个这样的小批量操作，因此调度程序在调度决策之前和之后比较DLT的小批量时间以确定其有效性。例如，考虑在前面描述的GPU中打包两个DLT作业的示例。 通过比较包装前后两个DLT作业中每个作业的小批量时间，Gandiva可以决定包装是否有效。 如果没有这样的分析，为了做出包装决定，人们不仅要模拟两个DLT作业在各种GPU上的性能，还要模拟它们可能相互干扰的各种方式（例如，高速缓存，内存带宽等）。 。），这是一项非常重要的任务，我们在第6.1节中看到了不同的包装性能。 7 Related Work略 8 Conclusion略]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>深度学习任务调度 - 论文阅读 - 科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm常用知识]]></title>
    <url>%2F2018%2F12%2F05%2Fpython_01_pycharm%2F</url>
    <content type="text"><![CDATA[PyCharm 的初始设置目标 恢复 PyCharm 的初始设置 第一次启动 PyCharm 新建一个 Python 项目 设置 PyCharm 的字体显示 PyCharm 的升级以及其他 PyCharm 的官方网站地址是：https://www.jetbrains.com/pycharm/ 01. 恢复 PyCharm 的初始设置PyCharm 的 配置信息 是保存在 用户家目录下 的 .PyCharmxxxx.x 目录下的，xxxx.x 表示当前使用的 PyCharm 的版本号 如果要恢复 PyCharm 的初始设置，可以按照以下步骤进行： 关闭正在运行的 PyCharm 在终端中执行以下终端命令，删除 PyCharm 的配置信息目录： 1$ rm -r ~/.PyCharm2016.3 重新启动 PyCharm 02. 设置 PyCharm 的字体显示 03. PyCharm 的升级以及其他 PyCharm 提供了对 学生和教师免费使用的版本 教育版下载地址：https://www.jetbrains.com/pycharm-edu/download/#section=linux 专业版下载地址：https://www.jetbrains.com/pycharm/download/#section=linux 3.1 安装和启动步骤 执行以下终端命令，解压缩下载后的安装包 1$ tar -zxvf pycharm-professional-2017.1.3.tar.gz 将解压缩后的目录移动到 /opt 目录下，可以方便其他用户使用 /opt 目录用户存放给主机额外安装的软件 1$ sudo mv pycharm-2017.1.3/ /opt/ 切换工作目录 1$ cd /opt/pycharm-2017.1.3/bin 启动 PyCharm 1$ ./pycharm.sh 3.2 设置专业版启动图标 在专业版中，选择菜单 Tools / Create Desktop Entry… 可以设置任务栏启动图标 注意：设置图标时，需要勾选 Create the entry for all users 3.3 卸载之前版本的 PyCharm1) 程序安装 程序文件目录 将安装包解压缩，并且移动到 /opt 目录下 所有的相关文件都保存在解压缩的目录中 配置文件目录 启动 PyCharm 后，会在用户家目录下建立一个 .PyCharmxxx 的隐藏目录 保存 PyCharm 相关的配置信息 快捷方式文件 /usr/share/applications/jetbrains-pycharm.desktop 在 ubuntu 中，应用程序启动的快捷方式通常都保存在 /usr/share/applications 目录下 2) 程序卸载 要卸载 PyCharm 只需要做以下两步工作： 删除解压缩目录 1$ sudo rm -r /opt/pycharm-2016.3.1/ 删除家目录下用于保存配置信息的隐藏目录 1$ rm -r ~/.PyCharm2016.3/ 如果不再使用 PyCharm 还需要将 /usr/share/applications/ 下的 jetbrains-pycharm.desktop 删掉]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F12%2F04%2Flinux_01_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux终端命令的重要性 Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如 磁盘操作、文件存取、目录操作、进程管理、文件权限 设定等 大量的 服务器维护工作 都是在 远程 通过 SSH 客户端 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成 作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令 Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已 学习终端命令： 不需要死记硬背，对于常用命令，用的多了，自然就记住了 不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到百度就可以 常用 Linux 命令 序号 命令 含义 作用 01 ls list 查看当前文件夹下的内容 02 pwd print wrok directory 查看当前所在文件夹 03 cd [目录名] change directory 切换文件夹 04 touch [文件名] touch 如果文件不存在，新建文件 05 mkdir [目录名] make directory 创建目录 06 rm [文件名] remove 删除指定的文件名 07 clear clear 清屏 技巧 ctrl + shift + = 放大终端窗口的字体显示 ctrl + - 缩小终端窗口的字体显示 自动补全 敲出 文件／目录／命令 的前几个字母之后，按下 tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 技巧 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux - 学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP1]]></title>
    <url>%2F2018%2F11%2F29%2FNLP_01%2F</url>
    <content type="text"><![CDATA[CS224N自然语言处理自然语言处理的目标是让计算机处理或说“理解”自然语言，以完成有意义的任务，比如订机票购物或QA等。完全理解和表达语言是极其困难的，完美的语言理解等效于实现人工智能。 作为输入一共有两个来源，语音与文本。所以第一级是语音识别和OCR或分词。形态分析（Morphological）是分析该词的构造形式（主要针对英语而言，例如，uninterested = un(前缀）+ interest(词干) + ed(后缀)）。句法分析是确定句子的语法结构句子中词汇之间的依存关系。本课程着重讲解句法分析和语义表示。 自然语言处理的应用 拼写检查、关键词检索…… 文本挖掘（产品价格、日期、时间、地点、人名、公司名） 文本分类 机器翻译 客服系统 复杂对话系统 在工业界从搜索到广告投放、自动\辅助翻译、情感舆情分析、语音识别、聊天机器人等。 人类语言的特殊之处与信号处理、数据挖掘不同，自然语言的随机性小而目的性强；语言是用来传输有意义的信息的，这种传输连小孩子都能很快学会。人类语言是离散的、明确的符号系统。但又允许出现各种变种，比如颜文字，随意的错误拼写“I loooove it”。这种自由性可能是因为语言的可靠性（赘余性）。所以说语言文字绝对不是形式逻辑或传统AI的产物。语言符号有多种形式（声音、手势、书写），在这些不同的形式中，其意义保持不变。虽然人类语言是明确的符号系统，但符号传输到大脑的过程是通过连续的声学光学信号，大脑编码似乎是连续的激活值上的模式。另外巨大的词表也导致数据稀疏，不利于机器学习。这构成一种动机，是不是应该用连续的信号而不是离散的符号去处理语言。 因为NVDIA官网即使是科学上网也经常崩，所以把百度网盘连接分享到文件里，需要的可以自取，密码ia9l 安装过程只要要三步： （1）下载并安装cuda9.1 （2）下载并安装cudnn7.1 (3) 下载并安装annaconda3-5.1.0 注意：1.查看cuda能否安装成功：在cmd(win+r)中输入：nvcc -V 2.安装cudnn7.0详细方法： 将cudnn压缩包中所有文件放入1C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0 目录下对应目录中，同时将1C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\extras\CUPTI\libx64\cupti64_91.dll 拷贝到1C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\bin CUDA环境测试CMD中输入1nvcc -V 如果成功出现下图，则说明CUDA和Cudnn已经配置成功 安装tensorflow打开Anaconda Prompt，创建tensorflow虚拟环境1conda create -n tensorflow python=3.5 然后启用虚拟环境1activate tensorflow 最后安装tensorflow1pip install tensorflow-gpu 如果安装速度较慢，可以使用清华大学开源软件镜像站的TensorFlow 镜像。 测试tensorflow安装情况在刚才的Anaconda Prompt中输入1Python 在Python的交互界面中输入12345import tensorflow as tfhello=tf.constant(&apos;Hello tensorflow!&apos;)sess=tf.Session()sess.run(hello)sess.close() 然后激动人心的时刻，我们可以使用TF了。 可能出现的问题 找不到cudart64_90.dll: ImportError: DLL loaded failed: 找不到指定模块出现上述问题是显卡驱动没有更新，手动到NVDIA对应网站下载对应显卡最新驱动安装，即可。 额外内容为了方便之后的开发，我们可以安装Spyder这款十分强大的科学计算IDE。首先添加清华大学镜像源12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 然后1conda install spyder 记得输入Yes，这样进行深度学习的环境就配置好了。 To be continue。。。]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP - 学习 - 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客正式上线]]></title>
    <url>%2F2018%2F09%2F20%2Ffirst_blog%2F</url>
    <content type="text"><![CDATA[博客正式上线想了好久的博客现在终于用上了，准备记录一下自己研究生期间的所学和所思所想吧。也把个人博客作为展示自己的一个平台，为之后工作、科研做些积累。 A Good Programmer’s abilityA fool can write code that a computer can understand.Good programmers write code that humans can understand. Hexo 指令Quick startCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow内核学习]]></title>
    <url>%2F2018%2F09%2F20%2Ftensor_01_TF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Tensorflow内核探究1研究生期间要做的课题是深度学习inference任务的加速和调度问题，因为已经有很多不错的开源深度学习框架（Tensorflow，Pytorch2，Caffe2。。。），所以想在框架的基础上来做调度器和加速。然后Google大法确实厉害，有很多充足的文档、资料和论文实现，所以决定以Tensorflow入手，最近在学习Tensorflow的相关实现和原理，想在这篇博客里总结一下所学。 Tensorflow GPU版本安装要安装进行train，inference加速，我们需要一块好的GPU。如果你有NVDIA 1080 Ti或者NVDIA TitanX，那加速效果可能达到10——20倍，效果是很直观的。其他Nvdia显卡也可以，只是性能没有这么好。可以在NVDIA官网查看市面上常用显卡的计算性（使用Tensorflow GPU版本需要大于等于3.0以上的显卡）Nvdia显卡计算性 安装包准备安装的Tensorflow为V1.8版本，需要CUDA9.0和Cudnn7.1，推荐使用Anaconda来使用Tensorflow。anaconda3-5.1.0-windows10cuda-9.1-windows10cudnn-7.1-windows10关于Tensorflow和CUDA，Cudnn的版本对应关系可以参考下图。 Tensorflow版本 CUDA版本 Cudnn版本 Python版本 1.1-1.2 8.0 v5.1 3.5 1.3 8.0 v6，V6.1 3.5，3.6 1.4 8.0 V6.1 3.5，3.6 1.5-1.8 9.0 V7.0 3.5，3.6 因为NVDIA官网即使是科学上网也经常崩，所以把百度网盘连接分享到文件里，需要的可以自取，密码ia9l 安装过程只要要三步： （1）下载并安装cuda9.1 （2）下载并安装cudnn7.1 (3) 下载并安装annaconda3-5.1.0 注意：1.查看cuda能否安装成功：在cmd(win+r)中输入：nvcc -V 2.安装cudnn7.0详细方法： 将cudnn压缩包中所有文件放入1C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0 目录下对应目录中，同时将1C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\extras\CUPTI\libx64\cupti64_91.dll 拷贝到1C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\bin CUDA环境测试CMD中输入1nvcc -V 如果成功出现下图，则说明CUDA和Cudnn已经配置成功 安装tensorflow打开Anaconda Prompt，创建tensorflow虚拟环境1conda create -n tensorflow python=3.5 然后启用虚拟环境1activate tensorflow 最后安装tensorflow1pip install tensorflow-gpu 如果安装速度较慢，可以使用清华大学开源软件镜像站的TensorFlow 镜像。 测试tensorflow安装情况在刚才的Anaconda Prompt中输入1Python 在Python的交互界面中输入12345import tensorflow as tfhello=tf.constant(&apos;Hello tensorflow!&apos;)sess=tf.Session()sess.run(hello)sess.close() 然后激动人心的时刻，我们可以使用TF了。 可能出现的问题 找不到cudart64_90.dll: ImportError: DLL loaded failed: 找不到指定模块出现上述问题是显卡驱动没有更新，手动到NVDIA对应网站下载对应显卡最新驱动安装，即可。 额外内容为了方便之后的开发，我们可以安装Spyder这款十分强大的科学计算IDE。首先添加清华大学镜像源12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 然后1conda install spyder 记得输入Yes，这样进行深度学习的环境就配置好了。 To be continue。。。]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>科研 - 学习</tag>
      </tags>
  </entry>
</search>
